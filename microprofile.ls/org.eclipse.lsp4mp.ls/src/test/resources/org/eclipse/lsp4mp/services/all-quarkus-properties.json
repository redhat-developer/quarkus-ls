{
  "projectURI": "C:\\Users\\azerr\\git\\quarkus-ls\\microprofile.jdt\\org.eclipse.lsp4mp.jdt.test\\target\\workingProjects\\maven\\all-quarkus-extensions",
  "classpathKind": 2,
  "properties": [
    {
      "type": "java.lang.String",
      "extensionName": "microprofile-metrics-api",
      "required": false,
      "phase": 0,
      "name": "mp.metrics.tags",
      "description": "List of tag values.\r\nTag values set through `mp.metrics.tags` MUST escape equal symbols `\u003d` and commas `,` with a backslash `\\`."
    },
    {
      "type": "java.lang.String",
      "extensionName": "microprofile-metrics-api",
      "required": false,
      "phase": 0,
      "name": "mp.metrics.appName",
      "description": "The app name."
    },
    {
      "type": "java.util.regex.Pattern",
      "extensionName": "microprofile-opentracing-api",
      "required": false,
      "phase": 0,
      "name": "mp.opentracing.server.skip-pattern",
      "description": "Specifies a skip pattern to avoid tracing of selected REST endpoints."
    },
    {
      "type": "\"http-path\" or \"class-method\"",
      "defaultValue": "class-method",
      "extensionName": "microprofile-opentracing-api",
      "required": false,
      "phase": 0,
      "name": "mp.opentracing.server.operation-name-provider",
      "description": "Specifies operation name provider for server spans. Possible values are `http-path` and `class-method`."
    },
    {
      "type": "java.lang.String",
      "extensionName": "microprofile-openapi-api",
      "required": true,
      "phase": 0,
      "name": "mp.openapi.model.reader",
      "description": "Configuration property to specify the fully qualified name of the OASModelReader implementation."
    },
    {
      "type": "java.lang.String",
      "extensionName": "microprofile-openapi-api",
      "required": true,
      "phase": 0,
      "name": "mp.openapi.filter",
      "description": "Configuration property to specify the fully qualified name of the OASFilter implementation."
    },
    {
      "type": "boolean",
      "defaultValue": "false",
      "extensionName": "microprofile-openapi-api",
      "required": false,
      "phase": 0,
      "name": "mp.openapi.scan.disable",
      "description": "Configuration property to disable annotation scanning. Default value is `false`."
    },
    {
      "type": "java.lang.String",
      "extensionName": "microprofile-openapi-api",
      "required": true,
      "phase": 0,
      "name": "mp.openapi.scan.packages",
      "description": "Configuration property to specify the list of packages to scan.\r\nFor example, `mp.openapi.scan.packages\u003dcom.xyz.PackageA,com.xyz.PackageB`."
    },
    {
      "type": "java.lang.String",
      "extensionName": "microprofile-openapi-api",
      "required": true,
      "phase": 0,
      "name": "mp.openapi.scan.classes",
      "description": "Configuration property to specify the list of classes to scan.\r\nFor example, `mp.openapi.scan.classes\u003dcom.xyz.MyClassA,com.xyz.MyClassB`."
    },
    {
      "type": "java.lang.String",
      "extensionName": "microprofile-openapi-api",
      "required": true,
      "phase": 0,
      "name": "mp.openapi.scan.exclude.packages",
      "description": "Configuration property to specify the list of packages to exclude from scans.\r\nFor example, `mp.openapi.scan.exclude.packages\u003dcom.xyz.PackageC,com.xyz.PackageD`."
    },
    {
      "type": "java.lang.String",
      "extensionName": "microprofile-openapi-api",
      "required": true,
      "phase": 0,
      "name": "mp.openapi.scan.exclude.classes",
      "description": "Configuration property to specify the list of classes to exclude from scans.\r\nFor example, `mp.openapi.scan.exclude.classes\u003dcom.xyz.MyClassC,com.xyz.MyClassD`."
    },
    {
      "type": "java.lang.String",
      "extensionName": "microprofile-openapi-api",
      "required": true,
      "phase": 0,
      "name": "mp.openapi.servers",
      "description": "Configuration property to specify the list of global servers that provide connectivity information.\r\nFor example, `mp.openapi.servers\u003dhttps://xyz.com/v1,https://abc.com/v1`."
    },
    {
      "type": "java.lang.String",
      "extensionName": "microprofile-openapi-api",
      "required": true,
      "phase": 0,
      "name": "mp.openapi.servers.path.{*}",
      "description": "Prefix of the configuration property to specify an alternative list of servers to service all operations in a path.For example, `mp.openapi.servers.path./airlines/bookings/{id}\u003dhttps://xyz.io/v1`."
    },
    {
      "type": "java.lang.String",
      "extensionName": "microprofile-openapi-api",
      "required": true,
      "phase": 0,
      "name": "mp.openapi.servers.operation.{*}",
      "description": "Prefix of the configuration property to specify an alternative list of servers to service an operation.Operations that want to specify an alternative list of servers must define an `operationId`, a unique string used to identify the operation.For example, `mp.openapi.servers.operation.getBooking\u003dhttps://abc.io/v1`."
    },
    {
      "type": "java.lang.String",
      "extensionName": "microprofile-openapi-api",
      "required": true,
      "phase": 0,
      "name": "mp.openapi.schema.{*}",
      "description": "Prefix of the configuration property to specify a schema for a specific class, in JSON format.The remainder of the property key must be the fully-qualified class name.The value must be a valid OpenAPI schema object, specified in the JSON format.The use of this property is functionally equivalent to the use of the `@Schema` annotationon a Java class, but may be used in cases where the application developer does not have access to the source code of a class."
    },
    {
      "type": "boolean",
      "sourceMethod": "enabled()Z",
      "defaultValue": "true",
      "required": false,
      "phase": 0,
      "name": "docker.enabled",
      "sourceType": "io.dekorate.docker.annotation.DockerBuild"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "registry()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "docker.registry",
      "description": "The registry that holds the image.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The registry or empty string if no registry has been specified.",
      "sourceType": "io.dekorate.docker.annotation.DockerBuild"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "group()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "docker.group",
      "description": "The group of the application. This value will be use as image user.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The specified group name.",
      "sourceType": "io.dekorate.docker.annotation.DockerBuild"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "docker.name",
      "description": "The name of the application. This value will be used as name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The specified application name.",
      "sourceType": "io.dekorate.docker.annotation.DockerBuild"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "version()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "docker.version",
      "description": "The version of the application. This value be used as image tag.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The version.",
      "sourceType": "io.dekorate.docker.annotation.DockerBuild"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "image()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "docker.image",
      "sourceType": "io.dekorate.docker.annotation.DockerBuild"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "dockerFile()Ljava/lang/String;",
      "defaultValue": "Dockerfile",
      "required": false,
      "phase": 0,
      "name": "docker.docker-file",
      "description": "The relative path of the Dockerfile, from the module root.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The relative path.",
      "sourceType": "io.dekorate.docker.annotation.DockerBuild"
    },
    {
      "type": "boolean",
      "sourceMethod": "autoPushEnabled()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "docker.auto-push-enabled",
      "description": "Flag to automatically push the image, to the specified registry.\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if hook is to be registered, false otherwise.",
      "sourceType": "io.dekorate.docker.annotation.DockerBuild"
    },
    {
      "type": "boolean",
      "sourceMethod": "autoBuildEnabled()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "docker.auto-build-enabled",
      "description": "Flag to automatically register a build hook after compilation.\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if hook is to be registered, false otherwise.",
      "sourceType": "io.dekorate.docker.annotation.DockerBuild"
    },
    {
      "type": "boolean",
      "sourceMethod": "autoDeployEnabled()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "docker.auto-deploy-enabled",
      "description": "Flag to trigger the registration of the deploy hook. It\u0027s generally preferable to use \\`-Ddekorate.deploy\u003dtrue\\` instead of hardcoding this here.\r\n\r\n *  **Returns:**\r\n    \r\n     *  True for automatic registration of the build hook.",
      "sourceType": "io.dekorate.docker.annotation.DockerBuild"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "partOf()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.part-of",
      "description": "The name of the collection of componnet this component belongs to. This value will be use as: - labeling resources\r\n\r\n *  **Returns:**\r\n    \r\n     *  The specified group name.",
      "sourceType": "io.dekorate.openshift.annotation.OpenshiftApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.name",
      "description": "The name of the application. This value will be used for naming Kubernetes resources like: - Deployment - Service and so on ... If no value is specified it will attempt to determine the name using the following rules: If its a maven/gradle project use the artifact id. Else if its a bazel project use the name. Else if the system property app.name is present it will be used. Else find the project root folder and use its name (root folder detection is done by moving to the parent folder until .git is found).\r\n\r\n *  **Returns:**\r\n    \r\n     *  The specified application name.",
      "sourceType": "io.dekorate.openshift.annotation.OpenshiftApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "version()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.version",
      "description": "The version of the application. This value be used for things like: - The docker image tag. If no value specified it will attempt to determine the name using the following rules:\r\n\r\n *  **Returns:**\r\n    \r\n     *  The version.",
      "sourceType": "io.dekorate.openshift.annotation.OpenshiftApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "image()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].image",
      "description": "The container image.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The container image.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].name",
      "description": "The container name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The container name, or the name part of the image, if no name has been specified.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].env-vars[*].name",
      "description": "The name of the environment variable.\r\n\r\n *  **Returns:**\r\n    \r\n     *  the name.",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "value()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].env-vars[*].value",
      "description": "The value of the environment variable. When no other fields are used (just name/value), this value will be assigned to the environment variable. If used with other fields, like secret, configmap, or field, it will indicate the key from with the value should be drawn.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The value of the variable, or the property/key from which the value will be pulled (in case of secret, configmap or field).",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "secret()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].env-vars[*].secret",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "configmap()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].env-vars[*].configmap",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "field()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].env-vars[*].field",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "workingDir()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].working-dir",
      "description": "Working directory.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The working directory if specified, else empty string.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "command()[Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].command[*]",
      "description": "The commands\r\n\r\n *  **Returns:**\r\n    \r\n     *  The commands.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "arguments()[Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].arguments[*]",
      "description": "The arguments\r\n\r\n *  **Returns:**\r\n    \r\n     *  The arguments.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].ports[*].name",
      "description": "The container port name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "int",
      "sourceMethod": "containerPort()I",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].ports[*].container-port",
      "description": "The port number. Refers to the container port.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The port number.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "int",
      "sourceMethod": "hostPort()I",
      "defaultValue": "0",
      "required": false,
      "phase": 0,
      "name": "openshift.init-containers[*].ports[*].host-port",
      "description": "The host port. When a host port is not specified (or is set to 0) then the container port will be used.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The host port, or 0 if none specified.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "path()Ljava/lang/String;",
      "defaultValue": "/",
      "required": false,
      "phase": 0,
      "name": "openshift.init-containers[*].ports[*].path",
      "description": "The application path (refers to web application path).\r\n\r\n *  **Returns:**\r\n    \r\n     *  The path, defaults to /.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.Protocol",
      "sourceMethod": "protocol()Lio/dekorate/kubernetes/annotation/Protocol;",
      "defaultValue": "TCP",
      "required": false,
      "phase": 0,
      "name": "openshift.init-containers[*].ports[*].protocol",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].mounts[*].name",
      "description": "The name of the volumeName to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "path()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].mounts[*].path",
      "description": "The path to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The path.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "subPath()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].mounts[*].sub-path",
      "description": "Path within the volumeName from which the container\u0027s volumeName should be mounted.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The subPath.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "boolean",
      "sourceMethod": "readOnly()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "openshift.init-containers[*].mounts[*].read-only",
      "description": "ReadOnly\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if mount is readonly, False otherwise.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.ImagePullPolicy",
      "sourceMethod": "imagePullPolicy()Lio/dekorate/kubernetes/annotation/ImagePullPolicy;",
      "defaultValue": "IfNotPresent",
      "required": false,
      "phase": 0,
      "name": "openshift.init-containers[*].image-pull-policy",
      "description": "Image pull policy.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The image pull policy.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "httpActionPath()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].liveness-probe.http-action-path",
      "description": "The http path to use for the probe For this to work, the container port also needs to be set Assuming the container port has been set (as per above comment), if execAction or tcpSocketAction are not set, an http probe will be used automatically even if no path is set (which will result in the root path being used)",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "execAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].liveness-probe.exec-action",
      "description": "The command to use for the probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The command.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "tcpSocketAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].liveness-probe.tcp-socket-action",
      "description": "The tcp socket to use for the probe (the format is host:port).\r\n\r\n *  **Returns:**\r\n    \r\n     *  The string representation of the socket.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "initialDelaySeconds()I",
      "defaultValue": "0",
      "required": false,
      "phase": 0,
      "name": "openshift.init-containers[*].liveness-probe.initial-delay-seconds",
      "description": "The amount of time to wait in seconds before starting to probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The initial delay.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "periodSeconds()I",
      "defaultValue": "30",
      "required": false,
      "phase": 0,
      "name": "openshift.init-containers[*].liveness-probe.period-seconds",
      "description": "The period in which the action should be called.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The period.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "timeoutSeconds()I",
      "defaultValue": "10",
      "required": false,
      "phase": 0,
      "name": "openshift.init-containers[*].liveness-probe.timeout-seconds",
      "description": "The amount of time to wait for each action.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The timeout.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "successThreshold()I",
      "defaultValue": "1",
      "required": false,
      "phase": 0,
      "name": "openshift.init-containers[*].liveness-probe.success-threshold",
      "description": "The success threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "failureThreshold()I",
      "defaultValue": "3",
      "required": false,
      "phase": 0,
      "name": "openshift.init-containers[*].liveness-probe.failure-threshold",
      "description": "The failure threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "httpActionPath()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].readiness-probe.http-action-path",
      "description": "The http path to use for the probe For this to work, the container port also needs to be set Assuming the container port has been set (as per above comment), if execAction or tcpSocketAction are not set, an http probe will be used automatically even if no path is set (which will result in the root path being used)",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "execAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].readiness-probe.exec-action",
      "description": "The command to use for the probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The command.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "tcpSocketAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.init-containers[*].readiness-probe.tcp-socket-action",
      "description": "The tcp socket to use for the probe (the format is host:port).\r\n\r\n *  **Returns:**\r\n    \r\n     *  The string representation of the socket.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "initialDelaySeconds()I",
      "defaultValue": "0",
      "required": false,
      "phase": 0,
      "name": "openshift.init-containers[*].readiness-probe.initial-delay-seconds",
      "description": "The amount of time to wait in seconds before starting to probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The initial delay.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "periodSeconds()I",
      "defaultValue": "30",
      "required": false,
      "phase": 0,
      "name": "openshift.init-containers[*].readiness-probe.period-seconds",
      "description": "The period in which the action should be called.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The period.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "timeoutSeconds()I",
      "defaultValue": "10",
      "required": false,
      "phase": 0,
      "name": "openshift.init-containers[*].readiness-probe.timeout-seconds",
      "description": "The amount of time to wait for each action.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The timeout.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "successThreshold()I",
      "defaultValue": "1",
      "required": false,
      "phase": 0,
      "name": "openshift.init-containers[*].readiness-probe.success-threshold",
      "description": "The success threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "failureThreshold()I",
      "defaultValue": "3",
      "required": false,
      "phase": 0,
      "name": "openshift.init-containers[*].readiness-probe.failure-threshold",
      "description": "The failure threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "key()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.labels[*].key",
      "sourceType": "io.dekorate.kubernetes.annotation.Label"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "value()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.labels[*].value",
      "sourceType": "io.dekorate.kubernetes.annotation.Label"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "key()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.annotations[*].key",
      "sourceType": "io.dekorate.kubernetes.annotation.Annotation"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "value()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.annotations[*].value",
      "sourceType": "io.dekorate.kubernetes.annotation.Annotation"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.env-vars[*].name",
      "description": "The name of the environment variable.\r\n\r\n *  **Returns:**\r\n    \r\n     *  the name.",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "value()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.env-vars[*].value",
      "description": "The value of the environment variable. When no other fields are used (just name/value), this value will be assigned to the environment variable. If used with other fields, like secret, configmap, or field, it will indicate the key from with the value should be drawn.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The value of the variable, or the property/key from which the value will be pulled (in case of secret, configmap or field).",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "secret()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.env-vars[*].secret",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "configmap()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.env-vars[*].configmap",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "field()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.env-vars[*].field",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "workingDir()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.working-dir",
      "description": "Working directory.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The working directory if specified, else empty string.",
      "sourceType": "io.dekorate.openshift.annotation.OpenshiftApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "command()[Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.command[*]",
      "description": "The commands\r\n\r\n *  **Returns:**\r\n    \r\n     *  The commands.",
      "sourceType": "io.dekorate.openshift.annotation.OpenshiftApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "arguments()[Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.arguments[*]",
      "description": "The arguments\r\n\r\n *  **Returns:**\r\n    \r\n     *  The arguments.",
      "sourceType": "io.dekorate.openshift.annotation.OpenshiftApplication"
    },
    {
      "type": "int",
      "sourceMethod": "replicas()I",
      "defaultValue": "1",
      "required": false,
      "phase": 0,
      "name": "openshift.replicas",
      "description": "The number of replicas to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The number of replicas.",
      "sourceType": "io.dekorate.openshift.annotation.OpenshiftApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "serviceAccount()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.service-account",
      "description": "The service account.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The service account or empty string if not specified.",
      "sourceType": "io.dekorate.openshift.annotation.OpenshiftApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "host()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.host",
      "description": "The host under which the application is going to be exposed.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The hostname.",
      "sourceType": "io.dekorate.openshift.annotation.OpenshiftApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.ports[*].name",
      "description": "The container port name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "int",
      "sourceMethod": "containerPort()I",
      "required": true,
      "phase": 0,
      "name": "openshift.ports[*].container-port",
      "description": "The port number. Refers to the container port.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The port number.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "int",
      "sourceMethod": "hostPort()I",
      "defaultValue": "0",
      "required": false,
      "phase": 0,
      "name": "openshift.ports[*].host-port",
      "description": "The host port. When a host port is not specified (or is set to 0) then the container port will be used.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The host port, or 0 if none specified.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "path()Ljava/lang/String;",
      "defaultValue": "/",
      "required": false,
      "phase": 0,
      "name": "openshift.ports[*].path",
      "description": "The application path (refers to web application path).\r\n\r\n *  **Returns:**\r\n    \r\n     *  The path, defaults to /.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.Protocol",
      "sourceMethod": "protocol()Lio/dekorate/kubernetes/annotation/Protocol;",
      "defaultValue": "TCP",
      "required": false,
      "phase": 0,
      "name": "openshift.ports[*].protocol",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.ServiceType",
      "sourceMethod": "serviceType()Lio/dekorate/kubernetes/annotation/ServiceType;",
      "defaultValue": "ClusterIP",
      "required": false,
      "phase": 0,
      "name": "openshift.service-type",
      "description": "The type of service that will be generated for the application.",
      "sourceType": "io.dekorate.openshift.annotation.OpenshiftApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "volumeName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.pvc-volumes[*].volume-name",
      "description": "The volumeName name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The volumeName name.",
      "sourceType": "io.dekorate.kubernetes.annotation.PersistentVolumeClaimVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "claimName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.pvc-volumes[*].claim-name",
      "description": "The persistent volumeName claim name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name of the pvcVolume.",
      "sourceType": "io.dekorate.kubernetes.annotation.PersistentVolumeClaimVolume"
    },
    {
      "type": "boolean",
      "sourceMethod": "readOnly()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "openshift.pvc-volumes[*].read-only",
      "description": "Wether the volumeName is read only or not.\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if read only, False otherwise.",
      "sourceType": "io.dekorate.kubernetes.annotation.PersistentVolumeClaimVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "volumeName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.secret-volumes[*].volume-name",
      "description": "The volumeName name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The volumeName name.",
      "sourceType": "io.dekorate.kubernetes.annotation.SecretVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "secretName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.secret-volumes[*].secret-name",
      "description": "The name of the secret to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name.",
      "sourceType": "io.dekorate.kubernetes.annotation.SecretVolume"
    },
    {
      "type": "int",
      "sourceMethod": "defaultMode()I",
      "defaultValue": "384",
      "required": false,
      "phase": 0,
      "name": "openshift.secret-volumes[*].default-mode",
      "description": "Default mode.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The default mode.",
      "sourceType": "io.dekorate.kubernetes.annotation.SecretVolume"
    },
    {
      "type": "boolean",
      "sourceMethod": "optional()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "openshift.secret-volumes[*].optional",
      "description": "Optional\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if optional, False otherwise.",
      "sourceType": "io.dekorate.kubernetes.annotation.SecretVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "volumeName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.config-map-volumes[*].volume-name",
      "description": "The volumeName name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The volumeName name.",
      "sourceType": "io.dekorate.kubernetes.annotation.ConfigMapVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "configMapName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.config-map-volumes[*].config-map-name",
      "description": "The name of the config map to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name.",
      "sourceType": "io.dekorate.kubernetes.annotation.ConfigMapVolume"
    },
    {
      "type": "int",
      "sourceMethod": "defaultMode()I",
      "defaultValue": "384",
      "required": false,
      "phase": 0,
      "name": "openshift.config-map-volumes[*].default-mode",
      "description": "Default mode.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The default mode.",
      "sourceType": "io.dekorate.kubernetes.annotation.ConfigMapVolume"
    },
    {
      "type": "boolean",
      "sourceMethod": "optional()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "openshift.config-map-volumes[*].optional",
      "description": "Optional\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if optional, False otherwise.",
      "sourceType": "io.dekorate.kubernetes.annotation.ConfigMapVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "volumeName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.git-repo-volumes[*].volume-name",
      "description": "The volumeName name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The volumeName name.",
      "sourceType": "io.dekorate.kubernetes.annotation.GitRepoVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "repository()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.git-repo-volumes[*].repository",
      "description": "Git repoistory URL.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The url of the repository.",
      "sourceType": "io.dekorate.kubernetes.annotation.GitRepoVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "directory()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.git-repo-volumes[*].directory",
      "description": "The directory of the repository to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The relative path to the directory.",
      "sourceType": "io.dekorate.kubernetes.annotation.GitRepoVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "revision()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.git-repo-volumes[*].revision",
      "description": "The commit hash to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The hash, or empty if the head of the repo (default).",
      "sourceType": "io.dekorate.kubernetes.annotation.GitRepoVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "volumeName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.aws-elastic-block-store-volumes[*].volume-name",
      "description": "The volumeName name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The volumeName name.",
      "sourceType": "io.dekorate.kubernetes.annotation.AwsElasticBlockStoreVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "volumeId()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.aws-elastic-block-store-volumes[*].volume-id",
      "description": "The name of the disk to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name.",
      "sourceType": "io.dekorate.kubernetes.annotation.AwsElasticBlockStoreVolume"
    },
    {
      "type": "int",
      "sourceMethod": "partition()I",
      "required": true,
      "phase": 0,
      "name": "openshift.aws-elastic-block-store-volumes[*].partition",
      "sourceType": "io.dekorate.kubernetes.annotation.AwsElasticBlockStoreVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "fsType()Ljava/lang/String;",
      "defaultValue": "ext4",
      "required": false,
      "phase": 0,
      "name": "openshift.aws-elastic-block-store-volumes[*].fs-type",
      "sourceType": "io.dekorate.kubernetes.annotation.AwsElasticBlockStoreVolume"
    },
    {
      "type": "boolean",
      "sourceMethod": "readOnly()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "openshift.aws-elastic-block-store-volumes[*].read-only",
      "description": "Wether the volumeName is read only or not.\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if read only, False otherwise.",
      "sourceType": "io.dekorate.kubernetes.annotation.AwsElasticBlockStoreVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "volumeName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.azure-disk-volumes[*].volume-name",
      "description": "The volumeName name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The volumeName name.",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureDiskVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "diskName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.azure-disk-volumes[*].disk-name",
      "description": "The name of the disk to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name.",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureDiskVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "diskURI()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.azure-disk-volumes[*].disk-uri",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureDiskVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "kind()Ljava/lang/String;",
      "defaultValue": "Managed",
      "required": false,
      "phase": 0,
      "name": "openshift.azure-disk-volumes[*].kind",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureDiskVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "cachingMode()Ljava/lang/String;",
      "defaultValue": "ReadWrite",
      "required": false,
      "phase": 0,
      "name": "openshift.azure-disk-volumes[*].caching-mode",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureDiskVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "fsType()Ljava/lang/String;",
      "defaultValue": "ext4",
      "required": false,
      "phase": 0,
      "name": "openshift.azure-disk-volumes[*].fs-type",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureDiskVolume"
    },
    {
      "type": "boolean",
      "sourceMethod": "readOnly()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "openshift.azure-disk-volumes[*].read-only",
      "description": "Wether the volumeName is read only or not.\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if read only, False otherwise.",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureDiskVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "volumeName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.azure-file-volumes[*].volume-name",
      "description": "The volumeName name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The volumeName name.",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureFileVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "shareName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.azure-file-volumes[*].share-name",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureFileVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "secretName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.azure-file-volumes[*].secret-name",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureFileVolume"
    },
    {
      "type": "boolean",
      "sourceMethod": "readOnly()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "openshift.azure-file-volumes[*].read-only",
      "description": "Wether the volumeName is read only or not.\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if read only, False otherwise.",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureFileVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.mounts[*].name",
      "description": "The name of the volumeName to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "path()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.mounts[*].path",
      "description": "The path to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The path.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "subPath()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.mounts[*].sub-path",
      "description": "Path within the volumeName from which the container\u0027s volumeName should be mounted.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The subPath.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "boolean",
      "sourceMethod": "readOnly()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "openshift.mounts[*].read-only",
      "description": "ReadOnly\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if mount is readonly, False otherwise.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.ImagePullPolicy",
      "sourceMethod": "imagePullPolicy()Lio/dekorate/kubernetes/annotation/ImagePullPolicy;",
      "defaultValue": "IfNotPresent",
      "required": false,
      "phase": 0,
      "name": "openshift.image-pull-policy",
      "description": "Image pull policy.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The image pull policy.",
      "sourceType": "io.dekorate.openshift.annotation.OpenshiftApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "imagePullSecrets()[Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.image-pull-secrets[*]",
      "description": "The image pull secret",
      "sourceType": "io.dekorate.openshift.annotation.OpenshiftApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "httpActionPath()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.liveness-probe.http-action-path",
      "description": "The http path to use for the probe For this to work, the container port also needs to be set Assuming the container port has been set (as per above comment), if execAction or tcpSocketAction are not set, an http probe will be used automatically even if no path is set (which will result in the root path being used)",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "execAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.liveness-probe.exec-action",
      "description": "The command to use for the probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The command.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "tcpSocketAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.liveness-probe.tcp-socket-action",
      "description": "The tcp socket to use for the probe (the format is host:port).\r\n\r\n *  **Returns:**\r\n    \r\n     *  The string representation of the socket.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "initialDelaySeconds()I",
      "defaultValue": "0",
      "required": false,
      "phase": 0,
      "name": "openshift.liveness-probe.initial-delay-seconds",
      "description": "The amount of time to wait in seconds before starting to probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The initial delay.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "periodSeconds()I",
      "defaultValue": "30",
      "required": false,
      "phase": 0,
      "name": "openshift.liveness-probe.period-seconds",
      "description": "The period in which the action should be called.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The period.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "timeoutSeconds()I",
      "defaultValue": "10",
      "required": false,
      "phase": 0,
      "name": "openshift.liveness-probe.timeout-seconds",
      "description": "The amount of time to wait for each action.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The timeout.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "successThreshold()I",
      "defaultValue": "1",
      "required": false,
      "phase": 0,
      "name": "openshift.liveness-probe.success-threshold",
      "description": "The success threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "failureThreshold()I",
      "defaultValue": "3",
      "required": false,
      "phase": 0,
      "name": "openshift.liveness-probe.failure-threshold",
      "description": "The failure threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "httpActionPath()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.readiness-probe.http-action-path",
      "description": "The http path to use for the probe For this to work, the container port also needs to be set Assuming the container port has been set (as per above comment), if execAction or tcpSocketAction are not set, an http probe will be used automatically even if no path is set (which will result in the root path being used)",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "execAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.readiness-probe.exec-action",
      "description": "The command to use for the probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The command.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "tcpSocketAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.readiness-probe.tcp-socket-action",
      "description": "The tcp socket to use for the probe (the format is host:port).\r\n\r\n *  **Returns:**\r\n    \r\n     *  The string representation of the socket.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "initialDelaySeconds()I",
      "defaultValue": "0",
      "required": false,
      "phase": 0,
      "name": "openshift.readiness-probe.initial-delay-seconds",
      "description": "The amount of time to wait in seconds before starting to probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The initial delay.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "periodSeconds()I",
      "defaultValue": "30",
      "required": false,
      "phase": 0,
      "name": "openshift.readiness-probe.period-seconds",
      "description": "The period in which the action should be called.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The period.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "timeoutSeconds()I",
      "defaultValue": "10",
      "required": false,
      "phase": 0,
      "name": "openshift.readiness-probe.timeout-seconds",
      "description": "The amount of time to wait for each action.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The timeout.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "successThreshold()I",
      "defaultValue": "1",
      "required": false,
      "phase": 0,
      "name": "openshift.readiness-probe.success-threshold",
      "description": "The success threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "failureThreshold()I",
      "defaultValue": "3",
      "required": false,
      "phase": 0,
      "name": "openshift.readiness-probe.failure-threshold",
      "description": "The failure threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "image()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].image",
      "description": "The container image.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The container image.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].name",
      "description": "The container name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The container name, or the name part of the image, if no name has been specified.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].env-vars[*].name",
      "description": "The name of the environment variable.\r\n\r\n *  **Returns:**\r\n    \r\n     *  the name.",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "value()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].env-vars[*].value",
      "description": "The value of the environment variable. When no other fields are used (just name/value), this value will be assigned to the environment variable. If used with other fields, like secret, configmap, or field, it will indicate the key from with the value should be drawn.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The value of the variable, or the property/key from which the value will be pulled (in case of secret, configmap or field).",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "secret()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].env-vars[*].secret",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "configmap()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].env-vars[*].configmap",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "field()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].env-vars[*].field",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "workingDir()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].working-dir",
      "description": "Working directory.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The working directory if specified, else empty string.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "command()[Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].command[*]",
      "description": "The commands\r\n\r\n *  **Returns:**\r\n    \r\n     *  The commands.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "arguments()[Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].arguments[*]",
      "description": "The arguments\r\n\r\n *  **Returns:**\r\n    \r\n     *  The arguments.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].ports[*].name",
      "description": "The container port name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "int",
      "sourceMethod": "containerPort()I",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].ports[*].container-port",
      "description": "The port number. Refers to the container port.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The port number.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "int",
      "sourceMethod": "hostPort()I",
      "defaultValue": "0",
      "required": false,
      "phase": 0,
      "name": "openshift.sidecars[*].ports[*].host-port",
      "description": "The host port. When a host port is not specified (or is set to 0) then the container port will be used.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The host port, or 0 if none specified.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "path()Ljava/lang/String;",
      "defaultValue": "/",
      "required": false,
      "phase": 0,
      "name": "openshift.sidecars[*].ports[*].path",
      "description": "The application path (refers to web application path).\r\n\r\n *  **Returns:**\r\n    \r\n     *  The path, defaults to /.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.Protocol",
      "sourceMethod": "protocol()Lio/dekorate/kubernetes/annotation/Protocol;",
      "defaultValue": "TCP",
      "required": false,
      "phase": 0,
      "name": "openshift.sidecars[*].ports[*].protocol",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].mounts[*].name",
      "description": "The name of the volumeName to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "path()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].mounts[*].path",
      "description": "The path to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The path.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "subPath()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].mounts[*].sub-path",
      "description": "Path within the volumeName from which the container\u0027s volumeName should be mounted.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The subPath.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "boolean",
      "sourceMethod": "readOnly()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "openshift.sidecars[*].mounts[*].read-only",
      "description": "ReadOnly\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if mount is readonly, False otherwise.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.ImagePullPolicy",
      "sourceMethod": "imagePullPolicy()Lio/dekorate/kubernetes/annotation/ImagePullPolicy;",
      "defaultValue": "IfNotPresent",
      "required": false,
      "phase": 0,
      "name": "openshift.sidecars[*].image-pull-policy",
      "description": "Image pull policy.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The image pull policy.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "httpActionPath()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].liveness-probe.http-action-path",
      "description": "The http path to use for the probe For this to work, the container port also needs to be set Assuming the container port has been set (as per above comment), if execAction or tcpSocketAction are not set, an http probe will be used automatically even if no path is set (which will result in the root path being used)",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "execAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].liveness-probe.exec-action",
      "description": "The command to use for the probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The command.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "tcpSocketAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].liveness-probe.tcp-socket-action",
      "description": "The tcp socket to use for the probe (the format is host:port).\r\n\r\n *  **Returns:**\r\n    \r\n     *  The string representation of the socket.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "initialDelaySeconds()I",
      "defaultValue": "0",
      "required": false,
      "phase": 0,
      "name": "openshift.sidecars[*].liveness-probe.initial-delay-seconds",
      "description": "The amount of time to wait in seconds before starting to probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The initial delay.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "periodSeconds()I",
      "defaultValue": "30",
      "required": false,
      "phase": 0,
      "name": "openshift.sidecars[*].liveness-probe.period-seconds",
      "description": "The period in which the action should be called.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The period.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "timeoutSeconds()I",
      "defaultValue": "10",
      "required": false,
      "phase": 0,
      "name": "openshift.sidecars[*].liveness-probe.timeout-seconds",
      "description": "The amount of time to wait for each action.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The timeout.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "successThreshold()I",
      "defaultValue": "1",
      "required": false,
      "phase": 0,
      "name": "openshift.sidecars[*].liveness-probe.success-threshold",
      "description": "The success threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "failureThreshold()I",
      "defaultValue": "3",
      "required": false,
      "phase": 0,
      "name": "openshift.sidecars[*].liveness-probe.failure-threshold",
      "description": "The failure threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "httpActionPath()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].readiness-probe.http-action-path",
      "description": "The http path to use for the probe For this to work, the container port also needs to be set Assuming the container port has been set (as per above comment), if execAction or tcpSocketAction are not set, an http probe will be used automatically even if no path is set (which will result in the root path being used)",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "execAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].readiness-probe.exec-action",
      "description": "The command to use for the probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The command.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "tcpSocketAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "openshift.sidecars[*].readiness-probe.tcp-socket-action",
      "description": "The tcp socket to use for the probe (the format is host:port).\r\n\r\n *  **Returns:**\r\n    \r\n     *  The string representation of the socket.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "initialDelaySeconds()I",
      "defaultValue": "0",
      "required": false,
      "phase": 0,
      "name": "openshift.sidecars[*].readiness-probe.initial-delay-seconds",
      "description": "The amount of time to wait in seconds before starting to probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The initial delay.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "periodSeconds()I",
      "defaultValue": "30",
      "required": false,
      "phase": 0,
      "name": "openshift.sidecars[*].readiness-probe.period-seconds",
      "description": "The period in which the action should be called.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The period.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "timeoutSeconds()I",
      "defaultValue": "10",
      "required": false,
      "phase": 0,
      "name": "openshift.sidecars[*].readiness-probe.timeout-seconds",
      "description": "The amount of time to wait for each action.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The timeout.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "successThreshold()I",
      "defaultValue": "1",
      "required": false,
      "phase": 0,
      "name": "openshift.sidecars[*].readiness-probe.success-threshold",
      "description": "The success threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "failureThreshold()I",
      "defaultValue": "3",
      "required": false,
      "phase": 0,
      "name": "openshift.sidecars[*].readiness-probe.failure-threshold",
      "description": "The failure threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "boolean",
      "sourceMethod": "expose()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "openshift.expose",
      "description": "Controls whether the application should be exposed via Route",
      "sourceType": "io.dekorate.openshift.annotation.OpenshiftApplication"
    },
    {
      "type": "boolean",
      "sourceMethod": "headless()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "openshift.headless",
      "description": "Controls whether the generated `Service` will be headless.\r\n\r\n *  **Returns:**\r\n    \r\n     *  true if headless.",
      "sourceType": "io.dekorate.openshift.annotation.OpenshiftApplication"
    },
    {
      "type": "boolean",
      "sourceMethod": "autoDeployEnabled()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "openshift.auto-deploy-enabled",
      "description": "Flag to trigger the registration of the deploy hook. It\u0027s generally preferable to use \\`-Ddekorate.deploy\u003dtrue\\` instead of hardcoding this here.\r\n\r\n *  **Returns:**\r\n    \r\n     *  True for automatic registration of the build hook.",
      "sourceType": "io.dekorate.openshift.annotation.OpenshiftApplication"
    },
    {
      "type": "java.lang.String",
      "required": true,
      "phase": 0,
      "name": "openshift.registry",
      "description": "Specify the docker registry."
    },
    {
      "type": "boolean",
      "sourceMethod": "enabled()Z",
      "defaultValue": "true",
      "required": false,
      "phase": 0,
      "name": "s2i.enabled",
      "sourceType": "io.dekorate.s2i.annotation.S2iBuild"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "registry()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "s2i.registry",
      "description": "The registry that holds the image.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The registry or empty string if no registry has been specified.",
      "sourceType": "io.dekorate.s2i.annotation.S2iBuild"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "group()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "s2i.group",
      "description": "The group of the application. This value will be use as image user.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The specified group name.",
      "sourceType": "io.dekorate.s2i.annotation.S2iBuild"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "s2i.name",
      "description": "The name of the application. This value will be used as name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The specified application name.",
      "sourceType": "io.dekorate.s2i.annotation.S2iBuild"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "version()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "s2i.version",
      "description": "The version of the application. This value be used as image tag.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The version.",
      "sourceType": "io.dekorate.s2i.annotation.S2iBuild"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "image()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "s2i.image",
      "sourceType": "io.dekorate.s2i.annotation.S2iBuild"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "dockerFile()Ljava/lang/String;",
      "defaultValue": "Dockerfile",
      "required": false,
      "phase": 0,
      "name": "s2i.docker-file",
      "description": "The relative path of the Dockerfile, from the module root.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The relative path.",
      "sourceType": "io.dekorate.s2i.annotation.S2iBuild"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "builderImage()Ljava/lang/String;",
      "defaultValue": "fabric8/s2i-java:2.3",
      "required": false,
      "phase": 0,
      "name": "s2i.builder-image",
      "description": "The S2i builder image to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The builder image.",
      "sourceType": "io.dekorate.s2i.annotation.S2iBuild"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "s2i.build-env-vars[*].name",
      "description": "The name of the environment variable.\r\n\r\n *  **Returns:**\r\n    \r\n     *  the name.",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "value()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "s2i.build-env-vars[*].value",
      "description": "The value of the environment variable. When no other fields are used (just name/value), this value will be assigned to the environment variable. If used with other fields, like secret, configmap, or field, it will indicate the key from with the value should be drawn.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The value of the variable, or the property/key from which the value will be pulled (in case of secret, configmap or field).",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "secret()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "s2i.build-env-vars[*].secret",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "configmap()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "s2i.build-env-vars[*].configmap",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "field()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "s2i.build-env-vars[*].field",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "boolean",
      "sourceMethod": "autoPushEnabled()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "s2i.auto-push-enabled",
      "description": "Flag to automatically push the image, to the specified registry.\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if hook is to be registered, false otherwise.",
      "sourceType": "io.dekorate.s2i.annotation.S2iBuild"
    },
    {
      "type": "boolean",
      "sourceMethod": "autoBuildEnabled()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "s2i.auto-build-enabled",
      "description": "Flag to automatically register a build hook after compilation.\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if hook is to be registered, false otherwise.",
      "sourceType": "io.dekorate.s2i.annotation.S2iBuild"
    },
    {
      "type": "boolean",
      "sourceMethod": "autoDeployEnabled()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "s2i.auto-deploy-enabled",
      "description": "Flag to trigger the registration of the deploy hook. It\u0027s generally preferable to use \\`-Ddekorate.deploy\u003dtrue\\` instead of hardcoding this here.\r\n\r\n *  **Returns:**\r\n    \r\n     *  True for automatic registration of the build hook.",
      "sourceType": "io.dekorate.s2i.annotation.S2iBuild"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "partOf()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.part-of",
      "description": "The name of the collection of componnet this component belongs to. This value will be use as: - docker image repo - labeling resources\r\n\r\n *  **Returns:**\r\n    \r\n     *  The specified group name.",
      "sourceType": "io.dekorate.kubernetes.annotation.KubernetesApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.name",
      "description": "The name of the application. This value will be used for naming Kubernetes resources like: - Deployment - Service and so on ... If no value is specified it will attempt to determine the name using the following rules: If its a maven/gradle project use the artifact id. Else if its a bazel project use the name. Else if the system property app.name is present it will be used. Else find the project root folder and use its name (root folder detection is done by moving to the parent folder until .git is found).\r\n\r\n *  **Returns:**\r\n    \r\n     *  The specified application name.",
      "sourceType": "io.dekorate.kubernetes.annotation.KubernetesApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "version()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.version",
      "description": "The version of the application. This value be used for things like: - The docker image tag. If no value specified it will attempt to determine the name using the following rules:\r\n\r\n *  **Returns:**\r\n    \r\n     *  The version.",
      "sourceType": "io.dekorate.kubernetes.annotation.KubernetesApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "image()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].image",
      "description": "The container image.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The container image.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].name",
      "description": "The container name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The container name, or the name part of the image, if no name has been specified.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].env-vars[*].name",
      "description": "The name of the environment variable.\r\n\r\n *  **Returns:**\r\n    \r\n     *  the name.",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "value()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].env-vars[*].value",
      "description": "The value of the environment variable. When no other fields are used (just name/value), this value will be assigned to the environment variable. If used with other fields, like secret, configmap, or field, it will indicate the key from with the value should be drawn.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The value of the variable, or the property/key from which the value will be pulled (in case of secret, configmap or field).",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "secret()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].env-vars[*].secret",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "configmap()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].env-vars[*].configmap",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "field()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].env-vars[*].field",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "workingDir()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].working-dir",
      "description": "Working directory.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The working directory if specified, else empty string.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "command()[Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].command[*]",
      "description": "The commands\r\n\r\n *  **Returns:**\r\n    \r\n     *  The commands.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "arguments()[Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].arguments[*]",
      "description": "The arguments\r\n\r\n *  **Returns:**\r\n    \r\n     *  The arguments.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].ports[*].name",
      "description": "The container port name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "int",
      "sourceMethod": "containerPort()I",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].ports[*].container-port",
      "description": "The port number. Refers to the container port.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The port number.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "int",
      "sourceMethod": "hostPort()I",
      "defaultValue": "0",
      "required": false,
      "phase": 0,
      "name": "kubernetes.init-containers[*].ports[*].host-port",
      "description": "The host port. When a host port is not specified (or is set to 0) then the container port will be used.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The host port, or 0 if none specified.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "path()Ljava/lang/String;",
      "defaultValue": "/",
      "required": false,
      "phase": 0,
      "name": "kubernetes.init-containers[*].ports[*].path",
      "description": "The application path (refers to web application path).\r\n\r\n *  **Returns:**\r\n    \r\n     *  The path, defaults to /.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.Protocol",
      "sourceMethod": "protocol()Lio/dekorate/kubernetes/annotation/Protocol;",
      "defaultValue": "TCP",
      "required": false,
      "phase": 0,
      "name": "kubernetes.init-containers[*].ports[*].protocol",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].mounts[*].name",
      "description": "The name of the volumeName to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "path()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].mounts[*].path",
      "description": "The path to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The path.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "subPath()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].mounts[*].sub-path",
      "description": "Path within the volumeName from which the container\u0027s volumeName should be mounted.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The subPath.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "boolean",
      "sourceMethod": "readOnly()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "kubernetes.init-containers[*].mounts[*].read-only",
      "description": "ReadOnly\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if mount is readonly, False otherwise.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.ImagePullPolicy",
      "sourceMethod": "imagePullPolicy()Lio/dekorate/kubernetes/annotation/ImagePullPolicy;",
      "defaultValue": "IfNotPresent",
      "required": false,
      "phase": 0,
      "name": "kubernetes.init-containers[*].image-pull-policy",
      "description": "Image pull policy.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The image pull policy.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "httpActionPath()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].liveness-probe.http-action-path",
      "description": "The http path to use for the probe For this to work, the container port also needs to be set Assuming the container port has been set (as per above comment), if execAction or tcpSocketAction are not set, an http probe will be used automatically even if no path is set (which will result in the root path being used)",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "execAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].liveness-probe.exec-action",
      "description": "The command to use for the probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The command.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "tcpSocketAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].liveness-probe.tcp-socket-action",
      "description": "The tcp socket to use for the probe (the format is host:port).\r\n\r\n *  **Returns:**\r\n    \r\n     *  The string representation of the socket.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "initialDelaySeconds()I",
      "defaultValue": "0",
      "required": false,
      "phase": 0,
      "name": "kubernetes.init-containers[*].liveness-probe.initial-delay-seconds",
      "description": "The amount of time to wait in seconds before starting to probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The initial delay.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "periodSeconds()I",
      "defaultValue": "30",
      "required": false,
      "phase": 0,
      "name": "kubernetes.init-containers[*].liveness-probe.period-seconds",
      "description": "The period in which the action should be called.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The period.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "timeoutSeconds()I",
      "defaultValue": "10",
      "required": false,
      "phase": 0,
      "name": "kubernetes.init-containers[*].liveness-probe.timeout-seconds",
      "description": "The amount of time to wait for each action.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The timeout.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "successThreshold()I",
      "defaultValue": "1",
      "required": false,
      "phase": 0,
      "name": "kubernetes.init-containers[*].liveness-probe.success-threshold",
      "description": "The success threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "failureThreshold()I",
      "defaultValue": "3",
      "required": false,
      "phase": 0,
      "name": "kubernetes.init-containers[*].liveness-probe.failure-threshold",
      "description": "The failure threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "httpActionPath()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].readiness-probe.http-action-path",
      "description": "The http path to use for the probe For this to work, the container port also needs to be set Assuming the container port has been set (as per above comment), if execAction or tcpSocketAction are not set, an http probe will be used automatically even if no path is set (which will result in the root path being used)",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "execAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].readiness-probe.exec-action",
      "description": "The command to use for the probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The command.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "tcpSocketAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.init-containers[*].readiness-probe.tcp-socket-action",
      "description": "The tcp socket to use for the probe (the format is host:port).\r\n\r\n *  **Returns:**\r\n    \r\n     *  The string representation of the socket.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "initialDelaySeconds()I",
      "defaultValue": "0",
      "required": false,
      "phase": 0,
      "name": "kubernetes.init-containers[*].readiness-probe.initial-delay-seconds",
      "description": "The amount of time to wait in seconds before starting to probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The initial delay.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "periodSeconds()I",
      "defaultValue": "30",
      "required": false,
      "phase": 0,
      "name": "kubernetes.init-containers[*].readiness-probe.period-seconds",
      "description": "The period in which the action should be called.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The period.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "timeoutSeconds()I",
      "defaultValue": "10",
      "required": false,
      "phase": 0,
      "name": "kubernetes.init-containers[*].readiness-probe.timeout-seconds",
      "description": "The amount of time to wait for each action.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The timeout.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "successThreshold()I",
      "defaultValue": "1",
      "required": false,
      "phase": 0,
      "name": "kubernetes.init-containers[*].readiness-probe.success-threshold",
      "description": "The success threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "failureThreshold()I",
      "defaultValue": "3",
      "required": false,
      "phase": 0,
      "name": "kubernetes.init-containers[*].readiness-probe.failure-threshold",
      "description": "The failure threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "key()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.labels[*].key",
      "sourceType": "io.dekorate.kubernetes.annotation.Label"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "value()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.labels[*].value",
      "sourceType": "io.dekorate.kubernetes.annotation.Label"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "key()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.annotations[*].key",
      "sourceType": "io.dekorate.kubernetes.annotation.Annotation"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "value()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.annotations[*].value",
      "sourceType": "io.dekorate.kubernetes.annotation.Annotation"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.env-vars[*].name",
      "description": "The name of the environment variable.\r\n\r\n *  **Returns:**\r\n    \r\n     *  the name.",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "value()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.env-vars[*].value",
      "description": "The value of the environment variable. When no other fields are used (just name/value), this value will be assigned to the environment variable. If used with other fields, like secret, configmap, or field, it will indicate the key from with the value should be drawn.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The value of the variable, or the property/key from which the value will be pulled (in case of secret, configmap or field).",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "secret()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.env-vars[*].secret",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "configmap()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.env-vars[*].configmap",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "field()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.env-vars[*].field",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "workingDir()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.working-dir",
      "description": "Working directory.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The working directory if specified, else empty string.",
      "sourceType": "io.dekorate.kubernetes.annotation.KubernetesApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "command()[Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.command[*]",
      "description": "The commands\r\n\r\n *  **Returns:**\r\n    \r\n     *  The commands.",
      "sourceType": "io.dekorate.kubernetes.annotation.KubernetesApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "arguments()[Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.arguments[*]",
      "description": "The arguments\r\n\r\n *  **Returns:**\r\n    \r\n     *  The arguments.",
      "sourceType": "io.dekorate.kubernetes.annotation.KubernetesApplication"
    },
    {
      "type": "int",
      "sourceMethod": "replicas()I",
      "defaultValue": "1",
      "required": false,
      "phase": 0,
      "name": "kubernetes.replicas",
      "description": "The number of replicas to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The number of replicas.",
      "sourceType": "io.dekorate.kubernetes.annotation.KubernetesApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "serviceAccount()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.service-account",
      "description": "The service account.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The service account or empty string if not specified.",
      "sourceType": "io.dekorate.kubernetes.annotation.KubernetesApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "host()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.host",
      "description": "The host under which the application is going to be exposed.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The hostname.",
      "sourceType": "io.dekorate.kubernetes.annotation.KubernetesApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.ports[*].name",
      "description": "The container port name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "int",
      "sourceMethod": "containerPort()I",
      "required": true,
      "phase": 0,
      "name": "kubernetes.ports[*].container-port",
      "description": "The port number. Refers to the container port.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The port number.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "int",
      "sourceMethod": "hostPort()I",
      "defaultValue": "0",
      "required": false,
      "phase": 0,
      "name": "kubernetes.ports[*].host-port",
      "description": "The host port. When a host port is not specified (or is set to 0) then the container port will be used.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The host port, or 0 if none specified.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "path()Ljava/lang/String;",
      "defaultValue": "/",
      "required": false,
      "phase": 0,
      "name": "kubernetes.ports[*].path",
      "description": "The application path (refers to web application path).\r\n\r\n *  **Returns:**\r\n    \r\n     *  The path, defaults to /.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.Protocol",
      "sourceMethod": "protocol()Lio/dekorate/kubernetes/annotation/Protocol;",
      "defaultValue": "TCP",
      "required": false,
      "phase": 0,
      "name": "kubernetes.ports[*].protocol",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.ServiceType",
      "sourceMethod": "serviceType()Lio/dekorate/kubernetes/annotation/ServiceType;",
      "defaultValue": "ClusterIP",
      "required": false,
      "phase": 0,
      "name": "kubernetes.service-type",
      "description": "The type of service that will be generated for the application.",
      "sourceType": "io.dekorate.kubernetes.annotation.KubernetesApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "volumeName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.pvc-volumes[*].volume-name",
      "description": "The volumeName name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The volumeName name.",
      "sourceType": "io.dekorate.kubernetes.annotation.PersistentVolumeClaimVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "claimName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.pvc-volumes[*].claim-name",
      "description": "The persistent volumeName claim name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name of the pvcVolume.",
      "sourceType": "io.dekorate.kubernetes.annotation.PersistentVolumeClaimVolume"
    },
    {
      "type": "boolean",
      "sourceMethod": "readOnly()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "kubernetes.pvc-volumes[*].read-only",
      "description": "Wether the volumeName is read only or not.\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if read only, False otherwise.",
      "sourceType": "io.dekorate.kubernetes.annotation.PersistentVolumeClaimVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "volumeName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.secret-volumes[*].volume-name",
      "description": "The volumeName name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The volumeName name.",
      "sourceType": "io.dekorate.kubernetes.annotation.SecretVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "secretName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.secret-volumes[*].secret-name",
      "description": "The name of the secret to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name.",
      "sourceType": "io.dekorate.kubernetes.annotation.SecretVolume"
    },
    {
      "type": "int",
      "sourceMethod": "defaultMode()I",
      "defaultValue": "384",
      "required": false,
      "phase": 0,
      "name": "kubernetes.secret-volumes[*].default-mode",
      "description": "Default mode.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The default mode.",
      "sourceType": "io.dekorate.kubernetes.annotation.SecretVolume"
    },
    {
      "type": "boolean",
      "sourceMethod": "optional()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "kubernetes.secret-volumes[*].optional",
      "description": "Optional\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if optional, False otherwise.",
      "sourceType": "io.dekorate.kubernetes.annotation.SecretVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "volumeName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.config-map-volumes[*].volume-name",
      "description": "The volumeName name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The volumeName name.",
      "sourceType": "io.dekorate.kubernetes.annotation.ConfigMapVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "configMapName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.config-map-volumes[*].config-map-name",
      "description": "The name of the config map to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name.",
      "sourceType": "io.dekorate.kubernetes.annotation.ConfigMapVolume"
    },
    {
      "type": "int",
      "sourceMethod": "defaultMode()I",
      "defaultValue": "384",
      "required": false,
      "phase": 0,
      "name": "kubernetes.config-map-volumes[*].default-mode",
      "description": "Default mode.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The default mode.",
      "sourceType": "io.dekorate.kubernetes.annotation.ConfigMapVolume"
    },
    {
      "type": "boolean",
      "sourceMethod": "optional()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "kubernetes.config-map-volumes[*].optional",
      "description": "Optional\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if optional, False otherwise.",
      "sourceType": "io.dekorate.kubernetes.annotation.ConfigMapVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "volumeName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.git-repo-volumes[*].volume-name",
      "description": "The volumeName name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The volumeName name.",
      "sourceType": "io.dekorate.kubernetes.annotation.GitRepoVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "repository()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.git-repo-volumes[*].repository",
      "description": "Git repoistory URL.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The url of the repository.",
      "sourceType": "io.dekorate.kubernetes.annotation.GitRepoVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "directory()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.git-repo-volumes[*].directory",
      "description": "The directory of the repository to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The relative path to the directory.",
      "sourceType": "io.dekorate.kubernetes.annotation.GitRepoVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "revision()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.git-repo-volumes[*].revision",
      "description": "The commit hash to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The hash, or empty if the head of the repo (default).",
      "sourceType": "io.dekorate.kubernetes.annotation.GitRepoVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "volumeName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.aws-elastic-block-store-volumes[*].volume-name",
      "description": "The volumeName name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The volumeName name.",
      "sourceType": "io.dekorate.kubernetes.annotation.AwsElasticBlockStoreVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "volumeId()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.aws-elastic-block-store-volumes[*].volume-id",
      "description": "The name of the disk to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name.",
      "sourceType": "io.dekorate.kubernetes.annotation.AwsElasticBlockStoreVolume"
    },
    {
      "type": "int",
      "sourceMethod": "partition()I",
      "required": true,
      "phase": 0,
      "name": "kubernetes.aws-elastic-block-store-volumes[*].partition",
      "sourceType": "io.dekorate.kubernetes.annotation.AwsElasticBlockStoreVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "fsType()Ljava/lang/String;",
      "defaultValue": "ext4",
      "required": false,
      "phase": 0,
      "name": "kubernetes.aws-elastic-block-store-volumes[*].fs-type",
      "sourceType": "io.dekorate.kubernetes.annotation.AwsElasticBlockStoreVolume"
    },
    {
      "type": "boolean",
      "sourceMethod": "readOnly()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "kubernetes.aws-elastic-block-store-volumes[*].read-only",
      "description": "Wether the volumeName is read only or not.\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if read only, False otherwise.",
      "sourceType": "io.dekorate.kubernetes.annotation.AwsElasticBlockStoreVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "volumeName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.azure-disk-volumes[*].volume-name",
      "description": "The volumeName name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The volumeName name.",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureDiskVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "diskName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.azure-disk-volumes[*].disk-name",
      "description": "The name of the disk to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name.",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureDiskVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "diskURI()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.azure-disk-volumes[*].disk-uri",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureDiskVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "kind()Ljava/lang/String;",
      "defaultValue": "Managed",
      "required": false,
      "phase": 0,
      "name": "kubernetes.azure-disk-volumes[*].kind",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureDiskVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "cachingMode()Ljava/lang/String;",
      "defaultValue": "ReadWrite",
      "required": false,
      "phase": 0,
      "name": "kubernetes.azure-disk-volumes[*].caching-mode",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureDiskVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "fsType()Ljava/lang/String;",
      "defaultValue": "ext4",
      "required": false,
      "phase": 0,
      "name": "kubernetes.azure-disk-volumes[*].fs-type",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureDiskVolume"
    },
    {
      "type": "boolean",
      "sourceMethod": "readOnly()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "kubernetes.azure-disk-volumes[*].read-only",
      "description": "Wether the volumeName is read only or not.\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if read only, False otherwise.",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureDiskVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "volumeName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.azure-file-volumes[*].volume-name",
      "description": "The volumeName name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The volumeName name.",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureFileVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "shareName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.azure-file-volumes[*].share-name",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureFileVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "secretName()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.azure-file-volumes[*].secret-name",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureFileVolume"
    },
    {
      "type": "boolean",
      "sourceMethod": "readOnly()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "kubernetes.azure-file-volumes[*].read-only",
      "description": "Wether the volumeName is read only or not.\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if read only, False otherwise.",
      "sourceType": "io.dekorate.kubernetes.annotation.AzureFileVolume"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.mounts[*].name",
      "description": "The name of the volumeName to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "path()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.mounts[*].path",
      "description": "The path to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The path.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "subPath()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.mounts[*].sub-path",
      "description": "Path within the volumeName from which the container\u0027s volumeName should be mounted.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The subPath.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "boolean",
      "sourceMethod": "readOnly()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "kubernetes.mounts[*].read-only",
      "description": "ReadOnly\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if mount is readonly, False otherwise.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.ImagePullPolicy",
      "sourceMethod": "imagePullPolicy()Lio/dekorate/kubernetes/annotation/ImagePullPolicy;",
      "defaultValue": "IfNotPresent",
      "required": false,
      "phase": 0,
      "name": "kubernetes.image-pull-policy",
      "description": "Image pull policy.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The image pull policy.",
      "sourceType": "io.dekorate.kubernetes.annotation.KubernetesApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "imagePullSecrets()[Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.image-pull-secrets[*]",
      "description": "The image pull secret",
      "sourceType": "io.dekorate.kubernetes.annotation.KubernetesApplication"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "httpActionPath()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.liveness-probe.http-action-path",
      "description": "The http path to use for the probe For this to work, the container port also needs to be set Assuming the container port has been set (as per above comment), if execAction or tcpSocketAction are not set, an http probe will be used automatically even if no path is set (which will result in the root path being used)",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "execAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.liveness-probe.exec-action",
      "description": "The command to use for the probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The command.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "tcpSocketAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.liveness-probe.tcp-socket-action",
      "description": "The tcp socket to use for the probe (the format is host:port).\r\n\r\n *  **Returns:**\r\n    \r\n     *  The string representation of the socket.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "initialDelaySeconds()I",
      "defaultValue": "0",
      "required": false,
      "phase": 0,
      "name": "kubernetes.liveness-probe.initial-delay-seconds",
      "description": "The amount of time to wait in seconds before starting to probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The initial delay.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "periodSeconds()I",
      "defaultValue": "30",
      "required": false,
      "phase": 0,
      "name": "kubernetes.liveness-probe.period-seconds",
      "description": "The period in which the action should be called.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The period.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "timeoutSeconds()I",
      "defaultValue": "10",
      "required": false,
      "phase": 0,
      "name": "kubernetes.liveness-probe.timeout-seconds",
      "description": "The amount of time to wait for each action.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The timeout.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "successThreshold()I",
      "defaultValue": "1",
      "required": false,
      "phase": 0,
      "name": "kubernetes.liveness-probe.success-threshold",
      "description": "The success threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "failureThreshold()I",
      "defaultValue": "3",
      "required": false,
      "phase": 0,
      "name": "kubernetes.liveness-probe.failure-threshold",
      "description": "The failure threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "httpActionPath()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.readiness-probe.http-action-path",
      "description": "The http path to use for the probe For this to work, the container port also needs to be set Assuming the container port has been set (as per above comment), if execAction or tcpSocketAction are not set, an http probe will be used automatically even if no path is set (which will result in the root path being used)",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "execAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.readiness-probe.exec-action",
      "description": "The command to use for the probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The command.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "tcpSocketAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.readiness-probe.tcp-socket-action",
      "description": "The tcp socket to use for the probe (the format is host:port).\r\n\r\n *  **Returns:**\r\n    \r\n     *  The string representation of the socket.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "initialDelaySeconds()I",
      "defaultValue": "0",
      "required": false,
      "phase": 0,
      "name": "kubernetes.readiness-probe.initial-delay-seconds",
      "description": "The amount of time to wait in seconds before starting to probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The initial delay.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "periodSeconds()I",
      "defaultValue": "30",
      "required": false,
      "phase": 0,
      "name": "kubernetes.readiness-probe.period-seconds",
      "description": "The period in which the action should be called.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The period.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "timeoutSeconds()I",
      "defaultValue": "10",
      "required": false,
      "phase": 0,
      "name": "kubernetes.readiness-probe.timeout-seconds",
      "description": "The amount of time to wait for each action.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The timeout.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "successThreshold()I",
      "defaultValue": "1",
      "required": false,
      "phase": 0,
      "name": "kubernetes.readiness-probe.success-threshold",
      "description": "The success threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "failureThreshold()I",
      "defaultValue": "3",
      "required": false,
      "phase": 0,
      "name": "kubernetes.readiness-probe.failure-threshold",
      "description": "The failure threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "image()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].image",
      "description": "The container image.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The container image.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].name",
      "description": "The container name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The container name, or the name part of the image, if no name has been specified.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].env-vars[*].name",
      "description": "The name of the environment variable.\r\n\r\n *  **Returns:**\r\n    \r\n     *  the name.",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "value()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].env-vars[*].value",
      "description": "The value of the environment variable. When no other fields are used (just name/value), this value will be assigned to the environment variable. If used with other fields, like secret, configmap, or field, it will indicate the key from with the value should be drawn.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The value of the variable, or the property/key from which the value will be pulled (in case of secret, configmap or field).",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "secret()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].env-vars[*].secret",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "configmap()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].env-vars[*].configmap",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "field()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].env-vars[*].field",
      "sourceType": "io.dekorate.kubernetes.annotation.Env"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "workingDir()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].working-dir",
      "description": "Working directory.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The working directory if specified, else empty string.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "command()[Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].command[*]",
      "description": "The commands\r\n\r\n *  **Returns:**\r\n    \r\n     *  The commands.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "arguments()[Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].arguments[*]",
      "description": "The arguments\r\n\r\n *  **Returns:**\r\n    \r\n     *  The arguments.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].ports[*].name",
      "description": "The container port name.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "int",
      "sourceMethod": "containerPort()I",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].ports[*].container-port",
      "description": "The port number. Refers to the container port.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The port number.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "int",
      "sourceMethod": "hostPort()I",
      "defaultValue": "0",
      "required": false,
      "phase": 0,
      "name": "kubernetes.sidecars[*].ports[*].host-port",
      "description": "The host port. When a host port is not specified (or is set to 0) then the container port will be used.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The host port, or 0 if none specified.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "path()Ljava/lang/String;",
      "defaultValue": "/",
      "required": false,
      "phase": 0,
      "name": "kubernetes.sidecars[*].ports[*].path",
      "description": "The application path (refers to web application path).\r\n\r\n *  **Returns:**\r\n    \r\n     *  The path, defaults to /.",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.Protocol",
      "sourceMethod": "protocol()Lio/dekorate/kubernetes/annotation/Protocol;",
      "defaultValue": "TCP",
      "required": false,
      "phase": 0,
      "name": "kubernetes.sidecars[*].ports[*].protocol",
      "sourceType": "io.dekorate.kubernetes.annotation.Port"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "name()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].mounts[*].name",
      "description": "The name of the volumeName to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The name.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "path()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].mounts[*].path",
      "description": "The path to mount.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The path.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "subPath()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].mounts[*].sub-path",
      "description": "Path within the volumeName from which the container\u0027s volumeName should be mounted.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The subPath.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "boolean",
      "sourceMethod": "readOnly()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "kubernetes.sidecars[*].mounts[*].read-only",
      "description": "ReadOnly\r\n\r\n *  **Returns:**\r\n    \r\n     *  True if mount is readonly, False otherwise.",
      "sourceType": "io.dekorate.kubernetes.annotation.Mount"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.ImagePullPolicy",
      "sourceMethod": "imagePullPolicy()Lio/dekorate/kubernetes/annotation/ImagePullPolicy;",
      "defaultValue": "IfNotPresent",
      "required": false,
      "phase": 0,
      "name": "kubernetes.sidecars[*].image-pull-policy",
      "description": "Image pull policy.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The image pull policy.",
      "sourceType": "io.dekorate.kubernetes.annotation.Container"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "httpActionPath()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].liveness-probe.http-action-path",
      "description": "The http path to use for the probe For this to work, the container port also needs to be set Assuming the container port has been set (as per above comment), if execAction or tcpSocketAction are not set, an http probe will be used automatically even if no path is set (which will result in the root path being used)",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "execAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].liveness-probe.exec-action",
      "description": "The command to use for the probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The command.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "tcpSocketAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].liveness-probe.tcp-socket-action",
      "description": "The tcp socket to use for the probe (the format is host:port).\r\n\r\n *  **Returns:**\r\n    \r\n     *  The string representation of the socket.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "initialDelaySeconds()I",
      "defaultValue": "0",
      "required": false,
      "phase": 0,
      "name": "kubernetes.sidecars[*].liveness-probe.initial-delay-seconds",
      "description": "The amount of time to wait in seconds before starting to probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The initial delay.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "periodSeconds()I",
      "defaultValue": "30",
      "required": false,
      "phase": 0,
      "name": "kubernetes.sidecars[*].liveness-probe.period-seconds",
      "description": "The period in which the action should be called.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The period.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "timeoutSeconds()I",
      "defaultValue": "10",
      "required": false,
      "phase": 0,
      "name": "kubernetes.sidecars[*].liveness-probe.timeout-seconds",
      "description": "The amount of time to wait for each action.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The timeout.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "successThreshold()I",
      "defaultValue": "1",
      "required": false,
      "phase": 0,
      "name": "kubernetes.sidecars[*].liveness-probe.success-threshold",
      "description": "The success threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "failureThreshold()I",
      "defaultValue": "3",
      "required": false,
      "phase": 0,
      "name": "kubernetes.sidecars[*].liveness-probe.failure-threshold",
      "description": "The failure threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "httpActionPath()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].readiness-probe.http-action-path",
      "description": "The http path to use for the probe For this to work, the container port also needs to be set Assuming the container port has been set (as per above comment), if execAction or tcpSocketAction are not set, an http probe will be used automatically even if no path is set (which will result in the root path being used)",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "execAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].readiness-probe.exec-action",
      "description": "The command to use for the probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The command.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "java.lang.String",
      "sourceMethod": "tcpSocketAction()Ljava/lang/String;",
      "required": true,
      "phase": 0,
      "name": "kubernetes.sidecars[*].readiness-probe.tcp-socket-action",
      "description": "The tcp socket to use for the probe (the format is host:port).\r\n\r\n *  **Returns:**\r\n    \r\n     *  The string representation of the socket.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "initialDelaySeconds()I",
      "defaultValue": "0",
      "required": false,
      "phase": 0,
      "name": "kubernetes.sidecars[*].readiness-probe.initial-delay-seconds",
      "description": "The amount of time to wait in seconds before starting to probe.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The initial delay.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "periodSeconds()I",
      "defaultValue": "30",
      "required": false,
      "phase": 0,
      "name": "kubernetes.sidecars[*].readiness-probe.period-seconds",
      "description": "The period in which the action should be called.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The period.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "timeoutSeconds()I",
      "defaultValue": "10",
      "required": false,
      "phase": 0,
      "name": "kubernetes.sidecars[*].readiness-probe.timeout-seconds",
      "description": "The amount of time to wait for each action.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The timeout.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "successThreshold()I",
      "defaultValue": "1",
      "required": false,
      "phase": 0,
      "name": "kubernetes.sidecars[*].readiness-probe.success-threshold",
      "description": "The success threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "int",
      "sourceMethod": "failureThreshold()I",
      "defaultValue": "3",
      "required": false,
      "phase": 0,
      "name": "kubernetes.sidecars[*].readiness-probe.failure-threshold",
      "description": "The failure threshold to use.\r\n\r\n *  **Returns:**\r\n    \r\n     *  The threshold.",
      "sourceType": "io.dekorate.kubernetes.annotation.Probe"
    },
    {
      "type": "boolean",
      "sourceMethod": "expose()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "kubernetes.expose",
      "description": "Controls whether the application should be exposed via Ingress",
      "sourceType": "io.dekorate.kubernetes.annotation.KubernetesApplication"
    },
    {
      "type": "boolean",
      "sourceMethod": "headless()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "kubernetes.headless",
      "description": "Controls whether the generated `Service` will be headless.\r\n\r\n *  **Returns:**\r\n    \r\n     *  true if headless.",
      "sourceType": "io.dekorate.kubernetes.annotation.KubernetesApplication"
    },
    {
      "type": "boolean",
      "sourceMethod": "autoDeployEnabled()Z",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "kubernetes.auto-deploy-enabled",
      "description": "Flag to trigger the registration of the deploy hook. It\u0027s generally preferable to use \\`-Ddekorate.deploy\u003dtrue\\` instead of hardcoding this here.\r\n\r\n *  **Returns:**\r\n    \r\n     *  True for automatic registration of the build hook.",
      "sourceType": "io.dekorate.kubernetes.annotation.KubernetesApplication"
    },
    {
      "type": "java.lang.String",
      "defaultValue": "kubernetes",
      "required": false,
      "phase": 0,
      "name": "kubernetes.deployment.target",
      "description": "To enable the generation of OpenShift resources, you need to include OpenShift in the target platforms: `kubernetes.deployment.target\u003dopenshift`.\r\nIf you need to generate resources for both platforms (vanilla Kubernetes and OpenShift), then you need to include both (coma separated).\r\n`kubernetes.deployment.target\u003dkubernetes, openshift`."
    },
    {
      "type": "java.lang.String",
      "required": true,
      "phase": 0,
      "name": "kubernetes.registry",
      "description": "Specify the docker registry."
    },
    {
      "type": "boolean",
      "sourceField": "enabled",
      "defaultValue": "true",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 2,
      "name": "quarkus.datasource.jdbc",
      "description": "If we create a JDBC datasource for this datasource.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcBuildTimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "driver",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 2,
      "name": "quarkus.datasource.jdbc.driver",
      "description": "The datasource driver class name",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcBuildTimeConfig"
    },
    {
      "type": "io.quarkus.agroal.runtime.TransactionIntegration",
      "sourceField": "transactions",
      "defaultValue": "enabled",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 2,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.datasource.jdbc.transactions",
      "description": "Whether we want to use regular JDBC transactions, XA, or disable all transactional capabilities.\n\u003cp\u003e\nWhen enabling XA you will need a driver implementing {@link javax.sql.XADataSource}.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcBuildTimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Boolean\u003e",
      "sourceField": "enableMetrics",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 2,
      "name": "quarkus.datasource.jdbc.enable-metrics",
      "description": "Enable datasource metrics collection. If unspecified, collecting metrics will be enabled by default if the\nsmallrye-metrics extension is active.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcBuildTimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enabled",
      "defaultValue": "true",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 2,
      "name": "quarkus.datasource.{*}.jdbc",
      "description": "If we create a JDBC datasource for this datasource.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcBuildTimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "driver",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 2,
      "name": "quarkus.datasource.{*}.jdbc.driver",
      "description": "The datasource driver class name",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcBuildTimeConfig"
    },
    {
      "type": "io.quarkus.agroal.runtime.TransactionIntegration",
      "sourceField": "transactions",
      "defaultValue": "enabled",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 2,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.datasource.{*}.jdbc.transactions",
      "description": "Whether we want to use regular JDBC transactions, XA, or disable all transactional capabilities.\n\u003cp\u003e\nWhen enabling XA you will need a driver implementing {@link javax.sql.XADataSource}.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcBuildTimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Boolean\u003e",
      "sourceField": "enableMetrics",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 2,
      "name": "quarkus.datasource.{*}.jdbc.enable-metrics",
      "description": "Enable datasource metrics collection. If unspecified, collecting metrics will be enabled by default if the\nsmallrye-metrics extension is active.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcBuildTimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "url",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.jdbc.url",
      "description": "The datasource URL",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "initialSize",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.jdbc.initial-size",
      "description": "The initial size of the pool. Usually you will want to set the initial size to match at least the\nminimal size, but this is not enforced so to allow for architectures which prefer a lazy initialization\nof the connections on boot, while being able to sustain a minimal pool size after boot.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "int",
      "sourceField": "minSize",
      "defaultValue": "0",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.jdbc.min-size",
      "description": "The datasource pool minimum size",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "int",
      "sourceField": "maxSize",
      "defaultValue": "20",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.jdbc.max-size",
      "description": "The datasource pool maximum size",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "backgroundValidationInterval",
      "defaultValue": "2M",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.jdbc.background-validation-interval",
      "description": "The interval at which we validate idle connections in the background.\n\u003cp\u003e\nSet to {@code 0} to disable background validation.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "acquisitionTimeout",
      "defaultValue": "5",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.jdbc.acquisition-timeout",
      "description": "The timeout before cancelling the acquisition of a new connection",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "leakDetectionInterval",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.jdbc.leak-detection-interval",
      "description": "The interval at which we check for connection leaks.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "idleRemovalInterval",
      "defaultValue": "5M",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.jdbc.idle-removal-interval",
      "description": "The interval at which we try to remove idle connections.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "maxLifetime",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.jdbc.max-lifetime",
      "description": "The max lifetime of a connection.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cio.agroal.api.configuration.AgroalConnectionFactoryConfiguration.TransactionIsolation\u003e",
      "sourceField": "transactionIsolationLevel",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.datasource.jdbc.transaction-isolation-level",
      "description": "The transaction isolation level.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "detectStatementLeaks",
      "defaultValue": "true",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.jdbc.detect-statement-leaks",
      "description": "When enabled Agroal will be able to produce a warning when a connection is returned\nto the pool without the application having closed all open statements.\nThis is unrelated with tracking of open connections.\nDisable for peak performance, but only when there\u0027s high confidence that\nno leaks are happening.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "newConnectionSql",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.jdbc.new-connection-sql",
      "description": "Query executed when first using a connection.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "validationQuerySql",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.jdbc.validation-query-sql",
      "description": "Query executed to validate a connection.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "url",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.jdbc.url",
      "description": "The datasource URL",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "initialSize",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.jdbc.initial-size",
      "description": "The initial size of the pool. Usually you will want to set the initial size to match at least the\nminimal size, but this is not enforced so to allow for architectures which prefer a lazy initialization\nof the connections on boot, while being able to sustain a minimal pool size after boot.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "int",
      "sourceField": "minSize",
      "defaultValue": "0",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.jdbc.min-size",
      "description": "The datasource pool minimum size",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "int",
      "sourceField": "maxSize",
      "defaultValue": "20",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.jdbc.max-size",
      "description": "The datasource pool maximum size",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "backgroundValidationInterval",
      "defaultValue": "2M",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.jdbc.background-validation-interval",
      "description": "The interval at which we validate idle connections in the background.\n\u003cp\u003e\nSet to {@code 0} to disable background validation.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "acquisitionTimeout",
      "defaultValue": "5",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.jdbc.acquisition-timeout",
      "description": "The timeout before cancelling the acquisition of a new connection",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "leakDetectionInterval",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.jdbc.leak-detection-interval",
      "description": "The interval at which we check for connection leaks.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "idleRemovalInterval",
      "defaultValue": "5M",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.jdbc.idle-removal-interval",
      "description": "The interval at which we try to remove idle connections.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "maxLifetime",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.jdbc.max-lifetime",
      "description": "The max lifetime of a connection.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cio.agroal.api.configuration.AgroalConnectionFactoryConfiguration.TransactionIsolation\u003e",
      "sourceField": "transactionIsolationLevel",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.datasource.{*}.jdbc.transaction-isolation-level",
      "description": "The transaction isolation level.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "detectStatementLeaks",
      "defaultValue": "true",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.jdbc.detect-statement-leaks",
      "description": "When enabled Agroal will be able to produce a warning when a connection is returned\nto the pool without the application having closed all open statements.\nThis is unrelated with tracking of open connections.\nDisable for peak performance, but only when there\u0027s high confidence that\nno leaks are happening.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "newConnectionSql",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.jdbc.new-connection-sql",
      "description": "Query executed when first using a connection.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "validationQuerySql",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.jdbc.validation-query-sql",
      "description": "Query executed to validate a connection.",
      "sourceType": "io.quarkus.agroal.runtime.DataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "driver",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 2,
      "name": "quarkus.datasource.driver",
      "description": "@deprecated use quarkus.datasource.db-kind (and quarkus.datasource.jdbc.driver if you really need a specific JDBC\n            driver).",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcBuildTimeConfig"
    },
    {
      "type": "io.quarkus.agroal.runtime.TransactionIntegration",
      "sourceField": "transactions",
      "defaultValue": "enabled",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 2,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.datasource.transactions",
      "description": "@deprecated use quarkus.datasource.jdbc.transactions instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcBuildTimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Boolean\u003e",
      "sourceField": "enableMetrics",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 2,
      "name": "quarkus.datasource.enable-metrics",
      "description": "@deprecated use quarkus.datasource.jdbc.enable-metrics instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcBuildTimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "driver",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 2,
      "name": "quarkus.datasource.{*}.driver",
      "description": "@deprecated use quarkus.datasource.db-kind (and quarkus.datasource.jdbc.driver if you really need a specific JDBC\n            driver).",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcBuildTimeConfig"
    },
    {
      "type": "io.quarkus.agroal.runtime.TransactionIntegration",
      "sourceField": "transactions",
      "defaultValue": "enabled",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 2,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.datasource.{*}.transactions",
      "description": "@deprecated use quarkus.datasource.jdbc.transactions instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcBuildTimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Boolean\u003e",
      "sourceField": "enableMetrics",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 2,
      "name": "quarkus.datasource.{*}.enable-metrics",
      "description": "@deprecated use quarkus.datasource.jdbc.enable-metrics instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcBuildTimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "initialSize",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.initial-size",
      "description": "@deprecated use quarkus.datasource.jdbc.initial-size instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "int",
      "sourceField": "minSize",
      "defaultValue": "0",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.min-size",
      "description": "@deprecated use quarkus.datasource.jdbc.min-size instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "backgroundValidationInterval",
      "defaultValue": "2M",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.background-validation-interval",
      "description": "@deprecated use quarkus.datasource.jdbc.background-validation-interval instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "acquisitionTimeout",
      "defaultValue": "5",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.acquisition-timeout",
      "description": "@deprecated use quarkus.datasource.jdbc.acquisition-timeout instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "leakDetectionInterval",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.leak-detection-interval",
      "description": "@deprecated use quarkus.datasource.jdbc.leak-detection-interval instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "idleRemovalInterval",
      "defaultValue": "5M",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.idle-removal-interval",
      "description": "@deprecated use quarkus.datasource.jdbc.idle-removal-interval instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "maxLifetime",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.max-lifetime",
      "description": "@deprecated use quarkus.datasource.jdbc.max-lifetime instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cio.agroal.api.configuration.AgroalConnectionFactoryConfiguration.TransactionIsolation\u003e",
      "sourceField": "transactionIsolationLevel",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.datasource.transaction-isolation-level",
      "description": "@deprecated use quarkus.datasource.jdbc.transaction-isolation-level instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "detectStatementLeaks",
      "defaultValue": "true",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.detect-statement-leaks",
      "description": "@deprecated use quarkus.datasource.jdbc.detect-statement-leaks instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "newConnectionSql",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.new-connection-sql",
      "description": "@deprecated use quarkus.datasource.jdbc.new-connection-sql instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "validationQuerySql",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.validation-query-sql",
      "description": "@deprecated use quarkus.datasource.jdbc.validation-query-sql instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "initialSize",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.initial-size",
      "description": "@deprecated use quarkus.datasource.jdbc.initial-size instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "int",
      "sourceField": "minSize",
      "defaultValue": "0",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.min-size",
      "description": "@deprecated use quarkus.datasource.jdbc.min-size instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "backgroundValidationInterval",
      "defaultValue": "2M",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.background-validation-interval",
      "description": "@deprecated use quarkus.datasource.jdbc.background-validation-interval instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "acquisitionTimeout",
      "defaultValue": "5",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.acquisition-timeout",
      "description": "@deprecated use quarkus.datasource.jdbc.acquisition-timeout instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "leakDetectionInterval",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.leak-detection-interval",
      "description": "@deprecated use quarkus.datasource.jdbc.leak-detection-interval instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "idleRemovalInterval",
      "defaultValue": "5M",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.idle-removal-interval",
      "description": "@deprecated use quarkus.datasource.jdbc.idle-removal-interval instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "maxLifetime",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.max-lifetime",
      "description": "@deprecated use quarkus.datasource.jdbc.max-lifetime instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cio.agroal.api.configuration.AgroalConnectionFactoryConfiguration.TransactionIsolation\u003e",
      "sourceField": "transactionIsolationLevel",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.datasource.{*}.transaction-isolation-level",
      "description": "@deprecated use quarkus.datasource.jdbc.transaction-isolation-level instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "detectStatementLeaks",
      "defaultValue": "true",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.detect-statement-leaks",
      "description": "@deprecated use quarkus.datasource.jdbc.detect-statement-leaks instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "newConnectionSql",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.new-connection-sql",
      "description": "@deprecated use quarkus.datasource.jdbc.new-connection-sql instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "validationQuerySql",
      "extensionName": "quarkus-agroal",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.validation-query-sql",
      "description": "@deprecated use quarkus.datasource.jdbc.validation-query-sql instead.",
      "sourceType": "io.quarkus.agroal.runtime.LegacyDataSourceJdbcRuntimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enablePollingJvmMode",
      "defaultValue": "false",
      "extensionName": "quarkus-amazon-lambda",
      "required": false,
      "phase": 1,
      "name": "quarkus.lambda.enable-polling-jvm-mode",
      "description": "If true, this will enable the aws event poll loop within a Quarkus test run. This loop normally only runs in native\nimage. This option is strictly for testing purposes.",
      "sourceType": "io.quarkus.amazon.lambda.runtime.LambdaBuildTimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "handler",
      "extensionName": "quarkus-amazon-lambda",
      "required": false,
      "phase": 4,
      "name": "quarkus.lambda.handler",
      "description": "The handler name. Handler names are specified on handler classes using the {@link @javax.inject.Named} annotation.\n\nIf this name is unspecified and there is exactly one unnamed implementation of\n{@link com.amazonaws.services.lambda.runtime.RequestHandler}\nthen this unnamed handler will be used. If there is only a single named handler and the name is unspecified\nthen the named handler will be used.",
      "sourceType": "io.quarkus.amazon.lambda.runtime.LambdaConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.Class\u003c?\u003e\u003e\u003e",
      "sourceField": "interceptors",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 2,
      "name": "quarkus.dynamodb.interceptors",
      "description": "List of execution interceptors that will have access to read and modify the request and response objects as they are\nprocessed by the AWS SDK.\n\u003cp\u003e\nThe list should consists of class names which implements\n{@code software.amazon.awssdk.core.interceptor.ExecutionInterceptor} interface.\n\n@see software.amazon.awssdk.core.interceptor.ExecutionInterceptor",
      "sourceType": "io.quarkus.dynamodb.runtime.SdkBuildTimeConfig"
    },
    {
      "type": "io.quarkus.dynamodb.runtime.SyncHttpClientBuildTimeConfig.SyncClientType",
      "sourceField": "type",
      "defaultValue": "url",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 2,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.dynamodb.sync-client.type",
      "description": "Type of the sync HTTP client implementation",
      "sourceType": "io.quarkus.dynamodb.runtime.SyncHttpClientBuildTimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enableEndpointDiscovery",
      "defaultValue": "false",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.enable-endpoint-discovery",
      "description": "Enable DynamoDB service endpoint discovery.",
      "sourceType": "io.quarkus.dynamodb.runtime.DynamodbConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.net.URI\u003e",
      "sourceField": "endpointOverride",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.endpoint-override",
      "description": "The endpoint URI with which the SDK should communicate.\n\u003cp\u003e\nIf not specified, an appropriate endpoint to be used for DynamoDB service and region.",
      "sourceType": "io.quarkus.dynamodb.runtime.SdkConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "apiCallTimeout",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.api-call-timeout",
      "description": "The amount of time to allow the client to complete the execution of an API call.\n\u003cp\u003e\nThis timeout covers the entire client execution except for marshalling. This includes request handler execution, all HTTP\nrequests including retries, unmarshalling, etc.\n\u003cp\u003e\nThis value should always be positive, if present.\n\n@see software.amazon.awssdk.core.client.config.ClientOverrideConfiguration#apiCallTimeout()",
      "sourceType": "io.quarkus.dynamodb.runtime.SdkConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "apiCallAttemptTimeout",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.api-call-attempt-timeout",
      "description": "The amount of time to wait for the HTTP request to complete before giving up and timing out.\n\u003cp\u003e\nThis value should always be positive, if present.\n\n@see software.amazon.awssdk.core.client.config.ClientOverrideConfiguration#apiCallAttemptTimeout()",
      "sourceType": "io.quarkus.dynamodb.runtime.SdkConfig"
    },
    {
      "type": "java.util.Optional\u003csoftware.amazon.awssdk.regions.Region\u003e",
      "sourceField": "region",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.aws.region",
      "description": "An Amazon Web Services region that hosts DynamoDB.\n\nIt overrides region provider chain with static value of\nregion with which the DynamoDB client should communicate.\n\nIf not set, region is retrieved via the default providers chain in the following order:\n\n* `aws.region` system property\n* `region` property from the profile file\n* Instance profile file\n\nSee `software.amazon.awssdk.regions.Region` for available regions.\n\n@asciidoclet",
      "sourceType": "io.quarkus.dynamodb.runtime.AwsConfig"
    },
    {
      "type": "io.quarkus.dynamodb.runtime.AwsCredentialsProviderType",
      "sourceField": "type",
      "defaultValue": "default",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.dynamodb.aws.credentials.type",
      "description": "Configure the credentials provider that should be used to authenticate with AWS.\n\nAvailable values:\n\n* `default` - the provider will attempt to identify the credentials automatically using the following checks:\n** Java System Properties - `aws.accessKeyId` and `aws.secretKey`\n** Environment Variables - `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`\n** Credential profiles file at the default location (`~/.aws/credentials`) shared by all AWS SDKs and the AWS CLI\n** Credentials delivered through the Amazon EC2 container service if `AWS_CONTAINER_CREDENTIALS_RELATIVE_URI` environment variable is set and security manager has permission to access the variable.\n** Instance profile credentials delivered through the Amazon EC2 metadata service\n* `static` - the provider that uses the access key and secret access key specified in the `static-provider` section of the config.\n* `system-property` - it loads credentials from the `aws.accessKeyId`, `aws.secretAccessKey` and `aws.sessionToken` system properties.\n* `env-variable` - it loads credentials from the `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY` and `AWS_SESSION_TOKEN` environment variables.\n* `profile` - credentials are based on AWS configuration profiles. This loads credentials from\n              a http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html[profile file],\n              allowing you to share multiple sets of AWS security credentials between different tools like the AWS SDK for Java and the AWS CLI.\n* `container` - It loads credentials from a local metadata service. Containers currently supported by the AWS SDK are\n                **Amazon Elastic Container Service (ECS)** and **AWS Greengrass**\n* `instance-profile` - It loads credentials from the Amazon EC2 Instance Metadata Service.\n* `process` - Credentials are loaded from an external process. This is used to support the credential_process setting in the profile\n              credentials file. See https://docs.aws.amazon.com/cli/latest/topic/config-vars.html#sourcing-credentials-from-external-processes[Sourcing Credentials From External Processes]\n              for more information.\n* `anonymous` - It always returns anonymous AWS credentials. Anonymous AWS credentials result in un-authenticated requests and will\n                fail unless the resource or API\u0027s policy has been configured to specifically allow anonymous access.\n\n@asciidoclet",
      "sourceType": "io.quarkus.dynamodb.runtime.AwsCredentialsProviderConfig"
    },
    {
      "type": "boolean",
      "sourceField": "asyncCredentialUpdateEnabled",
      "defaultValue": "false",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.aws.credentials.default-provider.async-credential-update-enabled",
      "description": "Whether this provider should fetch credentials asynchronously in the background.\n\u003cp\u003e\nIf this is `true`, threads are less likely to block, but additional resources are used to maintain the provider.",
      "sourceType": "io.quarkus.dynamodb.runtime.AwsCredentialsProviderConfig.DefaultCredentialsProviderConfig"
    },
    {
      "type": "boolean",
      "sourceField": "reuseLastProviderEnabled",
      "defaultValue": "true",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.aws.credentials.default-provider.reuse-last-provider-enabled",
      "description": "Whether the provider should reuse the last successful credentials provider in the chain.\n\u003cp\u003e\nReusing the last successful credentials provider will typically return credentials faster than searching through the\nchain.",
      "sourceType": "io.quarkus.dynamodb.runtime.AwsCredentialsProviderConfig.DefaultCredentialsProviderConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "accessKeyId",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.aws.credentials.static-provider.access-key-id",
      "description": "AWS Access key id",
      "sourceType": "io.quarkus.dynamodb.runtime.AwsCredentialsProviderConfig.StaticCredentialsProviderConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "secretAccessKey",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.aws.credentials.static-provider.secret-access-key",
      "description": "AWS Secret access key",
      "sourceType": "io.quarkus.dynamodb.runtime.AwsCredentialsProviderConfig.StaticCredentialsProviderConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "profileName",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.aws.credentials.profile-provider.profile-name",
      "description": "The name of the profile that should be used by this credentials provider.\n\u003cp\u003e\nIf not specified, the value in `AWS_PROFILE` environment variable or `aws.profile` system property is used and\ndefaults to `default` name.",
      "sourceType": "io.quarkus.dynamodb.runtime.AwsCredentialsProviderConfig.ProfileCredentialsProviderConfig"
    },
    {
      "type": "boolean",
      "sourceField": "asyncCredentialUpdateEnabled",
      "defaultValue": "false",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.aws.credentials.process-provider.async-credential-update-enabled",
      "description": "Whether the provider should fetch credentials asynchronously in the background.\n\u003cp\u003e\nIf this is true, threads are less likely to block when credentials are loaded, but additional resources are used to\nmaintain the provider.",
      "sourceType": "io.quarkus.dynamodb.runtime.AwsCredentialsProviderConfig.ProcessCredentialsProviderConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "credentialRefreshThreshold",
      "defaultValue": "15S",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.aws.credentials.process-provider.credential-refresh-threshold",
      "description": "The amount of time between when the credentials expire and when the credentials should start to be\nrefreshed.\n\u003cp\u003e\nThis allows the credentials to be refreshed *before* they are reported to expire.",
      "sourceType": "io.quarkus.dynamodb.runtime.AwsCredentialsProviderConfig.ProcessCredentialsProviderConfig"
    },
    {
      "type": "io.quarkus.runtime.configuration.MemorySize",
      "sourceField": "processOutputLimit",
      "defaultValue": "1024",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.aws.credentials.process-provider.process-output-limit",
      "description": "The maximum size of the output that can be returned by the external process before an exception is raised.",
      "sourceType": "io.quarkus.dynamodb.runtime.AwsCredentialsProviderConfig.ProcessCredentialsProviderConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "command",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.aws.credentials.process-provider.command",
      "description": "The command that should be executed to retrieve credentials.",
      "sourceType": "io.quarkus.dynamodb.runtime.AwsCredentialsProviderConfig.ProcessCredentialsProviderConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "connectionTimeout",
      "defaultValue": "2S",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.sync-client.connection-timeout",
      "description": "The maximum amount of time to establish a connection before timing out.",
      "sourceType": "io.quarkus.dynamodb.runtime.SyncHttpClientConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "socketTimeout",
      "defaultValue": "30S",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.sync-client.socket-timeout",
      "description": "The amount of time to wait for data to be transferred over an established, open connection before the connection is\ntimed\nout.",
      "sourceType": "io.quarkus.dynamodb.runtime.SyncHttpClientConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "connectionAcquisitionTimeout",
      "defaultValue": "10S",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.sync-client.apache.connection-acquisition-timeout",
      "description": "The amount of time to wait when acquiring a connection from the pool before giving up and timing out.",
      "sourceType": "io.quarkus.dynamodb.runtime.SyncHttpClientConfig.ApacheHttpClientConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "connectionMaxIdleTime",
      "defaultValue": "60S",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.sync-client.apache.connection-max-idle-time",
      "description": "The maximum amount of time that a connection should be allowed to remain open while idle.",
      "sourceType": "io.quarkus.dynamodb.runtime.SyncHttpClientConfig.ApacheHttpClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "connectionTimeToLive",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.sync-client.apache.connection-time-to-live",
      "description": "The maximum amount of time that a connection should be allowed to remain open, regardless of usage frequency.",
      "sourceType": "io.quarkus.dynamodb.runtime.SyncHttpClientConfig.ApacheHttpClientConfig"
    },
    {
      "type": "int",
      "sourceField": "maxConnections",
      "defaultValue": "50",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.sync-client.apache.max-connections",
      "description": "The maximum number of connections allowed in the connection pool.\n\u003cp\u003e\nEach built HTTP client has its own private connection pool.",
      "sourceType": "io.quarkus.dynamodb.runtime.SyncHttpClientConfig.ApacheHttpClientConfig"
    },
    {
      "type": "boolean",
      "sourceField": "expectContinueEnabled",
      "defaultValue": "true",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.sync-client.apache.expect-continue-enabled",
      "description": "Whether the client should send an HTTP expect-continue handshake before each request.",
      "sourceType": "io.quarkus.dynamodb.runtime.SyncHttpClientConfig.ApacheHttpClientConfig"
    },
    {
      "type": "boolean",
      "sourceField": "useIdleConnectionReaper",
      "defaultValue": "true",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.sync-client.apache.use-idle-connection-reaper",
      "description": "Whether the idle connections in the connection pool should be closed asynchronously.\n\u003cp\u003e\nWhen enabled, connections left idling for longer than `quarkus.dynamodb.sync-client.connection-max-idle-time` will be\nclosed.\nThis will not close connections currently in use.",
      "sourceType": "io.quarkus.dynamodb.runtime.SyncHttpClientConfig.ApacheHttpClientConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enabled",
      "defaultValue": "false",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.sync-client.apache.proxy.enabled",
      "description": "Enable HTTP proxy",
      "sourceType": "io.quarkus.dynamodb.runtime.SyncHttpClientConfig.ApacheHttpClientConfig.HttpClientProxyConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.net.URI\u003e",
      "sourceField": "endpoint",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.sync-client.apache.proxy.endpoint",
      "description": "The endpoint of the proxy server that the SDK should connect through.\n\u003cp\u003e\nCurrently, the endpoint is limited to a host and port. Any other URI components will result in an exception being\nraised.",
      "sourceType": "io.quarkus.dynamodb.runtime.SyncHttpClientConfig.ApacheHttpClientConfig.HttpClientProxyConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "username",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.sync-client.apache.proxy.username",
      "description": "The username to use when connecting through a proxy.",
      "sourceType": "io.quarkus.dynamodb.runtime.SyncHttpClientConfig.ApacheHttpClientConfig.HttpClientProxyConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "password",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.sync-client.apache.proxy.password",
      "description": "The password to use when connecting through a proxy.",
      "sourceType": "io.quarkus.dynamodb.runtime.SyncHttpClientConfig.ApacheHttpClientConfig.HttpClientProxyConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "ntlmDomain",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.sync-client.apache.proxy.ntlm-domain",
      "description": "For NTLM proxies - the Windows domain name to use when authenticating with the proxy.",
      "sourceType": "io.quarkus.dynamodb.runtime.SyncHttpClientConfig.ApacheHttpClientConfig.HttpClientProxyConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "ntlmWorkstation",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.sync-client.apache.proxy.ntlm-workstation",
      "description": "For NTLM proxies - the Windows workstation name to use when authenticating with the proxy.",
      "sourceType": "io.quarkus.dynamodb.runtime.SyncHttpClientConfig.ApacheHttpClientConfig.HttpClientProxyConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Boolean\u003e",
      "sourceField": "preemptiveBasicAuthenticationEnabled",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.sync-client.apache.proxy.preemptive-basic-authentication-enabled",
      "description": "Whether to attempt to authenticate preemptively against the proxy server using basic authentication.",
      "sourceType": "io.quarkus.dynamodb.runtime.SyncHttpClientConfig.ApacheHttpClientConfig.HttpClientProxyConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "nonProxyHosts",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.sync-client.apache.proxy.non-proxy-hosts",
      "description": "The hosts that the client is allowed to access without going through the proxy.",
      "sourceType": "io.quarkus.dynamodb.runtime.SyncHttpClientConfig.ApacheHttpClientConfig.HttpClientProxyConfiguration"
    },
    {
      "type": "io.quarkus.dynamodb.runtime.TlsManagersProviderType",
      "sourceField": "type",
      "defaultValue": "system-property",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.dynamodb.sync-client.apache.tls-managers-provider.type",
      "description": "TLS managers provider type.\n\nAvailable providers:\n\n* `none` - Use this provider if you don\u0027t want the client to present any certificates to the remote TLS host.\n* `system-property` - Provider checks the standard `javax.net.ssl.keyStore`, `javax.net.ssl.keyStorePassword`, and\n                      `javax.net.ssl.keyStoreType` properties defined by the\n                       https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html[JSSE].\n* `file-store` - Provider that loads a the key store from a file.\n\n@asciidoclet",
      "sourceType": "io.quarkus.dynamodb.runtime.TlsManagersProviderConfig"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.dynamodb.runtime.TlsManagersProviderConfig.FileStoreTlsManagersProviderConfig\u003e",
      "sourceField": "fileStore",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.sync-client.apache.tls-managers-provider.file-store",
      "description": "Configuration of the file store provider.\n\u003cp\u003e\nUsed only if {@code FILE_STORE} type is chosen.",
      "sourceType": "io.quarkus.dynamodb.runtime.TlsManagersProviderConfig"
    },
    {
      "type": "int",
      "sourceField": "maxConcurrency",
      "defaultValue": "50",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.async-client.max-concurrency",
      "description": "The maximum number of allowed concurrent requests.\n\u003cp\u003e\nFor HTTP/1.1 this is the same as max connections. For HTTP/2 the number of connections that will be used depends on the\nmax streams allowed per connection.",
      "sourceType": "io.quarkus.dynamodb.runtime.NettyHttpClientConfig"
    },
    {
      "type": "int",
      "sourceField": "maxPendingConnectionAcquires",
      "defaultValue": "10000",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.async-client.max-pending-connection-acquires",
      "description": "The maximum number of pending acquires allowed.\n\u003cp\u003e\nOnce this exceeds, acquire tries will be failed.",
      "sourceType": "io.quarkus.dynamodb.runtime.NettyHttpClientConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "readTimeout",
      "defaultValue": "30S",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.async-client.read-timeout",
      "description": "The amount of time to wait for a read on a socket before an exception is thrown.\n\u003cp\u003e\nSpecify `0` to disable.",
      "sourceType": "io.quarkus.dynamodb.runtime.NettyHttpClientConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "writeTimeout",
      "defaultValue": "30S",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.async-client.write-timeout",
      "description": "The amount of time to wait for a write on a socket before an exception is thrown.\n\u003cp\u003e\nSpecify `0` to disable.",
      "sourceType": "io.quarkus.dynamodb.runtime.NettyHttpClientConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "connectionTimeout",
      "defaultValue": "10S",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.async-client.connection-timeout",
      "description": "The amount of time to wait when initially establishing a connection before giving up and timing out.",
      "sourceType": "io.quarkus.dynamodb.runtime.NettyHttpClientConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "connectionAcquisitionTimeout",
      "defaultValue": "2S",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.async-client.connection-acquisition-timeout",
      "description": "The amount of time to wait when acquiring a connection from the pool before giving up and timing out.",
      "sourceType": "io.quarkus.dynamodb.runtime.NettyHttpClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "connectionTimeToLive",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.async-client.connection-time-to-live",
      "description": "The maximum amount of time that a connection should be allowed to remain open, regardless of usage frequency.",
      "sourceType": "io.quarkus.dynamodb.runtime.NettyHttpClientConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "connectionMaxIdleTime",
      "defaultValue": "60S",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.async-client.connection-max-idle-time",
      "description": "The maximum amount of time that a connection should be allowed to remain open while idle.\n\u003cp\u003e\nCurrently has no effect if `quarkus.dynamodb.async-client.use-idle-connection-reaper` is false.",
      "sourceType": "io.quarkus.dynamodb.runtime.NettyHttpClientConfig"
    },
    {
      "type": "boolean",
      "sourceField": "useIdleConnectionReaper",
      "defaultValue": "true",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.async-client.use-idle-connection-reaper",
      "description": "Whether the idle connections in the connection pool should be closed.\n\u003cp\u003e\nWhen enabled, connections left idling for longer than `quarkus.dynamodb.async-client.connection-max-idle-time` will be\nclosed. This will not close connections currently in use.",
      "sourceType": "io.quarkus.dynamodb.runtime.NettyHttpClientConfig"
    },
    {
      "type": "software.amazon.awssdk.http.Protocol",
      "sourceField": "protocol",
      "defaultValue": "http1-1",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.dynamodb.async-client.protocol",
      "description": "The HTTP protocol to use.",
      "sourceType": "io.quarkus.dynamodb.runtime.NettyHttpClientConfig"
    },
    {
      "type": "int",
      "sourceField": "maxHttp2Streams",
      "defaultValue": "0",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.async-client.max-http2-streams",
      "description": "The maximum number of concurrent streams for an HTTP/2 connection.\n\u003cp\u003e\nThis setting is only respected when the HTTP/2 protocol is used.\n\u003cp\u003e\n0 means unlimited.",
      "sourceType": "io.quarkus.dynamodb.runtime.NettyHttpClientConfig"
    },
    {
      "type": "java.util.Optional\u003cio.netty.handler.ssl.SslProvider\u003e",
      "sourceField": "sslProvider",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.dynamodb.async-client.ssl-provider",
      "description": "The SSL Provider to be used in the Netty client.\n\u003cp\u003e\nDefault is `OPENSSL` if available, `JDK` otherwise.",
      "sourceType": "io.quarkus.dynamodb.runtime.NettyHttpClientConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enabled",
      "defaultValue": "false",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.async-client.proxy.enabled",
      "description": "Enable HTTP proxy.",
      "sourceType": "io.quarkus.dynamodb.runtime.NettyHttpClientConfig.NettyProxyConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.net.URI\u003e",
      "sourceField": "endpoint",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.async-client.proxy.endpoint",
      "description": "The endpoint of the proxy server that the SDK should connect through.\n\u003cp\u003e\nCurrently, the endpoint is limited to a host and port. Any other URI components will result in an exception being\nraised.",
      "sourceType": "io.quarkus.dynamodb.runtime.NettyHttpClientConfig.NettyProxyConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "nonProxyHosts",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.async-client.proxy.non-proxy-hosts",
      "description": "The hosts that the client is allowed to access without going through the proxy.",
      "sourceType": "io.quarkus.dynamodb.runtime.NettyHttpClientConfig.NettyProxyConfiguration"
    },
    {
      "type": "io.quarkus.dynamodb.runtime.TlsManagersProviderType",
      "sourceField": "type",
      "defaultValue": "system-property",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.dynamodb.async-client.tls-managers-provider.type",
      "description": "TLS managers provider type.\n\nAvailable providers:\n\n* `none` - Use this provider if you don\u0027t want the client to present any certificates to the remote TLS host.\n* `system-property` - Provider checks the standard `javax.net.ssl.keyStore`, `javax.net.ssl.keyStorePassword`, and\n                      `javax.net.ssl.keyStoreType` properties defined by the\n                       https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html[JSSE].\n* `file-store` - Provider that loads a the key store from a file.\n\n@asciidoclet",
      "sourceType": "io.quarkus.dynamodb.runtime.TlsManagersProviderConfig"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.dynamodb.runtime.TlsManagersProviderConfig.FileStoreTlsManagersProviderConfig\u003e",
      "sourceField": "fileStore",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.async-client.tls-managers-provider.file-store",
      "description": "Configuration of the file store provider.\n\u003cp\u003e\nUsed only if {@code FILE_STORE} type is chosen.",
      "sourceType": "io.quarkus.dynamodb.runtime.TlsManagersProviderConfig"
    },
    {
      "type": "boolean",
      "sourceField": "override",
      "defaultValue": "false",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.async-client.event-loop.override",
      "description": "Enable the custom configuration of the Netty event loop group.",
      "sourceType": "io.quarkus.dynamodb.runtime.NettyHttpClientConfig.SdkEventLoopGroupConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "numberOfThreads",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.async-client.event-loop.number-of-threads",
      "description": "Number of threads to use for the event loop group.\n\u003cp\u003e\nIf not set, the default Netty thread count is used (which is double the number of available processors unless the\n`io.netty.eventLoopThreads` system property is set.",
      "sourceType": "io.quarkus.dynamodb.runtime.NettyHttpClientConfig.SdkEventLoopGroupConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "threadNamePrefix",
      "extensionName": "quarkus-amazon-dynamodb",
      "required": false,
      "phase": 4,
      "name": "quarkus.dynamodb.async-client.event-loop.thread-name-prefix",
      "description": "The thread name prefix for threads created by this thread factory used by event loop group.\n\u003cp\u003e\nThe prefix will be appended with a number unique to the thread factory and a number unique to the thread.\n\u003cp\u003e\nIf not specified it defaults to `aws-java-sdk-NettyEventLoop`",
      "sourceType": "io.quarkus.dynamodb.runtime.NettyHttpClientConfig.SdkEventLoopGroupConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "path",
      "defaultValue": "default_banner.txt",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.banner.path",
      "description": "The path of the banner (path relative to root of classpath)\nwhich could be provided by user",
      "sourceType": "io.quarkus.banner.BannerConfig"
    },
    {
      "type": "boolean",
      "sourceField": "reflection",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.debug.reflection",
      "description": "If set to true, writes a list of all reflective classes to META-INF",
      "sourceType": "io.quarkus.deployment.DebugConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "generatedClassesDir",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.debug.generated-classes-dir",
      "description": "If set to a directory, all generated classes will be written into that directory",
      "sourceType": "io.quarkus.deployment.DebugConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "libraryPaths",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.jni.library-paths",
      "description": "Paths of library to load.",
      "sourceType": "io.quarkus.deployment.JniProcessor.JniConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enable",
      "defaultValue": "true",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.jni.enable",
      "description": "@deprecated JNI is always enabled starting from GraalVM 19.3.1.",
      "sourceType": "io.quarkus.deployment.JniProcessor.JniConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "password",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.live-reload.password",
      "description": "Password used to use to connect to the remote dev-mode application",
      "sourceType": "io.quarkus.deployment.LiveReloadConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "url",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.live-reload.url",
      "description": "URL used to use to connect to the remote dev-mode application",
      "sourceType": "io.quarkus.deployment.LiveReloadConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "groupId",
      "defaultValue": "io.quarkus",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.platform.group-id",
      "description": "groupId of the platform to use",
      "sourceType": "io.quarkus.deployment.PlatformConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "artifactId",
      "defaultValue": "quarkus-universe-bom",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.platform.artifact-id",
      "description": "artifactId of the platform to use",
      "sourceType": "io.quarkus.deployment.PlatformConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "version",
      "defaultValue": "999-SNAPSHOT",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.platform.version",
      "description": "version of the platform to use",
      "sourceType": "io.quarkus.deployment.PlatformConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Boolean\u003e",
      "sourceField": "native_",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.ssl.native",
      "description": "Enable native SSL support.",
      "sourceType": "io.quarkus.deployment.SslProcessor.SslConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "nativeImageWaitTime",
      "defaultValue": "PT5M",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.test.native-image-wait-time",
      "description": "Duration to wait for the native image to built during testing",
      "sourceType": "io.quarkus.deployment.TestConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "nativeImageProfile",
      "defaultValue": "prod",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.test.native-image-profile",
      "description": "The profile to use when testing the native image",
      "sourceType": "io.quarkus.deployment.TestConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "profile",
      "defaultValue": "test",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.test.profile",
      "description": "The profile to use when testing using @QuarkusTest",
      "sourceType": "io.quarkus.deployment.TestConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "groupId",
      "extensionName": "quarkus-core",
      "required": true,
      "phase": 1,
      "name": "quarkus.index-dependency.{*}.group-id",
      "description": "The maven groupId of the artifact to index",
      "sourceType": "io.quarkus.deployment.index.IndexDependencyConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "artifactId",
      "extensionName": "quarkus-core",
      "required": true,
      "phase": 1,
      "name": "quarkus.index-dependency.{*}.artifact-id",
      "description": "The maven artifactId of the artifact to index",
      "sourceType": "io.quarkus.deployment.index.IndexDependencyConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "classifier",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.index-dependency.{*}.classifier",
      "description": "The maven classifier of the artifact to index",
      "sourceType": "io.quarkus.deployment.index.IndexDependencyConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "additionalBuildArgs",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.additional-build-args",
      "description": "Additional arguments to pass to the build process",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enableHttpUrlHandler",
      "defaultValue": "true",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.enable-http-url-handler",
      "description": "If the HTTP url handler should be enabled, allowing you to do URL.openConnection() for HTTP URLs",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enableHttpsUrlHandler",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.enable-https-url-handler",
      "description": "If the HTTPS url handler should be enabled, allowing you to do URL.openConnection() for HTTPS URLs",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enableAllSecurityServices",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.enable-all-security-services",
      "description": "If all security services should be added to the native image",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enableJni",
      "defaultValue": "true",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.enable-jni",
      "description": "@deprecated JNI is always enabled starting from GraalVM 19.3.1.",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "addAllCharsets",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.add-all-charsets",
      "description": "If all character sets should be added to the native image. This increases image size",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "includeAllTimeZones",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.include-all-time-zones",
      "description": "If all time zones should be added to the native image. This increases image size",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "graalvmHome",
      "defaultValue": "${GRAALVM_HOME:}",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.graalvm-home",
      "description": "The location of the Graal distribution",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "java.io.File",
      "sourceField": "javaHome",
      "defaultValue": "${java.home}",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.java-home",
      "description": "The location of the JDK",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "nativeImageXmx",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.native-image-xmx",
      "description": "The maximum Java heap to be used during the native image generation",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "debugSymbols",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.debug-symbols",
      "description": "If debug symbols should be included",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "debugBuildProcess",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.debug-build-process",
      "description": "If the native image build should wait for a debugger to be attached before running. This is an advanced option\nand is generally only intended for those familiar with GraalVM internals",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "publishDebugBuildProcessPort",
      "defaultValue": "true",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.publish-debug-build-process-port",
      "description": "If the debug port should be published when building with docker and debug-build-process is true",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "cleanupServer",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.cleanup-server",
      "description": "If the native image server should be restarted",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enableIsolates",
      "defaultValue": "true",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.enable-isolates",
      "description": "If isolates should be enabled",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enableFallbackImages",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.enable-fallback-images",
      "description": "If a JVM based \u0027fallback image\u0027 should be created if native image fails. This is not recommended, as this is\nfunctionally the same as just running the application in a JVM",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enableServer",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.enable-server",
      "description": "If the native image server should be used. This can speed up compilation but can result in changes not always\nbeing picked up due to cache invalidation not working 100%",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "autoServiceLoaderRegistration",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.auto-service-loader-registration",
      "description": "If all META-INF/services entries should be automatically registered",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "dumpProxies",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.dump-proxies",
      "description": "If the bytecode of all proxies should be dumped for inspection",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "containerBuild",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.container-build",
      "description": "If this build should be done using a container runtime. If this is set docker will be used by default,\nunless container-runtime is also set.",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "builderImage",
      "defaultValue": "quay.io/quarkus/ubi-quarkus-native-image:19.3.1-java11",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.builder-image",
      "description": "The docker image to use to do the image build",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "containerRuntime",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.container-runtime",
      "description": "The container runtime (e.g. docker) that is used to do an image based build. If this is set then\na container build is always done.",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "containerRuntimeOptions",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.container-runtime-options",
      "description": "Options to pass to the container runtime",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enableVmInspection",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.enable-vm-inspection",
      "description": "If the resulting image should allow VM introspection",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "fullStackTraces",
      "defaultValue": "true",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.full-stack-traces",
      "description": "If full stack traces are enabled in the resulting image",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enableReports",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.enable-reports",
      "description": "If the reports on call paths and included packages/classes/methods should be generated",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "reportExceptionStackTraces",
      "defaultValue": "true",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.report-exception-stack-traces",
      "description": "If exceptions should be reported with a full stack trace",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "reportErrorsAtRuntime",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.native.report-errors-at-runtime",
      "description": "If errors should be reported at runtime. This is a more relaxed setting, however it is not recommended as it means\nyour application may fail at runtime if an unsupported feature is used by accident.",
      "sourceType": "io.quarkus.deployment.pkg.NativeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "type",
      "defaultValue": "jar",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.package.type",
      "description": "The requested output type.\n\nThe default built in types are jar and native",
      "sourceType": "io.quarkus.deployment.pkg.PackageConfig"
    },
    {
      "type": "boolean",
      "sourceField": "uberJar",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.package.uber-jar",
      "description": "If the java runner should be packed as an uberjar",
      "sourceType": "io.quarkus.deployment.pkg.PackageConfig"
    },
    {
      "type": "boolean",
      "sourceField": "addImplementationEntries",
      "defaultValue": "true",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.package.manifest.add-implementation-entries",
      "description": "If the Implementation information should be included in the runner jar\u0027s MANIFEST.MF.",
      "sourceType": "io.quarkus.deployment.pkg.ManifestConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "mainClass",
      "defaultValue": "io.quarkus.runner.GeneratedMain",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.package.main-class",
      "description": "The entry point of the application. In most cases this should not be modified.",
      "sourceType": "io.quarkus.deployment.pkg.PackageConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "userConfiguredIgnoredEntries",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.package.user-configured-ignored-entries",
      "description": "Files that should not be copied to the output artifact",
      "sourceType": "io.quarkus.deployment.pkg.PackageConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "runnerSuffix",
      "defaultValue": "-runner",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.package.runner-suffix",
      "description": "The suffix that is applied to the runner jar and native images",
      "sourceType": "io.quarkus.deployment.pkg.PackageConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "outputDirectory",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.package.output-directory",
      "description": "The output folder in which to place the output, this is resolved relative to the build\nsystems target directory.",
      "sourceType": "io.quarkus.deployment.pkg.PackageConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "outputName",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 1,
      "name": "quarkus.package.output-name",
      "description": "The name of the final artifact",
      "sourceType": "io.quarkus.deployment.pkg.PackageConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "group",
      "defaultValue": "${user.name}",
      "extensionName": "quarkus-container-image",
      "required": false,
      "phase": 1,
      "name": "quarkus.container-image.group",
      "description": "The group the container image will be part of",
      "sourceType": "io.quarkus.container.image.deployment.ContainerImageConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "defaultValue": "${quarkus.application.name:unset}",
      "extensionName": "quarkus-container-image",
      "required": false,
      "phase": 1,
      "name": "quarkus.container-image.name",
      "description": "The name of the container image. If not set defaults to the application name",
      "sourceType": "io.quarkus.container.image.deployment.ContainerImageConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "tag",
      "defaultValue": "${quarkus.application.version:latest}",
      "extensionName": "quarkus-container-image",
      "required": false,
      "phase": 1,
      "name": "quarkus.container-image.tag",
      "description": "The tag of the container image. If not set defaults to the application version",
      "sourceType": "io.quarkus.container.image.deployment.ContainerImageConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "registry",
      "extensionName": "quarkus-container-image",
      "required": false,
      "phase": 1,
      "name": "quarkus.container-image.registry",
      "description": "The container registry to use",
      "sourceType": "io.quarkus.container.image.deployment.ContainerImageConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "username",
      "extensionName": "quarkus-container-image",
      "required": false,
      "phase": 1,
      "name": "quarkus.container-image.username",
      "description": "The username to use to authenticate with the registry",
      "sourceType": "io.quarkus.container.image.deployment.ContainerImageConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "password",
      "extensionName": "quarkus-container-image",
      "required": false,
      "phase": 1,
      "name": "quarkus.container-image.password",
      "description": "The password to use to authenticate with the registry",
      "sourceType": "io.quarkus.container.image.deployment.ContainerImageConfig"
    },
    {
      "type": "boolean",
      "sourceField": "insecure",
      "defaultValue": "false",
      "extensionName": "quarkus-container-image",
      "required": false,
      "phase": 1,
      "name": "quarkus.container-image.insecure",
      "description": "Whether or not insecure registries are allowed",
      "sourceType": "io.quarkus.container.image.deployment.ContainerImageConfig"
    },
    {
      "type": "boolean",
      "sourceField": "build",
      "defaultValue": "false",
      "extensionName": "quarkus-container-image",
      "required": false,
      "phase": 1,
      "name": "quarkus.container-image.build",
      "description": "Whether or not a image build will be performed.",
      "sourceType": "io.quarkus.container.image.deployment.ContainerImageConfig"
    },
    {
      "type": "boolean",
      "sourceField": "push",
      "defaultValue": "false",
      "extensionName": "quarkus-container-image",
      "required": false,
      "phase": 1,
      "name": "quarkus.container-image.push",
      "description": "Whether or not an image push will be performed.",
      "sourceType": "io.quarkus.container.image.deployment.ContainerImageConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "removeUnusedBeans",
      "defaultValue": "all",
      "extensionName": "quarkus-arc",
      "required": false,
      "phase": 1,
      "name": "quarkus.arc.remove-unused-beans",
      "description": "\u003cul\u003e\n\u003cli\u003eIf set to `all` (or `true`) the container will attempt to remove all unused beans.\u003c/li\u003e\n\u003cli\u003eIf set to none (or `false`) no beans will ever be removed even if they are unused (according to the criteria set out\nbelow)\u003c/li\u003e\n\u003cli\u003eIf set to `fwk`, then all unused beans will be removed, except the unused beans whose classes are declared in the\napplication code\u003c/li\u003e\n\u003c/ul\u003e\n\u003cbr\u003e\n\u003cp\u003e\nAn unused bean:\n\u003cul\u003e\n\u003cli\u003eis not a built-in bean or interceptor,\u003c/li\u003e\n\u003cli\u003eis not eligible for injection to any injection point,\u003c/li\u003e\n\u003cli\u003eis not excluded by any extension,\u003c/li\u003e\n\u003cli\u003edoes not have a name,\u003c/li\u003e\n\u003cli\u003edoes not declare an observer,\u003c/li\u003e\n\u003cli\u003edoes not declare any producer which is eligible for injection to any injection point,\u003c/li\u003e\n\u003cli\u003eis not directly eligible for injection into any {@link javax.enterprise.inject.Instance} injection point\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\n@see UnremovableBeanBuildItem",
      "sourceType": "io.quarkus.arc.deployment.ArcConfig"
    },
    {
      "type": "boolean",
      "sourceField": "autoInjectFields",
      "defaultValue": "true",
      "extensionName": "quarkus-arc",
      "required": false,
      "phase": 1,
      "name": "quarkus.arc.auto-inject-fields",
      "description": "If set to true {@code @Inject} is automatically added to all non-static fields that are annotated with\none of the annotations defined by {@link AutoInjectAnnotationBuildItem}.",
      "sourceType": "io.quarkus.arc.deployment.ArcConfig"
    },
    {
      "type": "boolean",
      "sourceField": "removeFinalForProxyableMethods",
      "defaultValue": "true",
      "extensionName": "quarkus-arc",
      "required": false,
      "phase": 1,
      "name": "quarkus.arc.remove-final-for-proxyable-methods",
      "description": "If set to true, Arc will transform the bytecode of beans containing methods that need to be proxyable\nbut have been declared as final. The transformation is simply a matter of removing final.\nThis ensures that a proxy can be created properly.\nIf the value is set to false, then an exception is thrown at build time indicating\nthat a proxy could not be created because a method was final.",
      "sourceType": "io.quarkus.arc.deployment.ArcConfig"
    },
    {
      "type": "io.quarkus.arc.config.ConfigProperties.NamingStrategy",
      "sourceField": "configPropertiesDefaultNamingStrategy",
      "defaultValue": "kebab-case",
      "extensionName": "quarkus-arc",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.arc.config-properties-default-naming-strategy",
      "description": "The default naming strategy for {@link ConfigProperties.NamingStrategy}. The allowed values are determined\nby that enum",
      "sourceType": "io.quarkus.arc.deployment.ArcConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 2,
      "name": "quarkus.application.name",
      "description": "The name of the application.\nIf not set, defaults to the name of the project (except for tests where it is not set at all).",
      "sourceType": "io.quarkus.runtime.ApplicationConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "version",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 2,
      "name": "quarkus.application.version",
      "description": "The version of the application.\nIf not set, defaults to the version of the project (except for tests where it is not set at all).",
      "sourceType": "io.quarkus.runtime.ApplicationConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enabled",
      "defaultValue": "true",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.banner.enabled",
      "description": "Whether or not the banner will be displayed",
      "sourceType": "io.quarkus.runtime.BannerRuntimeConfig"
    },
    {
      "type": "java.util.Set\u003cjava.util.Locale\u003e",
      "sourceField": "locales",
      "defaultValue": "${user.language:en}-${user.country:}",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 2,
      "name": "quarkus.locales",
      "description": "The set of supported locales that can be consumed by the extensions.\n\u003cp\u003e\nThe locales must be specified in the IETF BCP 47 format e.g. en-US or fr-FR.\n\u003cp\u003e\nFor instance, the Hibernate Validator extension makes use of it.",
      "sourceType": "io.quarkus.runtime.LocalesBuildTimeConfig"
    },
    {
      "type": "java.util.Locale",
      "sourceField": "defaultLocale",
      "defaultValue": "${user.language:en}-${user.country:}",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 2,
      "name": "quarkus.default-locale",
      "description": "Default locale that can be consumed by the extensions.\n\u003cp\u003e\nThe locales must be specified in the IETF BCP 47 format e.g. en-US or fr-FR.\n\u003cp\u003e\nFor instance, the Hibernate Validator extension makes use of it.",
      "sourceType": "io.quarkus.runtime.LocalesBuildTimeConfig"
    },
    {
      "type": "int",
      "sourceField": "coreThreads",
      "defaultValue": "1",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.thread-pool.core-threads",
      "description": "The core thread pool size. This number of threads will always be kept alive.",
      "sourceType": "io.quarkus.runtime.ThreadPoolConfig"
    },
    {
      "type": "boolean",
      "sourceField": "prefill",
      "defaultValue": "true",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.thread-pool.prefill",
      "description": "Prefill core thread pool.\nThe core thread pool will be initialised with the core number of threads at startup",
      "sourceType": "io.quarkus.runtime.ThreadPoolConfig"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "maxThreads",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.thread-pool.max-threads",
      "description": "The maximum number of threads. If this is not specified then\nit will be automatically sized to 8 * the number of available processors",
      "sourceType": "io.quarkus.runtime.ThreadPoolConfig"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "queueSize",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.thread-pool.queue-size",
      "description": "The queue size. For most applications this should be unbounded",
      "sourceType": "io.quarkus.runtime.ThreadPoolConfig"
    },
    {
      "type": "float",
      "sourceField": "growthResistance",
      "defaultValue": "0",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.thread-pool.growth-resistance",
      "description": "The executor growth resistance.\n\nA resistance factor applied after the core pool is full; values applied here will cause that fraction\nof submissions to create new threads when no idle thread is available. A value of {@code 0.0f} implies that\nthreads beyond the core size should be created as aggressively as threads within it; a value of {@code 1.0f}\nimplies that threads beyond the core size should never be created.",
      "sourceType": "io.quarkus.runtime.ThreadPoolConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "shutdownTimeout",
      "defaultValue": "1M",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.thread-pool.shutdown-timeout",
      "description": "The shutdown timeout. If all pending work has not been completed by this time\nthen additional threads will be spawned to attempt to finish any pending tasks, and the shutdown process will\ncontinue",
      "sourceType": "io.quarkus.runtime.ThreadPoolConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "shutdownInterrupt",
      "defaultValue": "10",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.thread-pool.shutdown-interrupt",
      "description": "The amount of time to wait for thread pool shutdown before tasks should be interrupted. If this value is\ngreater than or equal to the value for {@link #shutdownTimeout}, then tasks will not be interrupted before\nthe shutdown timeout occurs.",
      "sourceType": "io.quarkus.runtime.ThreadPoolConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "shutdownCheckInterval",
      "defaultValue": "5",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.thread-pool.shutdown-check-interval",
      "description": "The frequency at which the status of the thread pool should be checked during shutdown. Information about\nwaiting tasks and threads will be checked and possibly logged at this interval. Setting this key to an empty\nvalue disables the shutdown check interval.",
      "sourceType": "io.quarkus.runtime.ThreadPoolConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "keepAliveTime",
      "defaultValue": "30",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.thread-pool.keep-alive-time",
      "description": "The amount of time a thread will stay alive with no work.",
      "sourceType": "io.quarkus.runtime.ThreadPoolConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "profile",
      "defaultValue": "prod",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.profile",
      "description": "Profile that will be active when Quarkus launches",
      "sourceType": "io.quarkus.runtime.TopLevelRootConfig"
    },
    {
      "type": "java.util.logging.Level",
      "sourceField": "level",
      "defaultValue": "INFO",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.level",
      "description": "The log level of the root category, which is used as the default log level for all categories.",
      "sourceType": "io.quarkus.runtime.logging.LogConfig"
    },
    {
      "type": "java.util.logging.Level",
      "sourceField": "minLevel",
      "defaultValue": "INFO",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.min-level",
      "description": "The default minimum log level",
      "sourceType": "io.quarkus.runtime.logging.LogConfig"
    },
    {
      "type": "io.quarkus.runtime.logging.InheritableLevel",
      "sourceField": "level",
      "defaultValue": "inherit",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.category.{*}.level",
      "description": "The log level level for this category",
      "sourceType": "io.quarkus.runtime.logging.CategoryConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "handlers",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.category.{*}.handlers",
      "description": "The names of the handlers to link to this category.",
      "sourceType": "io.quarkus.runtime.logging.CategoryConfig"
    },
    {
      "type": "boolean",
      "sourceField": "useParentHandlers",
      "defaultValue": "true",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.category.{*}.use-parent-handlers",
      "description": "Specify whether or not this logger should send its output to its parent Logger",
      "sourceType": "io.quarkus.runtime.logging.CategoryConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enable",
      "defaultValue": "true",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.console.{*}.enable",
      "description": "If console logging should be enabled",
      "sourceType": "io.quarkus.runtime.logging.ConsoleConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "format",
      "defaultValue": "%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c{3.}] (%t) %s%e%n",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.console.{*}.format",
      "description": "The log format. Note that this value will be ignored if an extension is present that takes\ncontrol of console formatting (e.g. an XML or JSON-format extension).",
      "sourceType": "io.quarkus.runtime.logging.ConsoleConfig"
    },
    {
      "type": "java.util.logging.Level",
      "sourceField": "level",
      "defaultValue": "ALL",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.console.{*}.level",
      "description": "The console log level.",
      "sourceType": "io.quarkus.runtime.logging.ConsoleConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Boolean\u003e",
      "sourceField": "color",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.console.{*}.color",
      "description": "If the console logging should be in color. If undefined quarkus takes\nbest guess based on operating system and environment.\nNote that this value will be ignored if an extension is present that takes\ncontrol of console formatting (e.g. an XML or JSON-format extension).",
      "sourceType": "io.quarkus.runtime.logging.ConsoleConfig"
    },
    {
      "type": "int",
      "sourceField": "darken",
      "defaultValue": "0",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.console.{*}.darken",
      "description": "Specify how much the colors should be darkened.\nNote that this value will be ignored if an extension is present that takes\ncontrol of console formatting (e.g. an XML or JSON-format extension).",
      "sourceType": "io.quarkus.runtime.logging.ConsoleConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enable",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.console.{*}.async",
      "description": "Indicates whether to log asynchronously",
      "sourceType": "io.quarkus.runtime.logging.AsyncConfig"
    },
    {
      "type": "int",
      "sourceField": "queueLength",
      "defaultValue": "512",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.console.{*}.async.queue-length",
      "description": "The queue length to use before flushing writing",
      "sourceType": "io.quarkus.runtime.logging.AsyncConfig"
    },
    {
      "type": "org.jboss.logmanager.handlers.AsyncHandler.OverflowAction",
      "sourceField": "overflow",
      "defaultValue": "block",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.log.handler.console.{*}.async.overflow",
      "description": "Determine whether to block the publisher (rather than drop the message) when the queue is full",
      "sourceType": "io.quarkus.runtime.logging.AsyncConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enable",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.file.{*}.enable",
      "description": "If file logging should be enabled",
      "sourceType": "io.quarkus.runtime.logging.FileConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "format",
      "defaultValue": "%d{yyyy-MM-dd HH:mm:ss,SSS} %h %N[%i] %-5p [%c{3.}] (%t) %s%e%n",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.file.{*}.format",
      "description": "The log format",
      "sourceType": "io.quarkus.runtime.logging.FileConfig"
    },
    {
      "type": "java.util.logging.Level",
      "sourceField": "level",
      "defaultValue": "ALL",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.file.{*}.level",
      "description": "The level of logs to be written into the file.",
      "sourceType": "io.quarkus.runtime.logging.FileConfig"
    },
    {
      "type": "java.io.File",
      "sourceField": "path",
      "defaultValue": "quarkus.log",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.file.{*}.path",
      "description": "The name of the file in which logs will be written.",
      "sourceType": "io.quarkus.runtime.logging.FileConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enable",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.file.{*}.async",
      "description": "Indicates whether to log asynchronously",
      "sourceType": "io.quarkus.runtime.logging.AsyncConfig"
    },
    {
      "type": "int",
      "sourceField": "queueLength",
      "defaultValue": "512",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.file.{*}.async.queue-length",
      "description": "The queue length to use before flushing writing",
      "sourceType": "io.quarkus.runtime.logging.AsyncConfig"
    },
    {
      "type": "org.jboss.logmanager.handlers.AsyncHandler.OverflowAction",
      "sourceField": "overflow",
      "defaultValue": "block",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.log.handler.file.{*}.async.overflow",
      "description": "Determine whether to block the publisher (rather than drop the message) when the queue is full",
      "sourceType": "io.quarkus.runtime.logging.AsyncConfig"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.runtime.configuration.MemorySize\u003e",
      "sourceField": "maxFileSize",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.file.{*}.rotation.max-file-size",
      "description": "The maximum file size of the log file after which a rotation is executed.",
      "sourceType": "io.quarkus.runtime.logging.FileConfig.RotationConfig"
    },
    {
      "type": "int",
      "sourceField": "maxBackupIndex",
      "defaultValue": "1",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.file.{*}.rotation.max-backup-index",
      "description": "The maximum number of backups to keep.",
      "sourceType": "io.quarkus.runtime.logging.FileConfig.RotationConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "fileSuffix",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.file.{*}.rotation.file-suffix",
      "description": "File handler rotation file suffix.\n\nExample fileSuffix: .yyyy-MM-dd",
      "sourceType": "io.quarkus.runtime.logging.FileConfig.RotationConfig"
    },
    {
      "type": "boolean",
      "sourceField": "rotateOnBoot",
      "defaultValue": "true",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.file.{*}.rotation.rotate-on-boot",
      "description": "Indicates whether to rotate log files on server initialization.",
      "sourceType": "io.quarkus.runtime.logging.FileConfig.RotationConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enable",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.syslog.{*}.enable",
      "description": "If syslog logging should be enabled",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "java.net.InetSocketAddress",
      "sourceField": "endpoint",
      "defaultValue": "localhost:514",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.syslog.{*}.endpoint",
      "description": "The IP address and port of the syslog server",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "appName",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.syslog.{*}.app-name",
      "description": "The app name used when formatting the message in RFC5424 format",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "hostname",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.syslog.{*}.hostname",
      "description": "The name of the host the messages are being sent from",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "org.jboss.logmanager.handlers.SyslogHandler.Facility",
      "sourceField": "facility",
      "defaultValue": "user-level",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.log.handler.syslog.{*}.facility",
      "description": "Sets the facility used when calculating the priority of the message as defined by RFC-5424 and RFC-3164",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "org.jboss.logmanager.handlers.SyslogHandler.SyslogType",
      "sourceField": "syslogType",
      "defaultValue": "rfc5424",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.log.handler.syslog.{*}.syslog-type",
      "description": "Set the {@link SyslogType syslog type} this handler should use to format the message sent",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "org.jboss.logmanager.handlers.SyslogHandler.Protocol",
      "sourceField": "protocol",
      "defaultValue": "tcp",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.log.handler.syslog.{*}.protocol",
      "description": "Sets the protocol used to connect to the syslog server",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "boolean",
      "sourceField": "useCountingFraming",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.syslog.{*}.use-counting-framing",
      "description": "Set to {@code true} if the message being sent should be prefixed with the size of the message",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "boolean",
      "sourceField": "truncate",
      "defaultValue": "true",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.syslog.{*}.truncate",
      "description": "Set to {@code true} if the message should be truncated",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "boolean",
      "sourceField": "blockOnReconnect",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.syslog.{*}.block-on-reconnect",
      "description": "Enables or disables blocking when attempting to reconnect a\n{@link org.jboss.logmanager.handlers.SyslogHandler.Protocol#TCP\nTCP} or {@link org.jboss.logmanager.handlers.SyslogHandler.Protocol#SSL_TCP SSL TCP} protocol",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "format",
      "defaultValue": "%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c{3.}] (%t) %s%e%n",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.syslog.{*}.format",
      "description": "The log message format",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "java.util.logging.Level",
      "sourceField": "level",
      "defaultValue": "ALL",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.syslog.{*}.level",
      "description": "The log level specifying, which message levels will be logged by syslog logger",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enable",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.syslog.{*}.async",
      "description": "Indicates whether to log asynchronously",
      "sourceType": "io.quarkus.runtime.logging.AsyncConfig"
    },
    {
      "type": "int",
      "sourceField": "queueLength",
      "defaultValue": "512",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.handler.syslog.{*}.async.queue-length",
      "description": "The queue length to use before flushing writing",
      "sourceType": "io.quarkus.runtime.logging.AsyncConfig"
    },
    {
      "type": "org.jboss.logmanager.handlers.AsyncHandler.OverflowAction",
      "sourceField": "overflow",
      "defaultValue": "block",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.log.handler.syslog.{*}.async.overflow",
      "description": "Determine whether to block the publisher (rather than drop the message) when the queue is full",
      "sourceType": "io.quarkus.runtime.logging.AsyncConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enable",
      "defaultValue": "true",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.console.enable",
      "description": "If console logging should be enabled",
      "sourceType": "io.quarkus.runtime.logging.ConsoleConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "format",
      "defaultValue": "%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c{3.}] (%t) %s%e%n",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.console.format",
      "description": "The log format. Note that this value will be ignored if an extension is present that takes\ncontrol of console formatting (e.g. an XML or JSON-format extension).",
      "sourceType": "io.quarkus.runtime.logging.ConsoleConfig"
    },
    {
      "type": "java.util.logging.Level",
      "sourceField": "level",
      "defaultValue": "ALL",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.console.level",
      "description": "The console log level.",
      "sourceType": "io.quarkus.runtime.logging.ConsoleConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Boolean\u003e",
      "sourceField": "color",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.console.color",
      "description": "If the console logging should be in color. If undefined quarkus takes\nbest guess based on operating system and environment.\nNote that this value will be ignored if an extension is present that takes\ncontrol of console formatting (e.g. an XML or JSON-format extension).",
      "sourceType": "io.quarkus.runtime.logging.ConsoleConfig"
    },
    {
      "type": "int",
      "sourceField": "darken",
      "defaultValue": "0",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.console.darken",
      "description": "Specify how much the colors should be darkened.\nNote that this value will be ignored if an extension is present that takes\ncontrol of console formatting (e.g. an XML or JSON-format extension).",
      "sourceType": "io.quarkus.runtime.logging.ConsoleConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enable",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.console.async",
      "description": "Indicates whether to log asynchronously",
      "sourceType": "io.quarkus.runtime.logging.AsyncConfig"
    },
    {
      "type": "int",
      "sourceField": "queueLength",
      "defaultValue": "512",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.console.async.queue-length",
      "description": "The queue length to use before flushing writing",
      "sourceType": "io.quarkus.runtime.logging.AsyncConfig"
    },
    {
      "type": "org.jboss.logmanager.handlers.AsyncHandler.OverflowAction",
      "sourceField": "overflow",
      "defaultValue": "block",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.log.console.async.overflow",
      "description": "Determine whether to block the publisher (rather than drop the message) when the queue is full",
      "sourceType": "io.quarkus.runtime.logging.AsyncConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enable",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.file.enable",
      "description": "If file logging should be enabled",
      "sourceType": "io.quarkus.runtime.logging.FileConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "format",
      "defaultValue": "%d{yyyy-MM-dd HH:mm:ss,SSS} %h %N[%i] %-5p [%c{3.}] (%t) %s%e%n",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.file.format",
      "description": "The log format",
      "sourceType": "io.quarkus.runtime.logging.FileConfig"
    },
    {
      "type": "java.util.logging.Level",
      "sourceField": "level",
      "defaultValue": "ALL",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.file.level",
      "description": "The level of logs to be written into the file.",
      "sourceType": "io.quarkus.runtime.logging.FileConfig"
    },
    {
      "type": "java.io.File",
      "sourceField": "path",
      "defaultValue": "quarkus.log",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.file.path",
      "description": "The name of the file in which logs will be written.",
      "sourceType": "io.quarkus.runtime.logging.FileConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enable",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.file.async",
      "description": "Indicates whether to log asynchronously",
      "sourceType": "io.quarkus.runtime.logging.AsyncConfig"
    },
    {
      "type": "int",
      "sourceField": "queueLength",
      "defaultValue": "512",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.file.async.queue-length",
      "description": "The queue length to use before flushing writing",
      "sourceType": "io.quarkus.runtime.logging.AsyncConfig"
    },
    {
      "type": "org.jboss.logmanager.handlers.AsyncHandler.OverflowAction",
      "sourceField": "overflow",
      "defaultValue": "block",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.log.file.async.overflow",
      "description": "Determine whether to block the publisher (rather than drop the message) when the queue is full",
      "sourceType": "io.quarkus.runtime.logging.AsyncConfig"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.runtime.configuration.MemorySize\u003e",
      "sourceField": "maxFileSize",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.file.rotation.max-file-size",
      "description": "The maximum file size of the log file after which a rotation is executed.",
      "sourceType": "io.quarkus.runtime.logging.FileConfig.RotationConfig"
    },
    {
      "type": "int",
      "sourceField": "maxBackupIndex",
      "defaultValue": "1",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.file.rotation.max-backup-index",
      "description": "The maximum number of backups to keep.",
      "sourceType": "io.quarkus.runtime.logging.FileConfig.RotationConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "fileSuffix",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.file.rotation.file-suffix",
      "description": "File handler rotation file suffix.\n\nExample fileSuffix: .yyyy-MM-dd",
      "sourceType": "io.quarkus.runtime.logging.FileConfig.RotationConfig"
    },
    {
      "type": "boolean",
      "sourceField": "rotateOnBoot",
      "defaultValue": "true",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.file.rotation.rotate-on-boot",
      "description": "Indicates whether to rotate log files on server initialization.",
      "sourceType": "io.quarkus.runtime.logging.FileConfig.RotationConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enable",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.syslog.enable",
      "description": "If syslog logging should be enabled",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "java.net.InetSocketAddress",
      "sourceField": "endpoint",
      "defaultValue": "localhost:514",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.syslog.endpoint",
      "description": "The IP address and port of the syslog server",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "appName",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.syslog.app-name",
      "description": "The app name used when formatting the message in RFC5424 format",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "hostname",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.syslog.hostname",
      "description": "The name of the host the messages are being sent from",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "org.jboss.logmanager.handlers.SyslogHandler.Facility",
      "sourceField": "facility",
      "defaultValue": "user-level",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.log.syslog.facility",
      "description": "Sets the facility used when calculating the priority of the message as defined by RFC-5424 and RFC-3164",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "org.jboss.logmanager.handlers.SyslogHandler.SyslogType",
      "sourceField": "syslogType",
      "defaultValue": "rfc5424",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.log.syslog.syslog-type",
      "description": "Set the {@link SyslogType syslog type} this handler should use to format the message sent",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "org.jboss.logmanager.handlers.SyslogHandler.Protocol",
      "sourceField": "protocol",
      "defaultValue": "tcp",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.log.syslog.protocol",
      "description": "Sets the protocol used to connect to the syslog server",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "boolean",
      "sourceField": "useCountingFraming",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.syslog.use-counting-framing",
      "description": "Set to {@code true} if the message being sent should be prefixed with the size of the message",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "boolean",
      "sourceField": "truncate",
      "defaultValue": "true",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.syslog.truncate",
      "description": "Set to {@code true} if the message should be truncated",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "boolean",
      "sourceField": "blockOnReconnect",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.syslog.block-on-reconnect",
      "description": "Enables or disables blocking when attempting to reconnect a\n{@link org.jboss.logmanager.handlers.SyslogHandler.Protocol#TCP\nTCP} or {@link org.jboss.logmanager.handlers.SyslogHandler.Protocol#SSL_TCP SSL TCP} protocol",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "format",
      "defaultValue": "%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c{3.}] (%t) %s%e%n",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.syslog.format",
      "description": "The log message format",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "java.util.logging.Level",
      "sourceField": "level",
      "defaultValue": "ALL",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.syslog.level",
      "description": "The log level specifying, which message levels will be logged by syslog logger",
      "sourceType": "io.quarkus.runtime.logging.SyslogConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enable",
      "defaultValue": "false",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.syslog.async",
      "description": "Indicates whether to log asynchronously",
      "sourceType": "io.quarkus.runtime.logging.AsyncConfig"
    },
    {
      "type": "int",
      "sourceField": "queueLength",
      "defaultValue": "512",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.syslog.async.queue-length",
      "description": "The queue length to use before flushing writing",
      "sourceType": "io.quarkus.runtime.logging.AsyncConfig"
    },
    {
      "type": "org.jboss.logmanager.handlers.AsyncHandler.OverflowAction",
      "sourceField": "overflow",
      "defaultValue": "block",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.log.syslog.async.overflow",
      "description": "Determine whether to block the publisher (rather than drop the message) when the queue is full",
      "sourceType": "io.quarkus.runtime.logging.AsyncConfig"
    },
    {
      "type": "java.util.List\u003cjava.lang.String\u003e",
      "sourceField": "ifStartsWith",
      "defaultValue": "inherit",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.log.filter.{*}.if-starts-with",
      "description": "The message starts to match",
      "sourceType": "io.quarkus.runtime.logging.CleanupFilterConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "timeout",
      "extensionName": "quarkus-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.shutdown.timeout",
      "description": "The timeout to wait for running requests to finish. If this is not set then the application will exit immediately.\n\nSetting this timeout will incur a small performance penalty, as it requires active requests to be tracked.",
      "sourceType": "io.quarkus.runtime.shutdown.ShutdownConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enabled",
      "defaultValue": "true",
      "extensionName": "quarkus-elytron-security-oauth2",
      "required": false,
      "phase": 2,
      "name": "quarkus.oauth2.enabled",
      "description": "Determine if the OAuth2 extension is enabled. Enabled by default if you include the\n\u003ccode\u003eelytron-security-oauth2\u003c/code\u003e dependency, so this would be used to disable it.",
      "sourceType": "io.quarkus.elytron.security.oauth2.runtime.OAuth2Config"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "clientId",
      "extensionName": "quarkus-elytron-security-oauth2",
      "required": false,
      "phase": 2,
      "name": "quarkus.oauth2.client-id",
      "description": "The OAuth2 client id used to validate the token.\nMandatory if the extension is enabled.",
      "sourceType": "io.quarkus.elytron.security.oauth2.runtime.OAuth2Config"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "clientSecret",
      "extensionName": "quarkus-elytron-security-oauth2",
      "required": false,
      "phase": 2,
      "name": "quarkus.oauth2.client-secret",
      "description": "The OAuth2 client secret used to validate the token.\nMandatory if the extension is enabled.",
      "sourceType": "io.quarkus.elytron.security.oauth2.runtime.OAuth2Config"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "introspectionUrl",
      "extensionName": "quarkus-elytron-security-oauth2",
      "required": false,
      "phase": 2,
      "name": "quarkus.oauth2.introspection-url",
      "description": "The OAuth2 introspection endpoint URL used to validate the token and gather the authentication claims.\nMandatory if the extension is enabled.",
      "sourceType": "io.quarkus.elytron.security.oauth2.runtime.OAuth2Config"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "caCertFile",
      "extensionName": "quarkus-elytron-security-oauth2",
      "required": false,
      "phase": 2,
      "name": "quarkus.oauth2.ca-cert-file",
      "description": "The OAuth2 server certificate file. \u003cem\u003eWarning\u003c/em\u003e: this is not supported in native mode where the certificate\nmust be included in the truststore used during the native image generation, see\n\u003ca href\u003d\"native-and-ssl.html\"\u003eUsing SSL With Native Executables\u003c/a\u003e.",
      "sourceType": "io.quarkus.elytron.security.oauth2.runtime.OAuth2Config"
    },
    {
      "type": "java.lang.String",
      "sourceField": "roleClaim",
      "defaultValue": "scope",
      "extensionName": "quarkus-elytron-security-oauth2",
      "required": false,
      "phase": 2,
      "name": "quarkus.oauth2.role-claim",
      "description": "The claim that is used in the introspection endpoint response to load the roles.",
      "sourceType": "io.quarkus.elytron.security.oauth2.runtime.OAuth2Config"
    },
    {
      "type": "java.util.List\u003cjava.lang.String\u003e",
      "sourceField": "locations",
      "defaultValue": "db/migration",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 2,
      "name": "quarkus.flyway.locations",
      "description": "Comma-separated list of locations to scan recursively for migrations. The location type is determined by its prefix.\n\u003cp\u003e\nUnprefixed locations or locations starting with classpath: point to a package on the classpath and may contain both SQL\nand Java-based migrations.\n\u003cp\u003e\nLocations starting with filesystem: point to a directory on the filesystem, may only contain SQL migrations and are only\nscanned recursively down non-hidden directories.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceBuildTimeConfig"
    },
    {
      "type": "java.util.List\u003cjava.lang.String\u003e",
      "sourceField": "locations",
      "defaultValue": "db/migration",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 2,
      "name": "quarkus.flyway.{*}.locations",
      "description": "Comma-separated list of locations to scan recursively for migrations. The location type is determined by its prefix.\n\u003cp\u003e\nUnprefixed locations or locations starting with classpath: point to a package on the classpath and may contain both SQL\nand Java-based migrations.\n\u003cp\u003e\nLocations starting with filesystem: point to a directory on the filesystem, may only contain SQL migrations and are only\nscanned recursively down non-hidden directories.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceBuildTimeConfig"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "connectRetries",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.connect-retries",
      "description": "The maximum number of retries when attempting to connect to the database. After each failed attempt, Flyway will wait 1\nsecond before attempting to connect again, up to the maximum number of times specified by connectRetries.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "schemas",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.schemas",
      "description": "Comma-separated case-sensitive list of schemas managed by Flyway.\nThe first schema in the list will be automatically set as the default one during the migration.\nIt will also be the one containing the schema history table.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "table",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.table",
      "description": "The name of Flyway\u0027s schema history table.\nBy default (single-schema mode) the schema history table is placed in the default schema for the connection provided by\nthe datasource.\nWhen the flyway.schemas property is set (multi-schema mode), the schema history table is placed in the first schema of\nthe list.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "sqlMigrationPrefix",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.sql-migration-prefix",
      "description": "The file name prefix for versioned SQL migrations.\n\nVersioned SQL migrations have the following file name structure: prefixVERSIONseparatorDESCRIPTIONsuffix , which using\nthe defaults translates to V1.1__My_description.sql",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "repeatableSqlMigrationPrefix",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.repeatable-sql-migration-prefix",
      "description": "The file name prefix for repeatable SQL migrations.\n\nRepeatable SQL migrations have the following file name structure: prefixSeparatorDESCRIPTIONsuffix , which using the\ndefaults translates to R__My_description.sql",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "cleanAtStart",
      "defaultValue": "false",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.clean-at-start",
      "description": "true to execute Flyway clean command automatically when the application starts, false otherwise.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "migrateAtStart",
      "defaultValue": "false",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.migrate-at-start",
      "description": "true to execute Flyway automatically when the application starts, false otherwise.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "baselineOnMigrate",
      "defaultValue": "false",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.baseline-on-migrate",
      "description": "Enable the creation of the history table if it does not exist already.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "baselineVersion",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.baseline-version",
      "description": "The initial baseline version.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "baselineDescription",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.baseline-description",
      "description": "The description to tag an existing schema with when executing baseline.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "validateOnMigrate",
      "defaultValue": "false",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.validate-on-migrate",
      "description": "Whether to automatically call validate when performing a migration.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "outOfOrder",
      "defaultValue": "false",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.out-of-order",
      "description": "Allows migrations to be run \"out of order\".",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "placeholders",
      "extensionName": "quarkus-flyway",
      "required": true,
      "phase": 4,
      "name": "quarkus.flyway.placeholders.{*}",
      "description": "Sets the placeholders to replace in SQL migration scripts.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "connectRetries",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.{*}.connect-retries",
      "description": "The maximum number of retries when attempting to connect to the database. After each failed attempt, Flyway will wait 1\nsecond before attempting to connect again, up to the maximum number of times specified by connectRetries.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "schemas",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.{*}.schemas",
      "description": "Comma-separated case-sensitive list of schemas managed by Flyway.\nThe first schema in the list will be automatically set as the default one during the migration.\nIt will also be the one containing the schema history table.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "table",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.{*}.table",
      "description": "The name of Flyway\u0027s schema history table.\nBy default (single-schema mode) the schema history table is placed in the default schema for the connection provided by\nthe datasource.\nWhen the flyway.schemas property is set (multi-schema mode), the schema history table is placed in the first schema of\nthe list.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "sqlMigrationPrefix",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.{*}.sql-migration-prefix",
      "description": "The file name prefix for versioned SQL migrations.\n\nVersioned SQL migrations have the following file name structure: prefixVERSIONseparatorDESCRIPTIONsuffix , which using\nthe defaults translates to V1.1__My_description.sql",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "repeatableSqlMigrationPrefix",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.{*}.repeatable-sql-migration-prefix",
      "description": "The file name prefix for repeatable SQL migrations.\n\nRepeatable SQL migrations have the following file name structure: prefixSeparatorDESCRIPTIONsuffix , which using the\ndefaults translates to R__My_description.sql",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "cleanAtStart",
      "defaultValue": "false",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.{*}.clean-at-start",
      "description": "true to execute Flyway clean command automatically when the application starts, false otherwise.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "migrateAtStart",
      "defaultValue": "false",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.{*}.migrate-at-start",
      "description": "true to execute Flyway automatically when the application starts, false otherwise.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "baselineOnMigrate",
      "defaultValue": "false",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.{*}.baseline-on-migrate",
      "description": "Enable the creation of the history table if it does not exist already.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "baselineVersion",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.{*}.baseline-version",
      "description": "The initial baseline version.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "baselineDescription",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.{*}.baseline-description",
      "description": "The description to tag an existing schema with when executing baseline.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "validateOnMigrate",
      "defaultValue": "false",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.{*}.validate-on-migrate",
      "description": "Whether to automatically call validate when performing a migration.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "outOfOrder",
      "defaultValue": "false",
      "extensionName": "quarkus-flyway",
      "required": false,
      "phase": 4,
      "name": "quarkus.flyway.{*}.out-of-order",
      "description": "Allows migrations to be run \"out of order\".",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "placeholders",
      "extensionName": "quarkus-flyway",
      "required": true,
      "phase": 4,
      "name": "quarkus.flyway.{*}.placeholders.{*}",
      "description": "Sets the placeholders to replace in SQL migration scripts.",
      "sourceType": "io.quarkus.flyway.runtime.FlywayDataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "dbKind",
      "extensionName": "quarkus-datasource",
      "required": false,
      "phase": 2,
      "name": "quarkus.datasource.db-kind",
      "description": "The kind of database we will connect to (e.g. h2, postgresql...).",
      "sourceType": "io.quarkus.datasource.runtime.DataSourceBuildTimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "dbKind",
      "extensionName": "quarkus-datasource",
      "required": false,
      "phase": 2,
      "name": "quarkus.datasource.{*}.db-kind",
      "description": "The kind of database we will connect to (e.g. h2, postgresql...).",
      "sourceType": "io.quarkus.datasource.runtime.DataSourceBuildTimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "healthEnabled",
      "defaultValue": "true",
      "extensionName": "quarkus-datasource",
      "required": false,
      "phase": 2,
      "name": "quarkus.datasource.health.enabled",
      "description": "Whether or not an health check is published in case the smallrye-health extension is present.\n\u003cp\u003e\nThis is a global setting and is not specific to a datasource.",
      "sourceType": "io.quarkus.datasource.runtime.DataSourcesBuildTimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "metricsEnabled",
      "defaultValue": "false",
      "extensionName": "quarkus-datasource",
      "required": false,
      "phase": 2,
      "name": "quarkus.datasource.metrics.enabled",
      "description": "Whether or not datasource metrics are published in case the smallrye-metrics extension is present.\n\u003cp\u003e\nThis is a global setting and is not specific to a datasource.\n\u003cp\u003e\nNOTE: This is different from the \"jdbc.enable-metrics\" property that needs to be set on the JDBC datasource level to\nenable collection of metrics for that datasource.",
      "sourceType": "io.quarkus.datasource.runtime.DataSourcesBuildTimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "username",
      "extensionName": "quarkus-datasource",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.username",
      "description": "The datasource username",
      "sourceType": "io.quarkus.datasource.runtime.DataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "password",
      "extensionName": "quarkus-datasource",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.password",
      "description": "The datasource password",
      "sourceType": "io.quarkus.datasource.runtime.DataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "credentialsProvider",
      "extensionName": "quarkus-datasource",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.credentials-provider",
      "description": "The credentials provider name",
      "sourceType": "io.quarkus.datasource.runtime.DataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "credentialsProviderType",
      "extensionName": "quarkus-datasource",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.credentials-provider-type",
      "description": "The credentials provider type.\n\u003cp\u003e\nIt is the {@code \u0026#64;Named} value of the credentials provider bean. It is used to discriminate if multiple\nCredentialsProvider beans are available.\n\u003cp\u003e\nFor Vault it is: vault-credentials-provider. Not necessary if there is only one credentials provider available.",
      "sourceType": "io.quarkus.datasource.runtime.DataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "username",
      "extensionName": "quarkus-datasource",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.username",
      "description": "The datasource username",
      "sourceType": "io.quarkus.datasource.runtime.DataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "password",
      "extensionName": "quarkus-datasource",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.password",
      "description": "The datasource password",
      "sourceType": "io.quarkus.datasource.runtime.DataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "credentialsProvider",
      "extensionName": "quarkus-datasource",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.credentials-provider",
      "description": "The credentials provider name",
      "sourceType": "io.quarkus.datasource.runtime.DataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "credentialsProviderType",
      "extensionName": "quarkus-datasource",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.credentials-provider-type",
      "description": "The credentials provider type.\n\u003cp\u003e\nIt is the {@code \u0026#64;Named} value of the credentials provider bean. It is used to discriminate if multiple\nCredentialsProvider beans are available.\n\u003cp\u003e\nFor Vault it is: vault-credentials-provider. Not necessary if there is only one credentials provider available.",
      "sourceType": "io.quarkus.datasource.runtime.DataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "url",
      "extensionName": "quarkus-datasource",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.url",
      "description": "@deprecated use either quarkus.datasource.jdbc.url or quarkus.datasource.reactive.url.",
      "sourceType": "io.quarkus.datasource.runtime.LegacyDataSourceRuntimeConfig"
    },
    {
      "type": "int",
      "sourceField": "maxSize",
      "defaultValue": "20",
      "extensionName": "quarkus-datasource",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.max-size",
      "description": "@deprecated use either quarkus.datasource.jdbc.max-size or quarkus.datasource.reactive.max-size.",
      "sourceType": "io.quarkus.datasource.runtime.LegacyDataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "url",
      "extensionName": "quarkus-datasource",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.url",
      "description": "@deprecated use either quarkus.datasource.jdbc.url or quarkus.datasource.reactive.url.",
      "sourceType": "io.quarkus.datasource.runtime.LegacyDataSourceRuntimeConfig"
    },
    {
      "type": "int",
      "sourceField": "maxSize",
      "defaultValue": "20",
      "extensionName": "quarkus-datasource",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.{*}.max-size",
      "description": "@deprecated use either quarkus.datasource.jdbc.max-size or quarkus.datasource.reactive.max-size.",
      "sourceType": "io.quarkus.datasource.runtime.LegacyDataSourceRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "dialect",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.dialect",
      "description": "Class name of the Hibernate ORM dialect. The complete list of bundled dialects is available in the\nhttps://docs.jboss.org/hibernate/stable/orm/javadocs/org/hibernate/dialect/package-summary.html[Hibernate ORM JavaDoc].\n\n[NOTE]\n\u003d\u003d\u003d\u003d\nNot all the dialects are supported in GraalVM native executables: we currently provide driver extensions for PostgreSQL,\nMariaDB, Microsoft SQL Server and H2.\n\u003d\u003d\u003d\u003d\n\n@asciidoclet",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "dialectStorageEngine",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.dialect.storage-engine",
      "description": "The storage engine to use when the dialect supports multiple storage engines.\n\nE.g. `MyISAM` or `InnoDB` for MySQL.\n\n@asciidoclet",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "sqlLoadScript",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.sql-load-script",
      "description": "Name of the file containing the SQL statements to execute when Hibernate ORM starts.\nIts default value differs depending on the Quarkus launch mode:\n\n* In dev and test modes, it defaults to `import.sql`.\n  Simply add an `import.sql` file in the root of your resources directory\n  and it will be picked up without having to set this property.\n  Pass `no-file` to force Hibernate ORM to ignore the SQL import file.\n* In production mode, it defaults to `no-file`.\n  It means Hibernate ORM won\u0027t try to execute any SQL import file by default.\n  Pass an explicit value to force Hibernate ORM to execute the SQL import file.\n\nIf you need different SQL statements between dev mode, test (`@QuarkusTest`) and in production, use Quarkus\nhttps://quarkus.io/guides/config#configuration-profiles[configuration profiles facility].\n\n[source,property]\n.application.properties\n----\n%dev.quarkus.hibernate-orm.sql-load-script \u003d import-dev.sql\n%test.quarkus.hibernate-orm.sql-load-script \u003d import-test.sql\n%prod.quarkus.hibernate-orm.sql-load-script \u003d no-file\n----\n\n[NOTE]\n\u003d\u003d\u003d\u003d\nQuarkus supports `.sql` file with SQL statements or comments spread over multiple lines.\nEach SQL statement must be terminated by a semicolon.\n\u003d\u003d\u003d\u003d\n\n@asciidoclet",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig"
    },
    {
      "type": "int",
      "sourceField": "batchFetchSize",
      "defaultValue": "-1",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.batch-fetch-size",
      "description": "The size of the batches used when loading entities and collections.\n\n`-1` means batch loading is disabled. This is the default.\n\n@asciidoclet",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "physicalNamingStrategy",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.physical-naming-strategy",
      "description": "Pluggable strategy contract for applying physical naming rules for database object names.\n\nClass name of the Hibernate PhysicalNamingStrategy implementation",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "implicitNamingStrategy",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.implicit-naming-strategy",
      "description": "Pluggable strategy for applying implicit naming rules when an explicit name is not given.\n\nClass name of the Hibernate ImplicitNamingStrategy implementation",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "queryPlanCacheMaxSize",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.query.query-plan-cache-max-size",
      "description": "The maximum size of the query plan cache.",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig.HibernateOrmConfigQuery"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "defaultNullOrdering",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.query.default-null-ordering",
      "description": "Default precedence of null values in `ORDER BY` clauses.\n\nValid values are: `none`, `first`, `last`.\n\n@asciidoclet",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig.HibernateOrmConfigQuery"
    },
    {
      "type": "java.lang.String",
      "sourceField": "generation",
      "defaultValue": "none",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.database.generation",
      "description": "Select whether the database schema is generated or not.\n\n`drop-and-create` is awesome in development mode.\n\nAccepted values: `none`, `create`, `drop-and-create`, `drop`, `update`.",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig.HibernateOrmConfigDatabase"
    },
    {
      "type": "boolean",
      "sourceField": "generationHaltOnError",
      "defaultValue": "false",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.database.generation.halt-on-error",
      "description": "Whether we should stop on the first error when applying the schema.",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig.HibernateOrmConfigDatabase"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "defaultCatalog",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.database.default-catalog",
      "description": "The default catalog to use for the database objects.",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig.HibernateOrmConfigDatabase"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "defaultSchema",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.database.default-schema",
      "description": "The default schema to use for the database objects.",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig.HibernateOrmConfigDatabase"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "charset",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.database.charset",
      "description": "The charset of the database.",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig.HibernateOrmConfigDatabase"
    },
    {
      "type": "boolean",
      "sourceField": "globallyQuotedIdentifiers",
      "defaultValue": "false",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.database.globally-quoted-identifiers",
      "description": "Whether Hibernate should quote all identifiers.",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig.HibernateOrmConfigDatabase"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "timezone",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.jdbc.timezone",
      "description": "The time zone pushed to the JDBC driver.",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig.HibernateOrmConfigJdbc"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "statementFetchSize",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.jdbc.statement-fetch-size",
      "description": "How many rows are fetched at a time by the JDBC driver.",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig.HibernateOrmConfigJdbc"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "statementBatchSize",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.jdbc.statement-batch-size",
      "description": "The number of updates (inserts, updates and deletes) that are sent by the JDBC driver at one time for execution.",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig.HibernateOrmConfigJdbc"
    },
    {
      "type": "boolean",
      "sourceField": "sql",
      "defaultValue": "false",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.log.sql",
      "description": "Show SQL logs and format them nicely.\n\u003cp\u003e\nSetting it to true is obviously not recommended in production.",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig.HibernateOrmConfigLog"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Boolean\u003e",
      "sourceField": "jdbcWarnings",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.log.jdbc-warnings",
      "description": "Whether JDBC warnings should be collected and logged.",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig.HibernateOrmConfigLog"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "maxIdle",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.cache.{*}.expiration.max-idle",
      "description": "The maximum time before an object of the cache is considered expired.",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig.HibernateOrmConfigCacheExpiration"
    },
    {
      "type": "java.util.OptionalLong",
      "sourceField": "objectCount",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.cache.{*}.memory.object-count",
      "description": "The maximum number of objects kept in memory in the cache.",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig.HibernateOrmConfigCacheMemory"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Boolean\u003e",
      "sourceField": "statistics",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.statistics",
      "description": "Whether statistics collection is enabled. If \u0027metrics.enabled\u0027 is true, then the default here is\nconsidered true, otherwise the default is false.",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig"
    },
    {
      "type": "boolean",
      "sourceField": "metricsEnabled",
      "defaultValue": "false",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.metrics.enabled",
      "description": "Whether or not metrics are published in case the smallrye-metrics extension is present (default to false).",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig"
    },
    {
      "type": "boolean",
      "sourceField": "secondLevelCachingEnabled",
      "defaultValue": "true",
      "extensionName": "quarkus-hibernate-orm",
      "required": false,
      "phase": 1,
      "name": "quarkus.hibernate-orm.second-level-caching-enabled",
      "description": "The default in Quarkus is for 2nd level caching to be enabled,\nand a good implementation is already integrated for you.\n\u003cp\u003e\nJust cherry-pick which entities should be using the cache.\n\u003cp\u003e\nSet this to false to disable all 2nd level caches.",
      "sourceType": "io.quarkus.hibernate.orm.deployment.HibernateOrmConfig"
    },
    {
      "type": "java.util.Optional\u003corg.hibernate.search.backend.elasticsearch.ElasticsearchVersion\u003e",
      "sourceField": "version",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 2,
      "name": "quarkus.hibernate-search.elasticsearch.version",
      "description": "The version of Elasticsearch used in the cluster.\n\u003cp\u003e\nAs the schema is generated without a connection to the server, this item is mandatory.\n\u003cp\u003e\nIt doesn\u0027t have to be the exact version (it can be 7 or 7.1 for instance) but it has to be sufficiently precise to\nchoose a model dialect (the one used to generate the schema) compatible with the protocol dialect (the one used to\ncommunicate with Elasticsearch).\n\u003cp\u003e\nThere\u0027s no rule of thumb here as it depends on the schema incompatibilities introduced by Elasticsearch versions. In\nany case, if there is a problem, you will have an error when Hibernate Search tries to connect to the cluster.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchBuildTimeConfig.ElasticsearchBackendBuildTimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Class\u003c?\u003e\u003e",
      "sourceField": "configurer",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 2,
      "name": "quarkus.hibernate-search.elasticsearch.analysis.configurer",
      "description": "The class or the name of the bean used to configure full text analysis (e.g. analyzers, normalizers).",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchBuildTimeConfig.AnalysisConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "defaultBackend",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 2,
      "name": "quarkus.hibernate-search.elasticsearch.default-backend",
      "description": "Only useful when defining {@link #backends additional backends}:\nthe name of the default backend,\ni.e. the backend that will be assigned to {@code @Indexed} entities\nthat do not specify a backend explicitly through {@code @Indexed(backend \u003d ...)}.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchBuildTimeConfig.ElasticsearchAdditionalBackendsBuildTimeConfig"
    },
    {
      "type": "java.util.Optional\u003corg.hibernate.search.backend.elasticsearch.ElasticsearchVersion\u003e",
      "sourceField": "version",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 2,
      "name": "quarkus.hibernate-search.elasticsearch.backends.{*}.version",
      "description": "The version of Elasticsearch used in the cluster.\n\u003cp\u003e\nAs the schema is generated without a connection to the server, this item is mandatory.\n\u003cp\u003e\nIt doesn\u0027t have to be the exact version (it can be 7 or 7.1 for instance) but it has to be sufficiently precise to\nchoose a model dialect (the one used to generate the schema) compatible with the protocol dialect (the one used to\ncommunicate with Elasticsearch).\n\u003cp\u003e\nThere\u0027s no rule of thumb here as it depends on the schema incompatibilities introduced by Elasticsearch versions. In\nany case, if there is a problem, you will have an error when Hibernate Search tries to connect to the cluster.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchBuildTimeConfig.ElasticsearchBackendBuildTimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Class\u003c?\u003e\u003e",
      "sourceField": "configurer",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 2,
      "name": "quarkus.hibernate-search.elasticsearch.backends.{*}.analysis.configurer",
      "description": "The class or the name of the bean used to configure full text analysis (e.g. analyzers, normalizers).",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchBuildTimeConfig.AnalysisConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Class\u003c?\u003e\u003e",
      "sourceField": "backgroundFailureHandler",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 2,
      "name": "quarkus.hibernate-search.background-failure-handler",
      "description": "The class or the name of the bean that should be notified of any failure occurring in a background process\n(mainly index operations).\n\u003cp\u003e\nMust implement {@link org.hibernate.search.engine.reporting.FailureHandler}.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchBuildTimeConfig"
    },
    {
      "type": "java.util.List\u003cjava.lang.String\u003e",
      "sourceField": "hosts",
      "defaultValue": "localhost:9200",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.elasticsearch.hosts",
      "description": "The list of hosts of the Elasticsearch servers.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.ElasticsearchBackendRuntimeConfig"
    },
    {
      "type": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.ElasticsearchClientProtocol",
      "sourceField": "protocol",
      "defaultValue": "http",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.hibernate-search.elasticsearch.protocol",
      "description": "The protocol to use when contacting Elasticsearch servers.\nSet to \"https\" to enable SSL/TLS.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.ElasticsearchBackendRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "username",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.elasticsearch.username",
      "description": "The username used for authentication.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.ElasticsearchBackendRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "password",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.elasticsearch.password",
      "description": "The password used for authentication.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.ElasticsearchBackendRuntimeConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "connectionTimeout",
      "defaultValue": "3S",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.elasticsearch.connection-timeout",
      "description": "The connection timeout.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.ElasticsearchBackendRuntimeConfig"
    },
    {
      "type": "int",
      "sourceField": "maxConnections",
      "defaultValue": "20",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.elasticsearch.max-connections",
      "description": "The maximum number of connections to all the Elasticsearch servers.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.ElasticsearchBackendRuntimeConfig"
    },
    {
      "type": "int",
      "sourceField": "maxConnectionsPerRoute",
      "defaultValue": "10",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.elasticsearch.max-connections-per-route",
      "description": "The maximum number of connections per Elasticsearch server.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.ElasticsearchBackendRuntimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enabled",
      "defaultValue": "false",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.elasticsearch.discovery.enabled",
      "description": "Defines if automatic discovery is enabled.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.DiscoveryConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "refreshInterval",
      "defaultValue": "10S",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.elasticsearch.discovery.refresh-interval",
      "description": "Refresh interval of the node list.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.DiscoveryConfig"
    },
    {
      "type": "java.util.Optional\u003corg.hibernate.search.backend.elasticsearch.index.IndexLifecycleStrategyName\u003e",
      "sourceField": "strategy",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.hibernate-search.elasticsearch.index-defaults.lifecycle.strategy",
      "description": "The strategy used for index lifecycle.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.LifecycleConfig"
    },
    {
      "type": "java.util.Optional\u003corg.hibernate.search.backend.elasticsearch.index.IndexStatus\u003e",
      "sourceField": "requiredStatus",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.hibernate-search.elasticsearch.index-defaults.lifecycle.required-status",
      "description": "The minimal cluster status required.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.LifecycleConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "requiredStatusWaitTimeout",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.elasticsearch.index-defaults.lifecycle.required-status-wait-timeout",
      "description": "How long we should wait for the status before failing the bootstrap.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.LifecycleConfig"
    },
    {
      "type": "java.util.Optional\u003corg.hibernate.search.backend.elasticsearch.index.IndexLifecycleStrategyName\u003e",
      "sourceField": "strategy",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.hibernate-search.elasticsearch.indexes.{*}.lifecycle.strategy",
      "description": "The strategy used for index lifecycle.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.LifecycleConfig"
    },
    {
      "type": "java.util.Optional\u003corg.hibernate.search.backend.elasticsearch.index.IndexStatus\u003e",
      "sourceField": "requiredStatus",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.hibernate-search.elasticsearch.indexes.{*}.lifecycle.required-status",
      "description": "The minimal cluster status required.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.LifecycleConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "requiredStatusWaitTimeout",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.elasticsearch.indexes.{*}.lifecycle.required-status-wait-timeout",
      "description": "How long we should wait for the status before failing the bootstrap.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.LifecycleConfig"
    },
    {
      "type": "java.util.List\u003cjava.lang.String\u003e",
      "sourceField": "hosts",
      "defaultValue": "localhost:9200",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.elasticsearch.backends.{*}.hosts",
      "description": "The list of hosts of the Elasticsearch servers.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.ElasticsearchBackendRuntimeConfig"
    },
    {
      "type": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.ElasticsearchClientProtocol",
      "sourceField": "protocol",
      "defaultValue": "http",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.hibernate-search.elasticsearch.backends.{*}.protocol",
      "description": "The protocol to use when contacting Elasticsearch servers.\nSet to \"https\" to enable SSL/TLS.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.ElasticsearchBackendRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "username",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.elasticsearch.backends.{*}.username",
      "description": "The username used for authentication.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.ElasticsearchBackendRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "password",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.elasticsearch.backends.{*}.password",
      "description": "The password used for authentication.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.ElasticsearchBackendRuntimeConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "connectionTimeout",
      "defaultValue": "3S",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.elasticsearch.backends.{*}.connection-timeout",
      "description": "The connection timeout.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.ElasticsearchBackendRuntimeConfig"
    },
    {
      "type": "int",
      "sourceField": "maxConnections",
      "defaultValue": "20",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.elasticsearch.backends.{*}.max-connections",
      "description": "The maximum number of connections to all the Elasticsearch servers.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.ElasticsearchBackendRuntimeConfig"
    },
    {
      "type": "int",
      "sourceField": "maxConnectionsPerRoute",
      "defaultValue": "10",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.elasticsearch.backends.{*}.max-connections-per-route",
      "description": "The maximum number of connections per Elasticsearch server.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.ElasticsearchBackendRuntimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enabled",
      "defaultValue": "false",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.elasticsearch.backends.{*}.discovery.enabled",
      "description": "Defines if automatic discovery is enabled.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.DiscoveryConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "refreshInterval",
      "defaultValue": "10S",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.elasticsearch.backends.{*}.discovery.refresh-interval",
      "description": "Refresh interval of the node list.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.DiscoveryConfig"
    },
    {
      "type": "java.util.Optional\u003corg.hibernate.search.backend.elasticsearch.index.IndexLifecycleStrategyName\u003e",
      "sourceField": "strategy",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.hibernate-search.elasticsearch.backends.{*}.index-defaults.lifecycle.strategy",
      "description": "The strategy used for index lifecycle.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.LifecycleConfig"
    },
    {
      "type": "java.util.Optional\u003corg.hibernate.search.backend.elasticsearch.index.IndexStatus\u003e",
      "sourceField": "requiredStatus",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.hibernate-search.elasticsearch.backends.{*}.index-defaults.lifecycle.required-status",
      "description": "The minimal cluster status required.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.LifecycleConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "requiredStatusWaitTimeout",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.elasticsearch.backends.{*}.index-defaults.lifecycle.required-status-wait-timeout",
      "description": "How long we should wait for the status before failing the bootstrap.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.LifecycleConfig"
    },
    {
      "type": "java.util.Optional\u003corg.hibernate.search.backend.elasticsearch.index.IndexLifecycleStrategyName\u003e",
      "sourceField": "strategy",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.hibernate-search.elasticsearch.backends.{*}.indexes.{*}.lifecycle.strategy",
      "description": "The strategy used for index lifecycle.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.LifecycleConfig"
    },
    {
      "type": "java.util.Optional\u003corg.hibernate.search.backend.elasticsearch.index.IndexStatus\u003e",
      "sourceField": "requiredStatus",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.hibernate-search.elasticsearch.backends.{*}.indexes.{*}.lifecycle.required-status",
      "description": "The minimal cluster status required.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.LifecycleConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "requiredStatusWaitTimeout",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.elasticsearch.backends.{*}.indexes.{*}.lifecycle.required-status-wait-timeout",
      "description": "How long we should wait for the status before failing the bootstrap.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.LifecycleConfig"
    },
    {
      "type": "org.hibernate.search.mapper.orm.search.loading.EntityLoadingCacheLookupStrategy",
      "sourceField": "strategy",
      "defaultValue": "skip",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.hibernate-search.query.loading.cache-lookup.strategy",
      "description": "The strategy to use when loading entities during the execution of a search query.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.SearchQueryLoadingCacheLookupConfig"
    },
    {
      "type": "int",
      "sourceField": "fetchSize",
      "defaultValue": "100",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.query.loading.fetch-size",
      "description": "The fetch size to use when loading entities during the execution of a search query.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.SearchQueryLoadingConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "strategy",
      "defaultValue": "write-sync",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.automatic-indexing.synchronization.strategy",
      "description": "The synchronization strategy to use when indexing automatically.\n\u003cp\u003e\nDefines how complete indexing should be before resuming the application thread\nafter a database transaction is committed.\n\u003cp\u003e\nAvailable values:\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth rowspan\u003d\"2\"\u003e\n\u003cp\u003e\nStrategy\n\u003c/p\u003e\n\u003c/th\u003e\n\u003cth colspan\u003d\"3\"\u003e\n\u003cp\u003e\nGuarantees when the application thread resumes\n\u003c/p\u003e\n\u003c/th\u003e\n\u003cth rowspan\u003d\"2\"\u003e\n\u003cp\u003e\nThroughput\n\u003c/p\u003e\n\u003c/th\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003cth\u003e\n\u003cp\u003e\nChanges applied\n\u003c/p\u003e\n\u003c/th\u003e\n\u003cth\u003e\n\u003cp\u003e\nChanges safe from crash/power loss\n\u003c/p\u003e\n\u003c/th\u003e\n\u003cth\u003e\n\u003cp\u003e\nChanges visible on search\n\u003c/p\u003e\n\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\n\u003cp\u003e\n\u003ccode\u003e{@value AutomaticIndexingSynchronizationStrategyNames#ASYNC}\u003c/code\u003e\n\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e\nNo guarantee\n\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e\nNo guarantee\n\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e\nNo guarantee\n\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e\nBest\n\u003c/p\u003e\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\n\u003cp\u003e\n\u003ccode\u003e{@value AutomaticIndexingSynchronizationStrategyNames#WRITE_SYNC}\u003c/code\u003e (\u003cstrong\u003edefault\u003c/strong\u003e)\n\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e\nGuaranteed\n\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e\nGuaranteed\n\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e\nNo guarantee\n\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e\nMedium\n\u003c/p\u003e\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\n\u003cp\u003e\n\u003ccode\u003e{@value AutomaticIndexingSynchronizationStrategyNames#READ_SYNC}\u003c/code\u003e\n\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e\nGuaranteed\n\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e\nNo guarantee\n\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e\nGuaranteed\n\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e\nMedium to worst\n\u003c/p\u003e\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\n\u003cp\u003e\n\u003ccode\u003e{@value AutomaticIndexingSynchronizationStrategyNames#SYNC}\u003c/code\u003e\n\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e\nGuaranteed\n\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e\nGuaranteed\n\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e\nGuaranteed\n\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e\nWorst\n\u003c/p\u003e\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\nSee\n\u003ca href\u003d\n\"https://docs.jboss.org/hibernate/search/6.0/reference/en-US/html_single/#mapper-orm-indexing-automatic-synchronization\"\u003ethis\nsection of the reference documentation\u003c/a\u003e\nfor more information.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.AutomaticIndexingSynchronizationConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enableDirtyCheck",
      "defaultValue": "true",
      "extensionName": "quarkus-hibernate-search-elasticsearch",
      "required": false,
      "phase": 4,
      "name": "quarkus.hibernate-search.automatic-indexing.enable-dirty-check",
      "description": "Whether to check if dirty properties are relevant to indexing before actually reindexing an entity.\n\u003cp\u003e\nWhen enabled, re-indexing of an entity is skipped if the only changes are on properties that are not used when\nindexing.",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.AutomaticIndexingConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enabled",
      "defaultValue": "true",
      "extensionName": "quarkus-jaeger",
      "required": false,
      "phase": 1,
      "name": "quarkus.jaeger.enabled",
      "description": "Defines if the Jaeger extension is enabled.",
      "sourceType": "io.quarkus.jaeger.runtime.JaegerBuildTimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.net.URI\u003e",
      "sourceField": "endpoint",
      "extensionName": "quarkus-jaeger",
      "required": false,
      "phase": 4,
      "name": "quarkus.jaeger.endpoint",
      "description": "The traces endpoint, in case the client should connect directly to the Collector,\nlike http://jaeger-collector:14268/api/traces",
      "sourceType": "io.quarkus.jaeger.runtime.JaegerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "authToken",
      "extensionName": "quarkus-jaeger",
      "required": false,
      "phase": 4,
      "name": "quarkus.jaeger.auth-token",
      "description": "Authentication Token to send as \"Bearer\" to the endpoint",
      "sourceType": "io.quarkus.jaeger.runtime.JaegerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "user",
      "extensionName": "quarkus-jaeger",
      "required": false,
      "phase": 4,
      "name": "quarkus.jaeger.user",
      "description": "Username to send as part of \"Basic\" authentication to the endpoint",
      "sourceType": "io.quarkus.jaeger.runtime.JaegerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "password",
      "extensionName": "quarkus-jaeger",
      "required": false,
      "phase": 4,
      "name": "quarkus.jaeger.password",
      "description": "Password to send as part of \"Basic\" authentication to the endpoint",
      "sourceType": "io.quarkus.jaeger.runtime.JaegerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.net.InetSocketAddress\u003e",
      "sourceField": "agentHostPort",
      "extensionName": "quarkus-jaeger",
      "required": false,
      "phase": 4,
      "name": "quarkus.jaeger.agent-host-port",
      "description": "The hostname and port for communicating with agent via UDP",
      "sourceType": "io.quarkus.jaeger.runtime.JaegerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Boolean\u003e",
      "sourceField": "reporterLogSpans",
      "extensionName": "quarkus-jaeger",
      "required": false,
      "phase": 4,
      "name": "quarkus.jaeger.reporter-log-spans",
      "description": "Whether the reporter should also log the spans",
      "sourceType": "io.quarkus.jaeger.runtime.JaegerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "reporterMaxQueueSize",
      "extensionName": "quarkus-jaeger",
      "required": false,
      "phase": 4,
      "name": "quarkus.jaeger.reporter-max-queue-size",
      "description": "The reporter\u0027s maximum queue size",
      "sourceType": "io.quarkus.jaeger.runtime.JaegerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "reporterFlushInterval",
      "extensionName": "quarkus-jaeger",
      "required": false,
      "phase": 4,
      "name": "quarkus.jaeger.reporter-flush-interval",
      "description": "The reporter\u0027s flush interval",
      "sourceType": "io.quarkus.jaeger.runtime.JaegerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "samplerType",
      "extensionName": "quarkus-jaeger",
      "required": false,
      "phase": 4,
      "name": "quarkus.jaeger.sampler-type",
      "description": "The sampler type (const, probabilistic, ratelimiting or remote)",
      "sourceType": "io.quarkus.jaeger.runtime.JaegerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.math.BigDecimal\u003e",
      "sourceField": "samplerParam",
      "extensionName": "quarkus-jaeger",
      "required": false,
      "phase": 4,
      "name": "quarkus.jaeger.sampler-param",
      "description": "The sampler parameter (number)",
      "sourceType": "io.quarkus.jaeger.runtime.JaegerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.net.InetSocketAddress\u003e",
      "sourceField": "samplerManagerHostPort",
      "extensionName": "quarkus-jaeger",
      "required": false,
      "phase": 4,
      "name": "quarkus.jaeger.sampler-manager-host-port",
      "description": "The host name and port when using the remote controlled sampler",
      "sourceType": "io.quarkus.jaeger.runtime.JaegerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "serviceName",
      "extensionName": "quarkus-jaeger",
      "required": false,
      "phase": 4,
      "name": "quarkus.jaeger.service-name",
      "description": "The service name",
      "sourceType": "io.quarkus.jaeger.runtime.JaegerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "tags",
      "extensionName": "quarkus-jaeger",
      "required": false,
      "phase": 4,
      "name": "quarkus.jaeger.tags",
      "description": "A comma separated list of name \u003d value tracer level tags, which get added to all reported\nspans. The value can also refer to an environment variable using the format ${envVarName:default},\nwhere the :default is optional, and identifies a value to be used if the environment variable\ncannot be found",
      "sourceType": "io.quarkus.jaeger.runtime.JaegerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "propagation",
      "extensionName": "quarkus-jaeger",
      "required": false,
      "phase": 4,
      "name": "quarkus.jaeger.propagation",
      "description": "Comma separated list of formats to use for propagating the trace context. Defaults to the\nstandard Jaeger format. Valid values are jaeger and b3",
      "sourceType": "io.quarkus.jaeger.runtime.JaegerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "senderFactory",
      "extensionName": "quarkus-jaeger",
      "required": false,
      "phase": 4,
      "name": "quarkus.jaeger.sender-factory",
      "description": "The sender factory class name",
      "sourceType": "io.quarkus.jaeger.runtime.JaegerConfig"
    },
    {
      "type": "java.lang.Boolean",
      "sourceField": "logTraceContext",
      "defaultValue": "true",
      "extensionName": "quarkus-jaeger",
      "required": false,
      "phase": 4,
      "name": "quarkus.jaeger.log-trace-context",
      "description": "Whether the trace context should be logged.",
      "sourceType": "io.quarkus.jaeger.runtime.JaegerConfig"
    },
    {
      "type": "int",
      "sourceField": "nearCacheMaxEntries",
      "defaultValue": "0",
      "extensionName": "quarkus-infinispan-client",
      "required": false,
      "phase": 2,
      "name": "quarkus.infinispan-client.near-cache-max-entries",
      "description": "Sets the bounded entry count for near cache. If this value is 0 or less near cache is disabled.",
      "sourceType": "io.quarkus.infinispan.client.runtime.InfinispanClientBuildTimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "serverList",
      "extensionName": "quarkus-infinispan-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.infinispan-client.server-list",
      "description": "Sets the host name/port to connect to. Each one is separated by a semicolon (eg. host1:11222;host2:11222).",
      "sourceType": "io.quarkus.infinispan.client.runtime.InfinispanClientRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "clientIntelligence",
      "extensionName": "quarkus-infinispan-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.infinispan-client.client-intelligence",
      "description": "Sets client intelligence used by authentication",
      "sourceType": "io.quarkus.infinispan.client.runtime.InfinispanClientRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "useAuth",
      "extensionName": "quarkus-infinispan-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.infinispan-client.use-auth",
      "description": "Enables or disables authentication",
      "sourceType": "io.quarkus.infinispan.client.runtime.InfinispanClientRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "authUsername",
      "extensionName": "quarkus-infinispan-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.infinispan-client.auth-username",
      "description": "Sets user name used by authentication",
      "sourceType": "io.quarkus.infinispan.client.runtime.InfinispanClientRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "authPassword",
      "extensionName": "quarkus-infinispan-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.infinispan-client.auth-password",
      "description": "Sets password used by authentication",
      "sourceType": "io.quarkus.infinispan.client.runtime.InfinispanClientRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "authRealm",
      "extensionName": "quarkus-infinispan-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.infinispan-client.auth-realm",
      "description": "Sets realm used by authentication",
      "sourceType": "io.quarkus.infinispan.client.runtime.InfinispanClientRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "authServerName",
      "extensionName": "quarkus-infinispan-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.infinispan-client.auth-server-name",
      "description": "Sets server name used by authentication",
      "sourceType": "io.quarkus.infinispan.client.runtime.InfinispanClientRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "authClientSubject",
      "extensionName": "quarkus-infinispan-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.infinispan-client.auth-client-subject",
      "description": "Sets client subject used by authentication",
      "sourceType": "io.quarkus.infinispan.client.runtime.InfinispanClientRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "authCallbackHandler",
      "extensionName": "quarkus-infinispan-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.infinispan-client.auth-callback-handler",
      "description": "Sets callback handler used by authentication",
      "sourceType": "io.quarkus.infinispan.client.runtime.InfinispanClientRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "saslMechanism",
      "extensionName": "quarkus-infinispan-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.infinispan-client.sasl-mechanism",
      "description": "Sets SASL mechanism used by authentication",
      "sourceType": "io.quarkus.infinispan.client.runtime.InfinispanClientRuntimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "healthEnabled",
      "defaultValue": "false",
      "extensionName": "quarkus-kafka-client",
      "required": false,
      "phase": 1,
      "name": "quarkus.kafka.health.enabled",
      "description": "Whether or not an health check is published in case the smallrye-health extension is present.\n\u003cp\u003e\nIf you enable the health check, you must specify the `kafka.bootstrap.servers` property.",
      "sourceType": "io.quarkus.kafka.client.deployment.KafkaBuildTimeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "bootstrapServers",
      "defaultValue": "localhost:9092",
      "required": false,
      "phase": 0,
      "name": "kafka.bootstrap.servers",
      "sourceType": "io.quarkus.kafka.client.health.KafkaHealthCheck"
    },
    {
      "type": "boolean",
      "sourceField": "healthEnabled",
      "defaultValue": "true",
      "extensionName": "quarkus-kafka-streams",
      "required": false,
      "phase": 1,
      "name": "quarkus.kafka-streams.health.enabled",
      "description": "Whether or not a health check is published in case the smallrye-health extension is present (defaults to true).",
      "sourceType": "io.quarkus.kafka.streams.deployment.KafkaStreamsBuildTimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "trustCerts",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.trust-certs",
      "description": "Whether or not the client should trust a self signed certificate if so presented by the API server",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "masterUrl",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.master-url",
      "description": "URL of the Kubernetes API server",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "namespace",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.namespace",
      "description": "Default namespace to use",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "caCertFile",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.ca-cert-file",
      "description": "CA certificate file",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "caCertData",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.ca-cert-data",
      "description": "CA certificate data",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "clientCertFile",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.client-cert-file",
      "description": "Client certificate file",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "clientCertData",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.client-cert-data",
      "description": "Client certificate data",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "clientKeyFile",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.client-key-file",
      "description": "Client key file",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "clientKeyData",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.client-key-data",
      "description": "Client key data",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "clientKeyAlgo",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.client-key-algo",
      "description": "Client key algorithm",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "clientKeyPassphrase",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.client-key-passphrase",
      "description": "Client key passphrase",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "username",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.username",
      "description": "Kubernetes auth username",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "password",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.password",
      "description": "Kubernetes auth password",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "watchReconnectInterval",
      "defaultValue": "PT1S",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.watch-reconnect-interval",
      "description": "Watch reconnect interval",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "int",
      "sourceField": "watchReconnectLimit",
      "defaultValue": "-1",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.watch-reconnect-limit",
      "description": "Maximum reconnect attempts in case of watch failure\nBy default there is no limit to the number of reconnect attempts",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "connectionTimeout",
      "defaultValue": "PT10S",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.connection-timeout",
      "description": "Maximum amount of time to wait for a connection with the API server to be established",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "requestTimeout",
      "defaultValue": "PT10S",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.request-timeout",
      "description": "Maximum amount of time to wait for a request to the API server to be completed",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "rollingTimeout",
      "defaultValue": "PT15M",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.rolling-timeout",
      "description": "Maximum amount of time in milliseconds to wait for a rollout to be completed",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "httpProxy",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.http-proxy",
      "description": "HTTP proxy used to access the Kubernetes API server",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "httpsProxy",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.https-proxy",
      "description": "HTTPS proxy used to access the Kubernetes API server",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "proxyUsername",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.proxy-username",
      "description": "Proxy username",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "proxyPassword",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.proxy-password",
      "description": "Proxy password",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String[]\u003e",
      "sourceField": "noProxy",
      "extensionName": "quarkus-kubernetes-client-internal",
      "required": false,
      "phase": 2,
      "name": "quarkus.kubernetes-client.no-proxy",
      "description": "IP addresses or hosts to exclude from proxying",
      "sourceType": "io.quarkus.kubernetes.client.runtime.KubernetesClientBuildConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "applicationId",
      "extensionName": "quarkus-kafka-streams",
      "required": true,
      "phase": 4,
      "name": "quarkus.kafka-streams.application-id",
      "description": "A unique identifier for this Kafka Streams application.",
      "sourceType": "io.quarkus.kafka.streams.runtime.KafkaStreamsRuntimeConfig"
    },
    {
      "type": "java.util.List\u003cjava.net.InetSocketAddress\u003e",
      "sourceField": "bootstrapServers",
      "defaultValue": "localhost:9012",
      "extensionName": "quarkus-kafka-streams",
      "required": false,
      "phase": 4,
      "name": "quarkus.kafka-streams.bootstrap-servers",
      "description": "A comma-separated list of host:port pairs identifying the Kafka bootstrap server(s)",
      "sourceType": "io.quarkus.kafka.streams.runtime.KafkaStreamsRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "applicationServer",
      "extensionName": "quarkus-kafka-streams",
      "required": false,
      "phase": 4,
      "name": "quarkus.kafka-streams.application-server",
      "description": "A unique identifier of this application instance, typically in the form host:port.",
      "sourceType": "io.quarkus.kafka.streams.runtime.KafkaStreamsRuntimeConfig"
    },
    {
      "type": "java.util.List\u003cjava.lang.String\u003e",
      "sourceField": "topics",
      "extensionName": "quarkus-kafka-streams",
      "required": true,
      "phase": 4,
      "name": "quarkus.kafka-streams.topics",
      "description": "A comma-separated list of topic names.\nThe pipeline will only be started once all these topics are present in the Kafka cluster.",
      "sourceType": "io.quarkus.kafka.streams.runtime.KafkaStreamsRuntimeConfig"
    },
    {
      "type": "java.util.List\u003cjava.lang.String\u003e",
      "sourceField": "topics",
      "required": true,
      "phase": 0,
      "name": "quarkus.kafka-streams.topics",
      "sourceType": "io.quarkus.kafka.streams.runtime.health.KafkaStreamsTopicsHealthCheck"
    },
    {
      "type": "int",
      "sourceField": "connectionPoolSize",
      "defaultValue": "20",
      "extensionName": "quarkus-keycloak-authorization",
      "required": false,
      "phase": 2,
      "name": "quarkus.keycloak.connection-pool-size",
      "description": "Adapters will make separate HTTP invocations to the Keycloak server to turn an access code into an access token.\nThis config option defines how many connections to the Keycloak server should be pooled",
      "sourceType": "io.quarkus.keycloak.pep.runtime.KeycloakPolicyEnforcerConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enable",
      "defaultValue": "false",
      "extensionName": "quarkus-keycloak-authorization",
      "required": false,
      "phase": 2,
      "name": "quarkus.keycloak.policy-enforcer.enable",
      "description": "Enables policy enforcement.",
      "sourceType": "io.quarkus.keycloak.pep.runtime.KeycloakPolicyEnforcerConfig.KeycloakConfigPolicyEnforcer"
    },
    {
      "type": "java.lang.String",
      "sourceField": "enforcementMode",
      "defaultValue": "ENFORCING",
      "extensionName": "quarkus-keycloak-authorization",
      "required": false,
      "phase": 2,
      "name": "quarkus.keycloak.policy-enforcer.enforcement-mode",
      "description": "Specifies how policies are enforced.",
      "sourceType": "io.quarkus.keycloak.pep.runtime.KeycloakPolicyEnforcerConfig.KeycloakConfigPolicyEnforcer"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "extensionName": "quarkus-keycloak-authorization",
      "required": false,
      "phase": 2,
      "name": "quarkus.keycloak.policy-enforcer.paths.{*}.name",
      "description": "The name of a resource on the server that is to be associated with a given path",
      "sourceType": "io.quarkus.keycloak.pep.runtime.KeycloakPolicyEnforcerConfig.KeycloakConfigPolicyEnforcer.PathConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "extensionName": "quarkus-keycloak-authorization",
      "required": false,
      "phase": 2,
      "name": "quarkus.keycloak.policy-enforcer.paths.{*}.path",
      "description": "A URI relative to the applications context path that should be protected by the policy enforcer",
      "sourceType": "io.quarkus.keycloak.pep.runtime.KeycloakPolicyEnforcerConfig.KeycloakConfigPolicyEnforcer.PathConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "method",
      "extensionName": "quarkus-keycloak-authorization",
      "required": true,
      "phase": 2,
      "name": "quarkus.keycloak.policy-enforcer.paths.{*}.methods.{*}.method",
      "description": "The name of the HTTP method",
      "sourceType": "io.quarkus.keycloak.pep.runtime.KeycloakPolicyEnforcerConfig.KeycloakConfigPolicyEnforcer.MethodConfig"
    },
    {
      "type": "java.util.List\u003cjava.lang.String\u003e",
      "sourceField": "scopes",
      "extensionName": "quarkus-keycloak-authorization",
      "required": true,
      "phase": 2,
      "name": "quarkus.keycloak.policy-enforcer.paths.{*}.methods.{*}.scopes",
      "description": "An array of strings with the scopes associated with the method",
      "sourceType": "io.quarkus.keycloak.pep.runtime.KeycloakPolicyEnforcerConfig.KeycloakConfigPolicyEnforcer.MethodConfig"
    },
    {
      "type": "org.keycloak.representations.adapters.config.PolicyEnforcerConfig.ScopeEnforcementMode",
      "sourceField": "scopesEnforcementMode",
      "defaultValue": "ALL",
      "extensionName": "quarkus-keycloak-authorization",
      "required": false,
      "phase": 2,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.keycloak.policy-enforcer.paths.{*}.methods.{*}.scopes-enforcement-mode",
      "description": "A string referencing the enforcement mode for the scopes associated with a method",
      "sourceType": "io.quarkus.keycloak.pep.runtime.KeycloakPolicyEnforcerConfig.KeycloakConfigPolicyEnforcer.MethodConfig"
    },
    {
      "type": "org.keycloak.representations.adapters.config.PolicyEnforcerConfig.EnforcementMode",
      "sourceField": "enforcementMode",
      "defaultValue": "ENFORCING",
      "extensionName": "quarkus-keycloak-authorization",
      "required": false,
      "phase": 2,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.keycloak.policy-enforcer.paths.{*}.enforcement-mode",
      "description": "Specifies how policies are enforced",
      "sourceType": "io.quarkus.keycloak.pep.runtime.KeycloakPolicyEnforcerConfig.KeycloakConfigPolicyEnforcer.PathConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "complexConfig",
      "extensionName": "quarkus-keycloak-authorization",
      "required": true,
      "phase": 2,
      "name": "quarkus.keycloak.policy-enforcer.paths.{*}.claim-information-point.{*}.{*}.{*}",
      "description": "",
      "sourceType": "io.quarkus.keycloak.pep.runtime.KeycloakPolicyEnforcerConfig.KeycloakConfigPolicyEnforcer.ClaimInformationPointConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "simpleConfig",
      "extensionName": "quarkus-keycloak-authorization",
      "required": true,
      "phase": 2,
      "name": "quarkus.keycloak.policy-enforcer.paths.{*}.claim-information-point.{*}.{*}",
      "description": "",
      "sourceType": "io.quarkus.keycloak.pep.runtime.KeycloakPolicyEnforcerConfig.KeycloakConfigPolicyEnforcer.ClaimInformationPointConfig"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.keycloak.pep.runtime.KeycloakPolicyEnforcerConfig.KeycloakConfigPolicyEnforcer.PathCacheConfig\u003e",
      "sourceField": "pathCache",
      "extensionName": "quarkus-keycloak-authorization",
      "required": false,
      "phase": 2,
      "name": "quarkus.keycloak.policy-enforcer.path-cache",
      "description": "Defines how the policy enforcer should track associations between paths in your application and resources defined in\nKeycloak.\nThe cache is needed to avoid unnecessary requests to a Keycloak server by caching associations between paths and\nprotected resources",
      "sourceType": "io.quarkus.keycloak.pep.runtime.KeycloakPolicyEnforcerConfig.KeycloakConfigPolicyEnforcer"
    },
    {
      "type": "boolean",
      "sourceField": "lazyLoadPaths",
      "defaultValue": "true",
      "extensionName": "quarkus-keycloak-authorization",
      "required": false,
      "phase": 2,
      "name": "quarkus.keycloak.policy-enforcer.lazy-load-paths",
      "description": "Specifies how the adapter should fetch the server for resources associated with paths in your application. If true,\nthe\npolicy\nenforcer is going to fetch resources on-demand accordingly with the path being requested",
      "sourceType": "io.quarkus.keycloak.pep.runtime.KeycloakPolicyEnforcerConfig.KeycloakConfigPolicyEnforcer"
    },
    {
      "type": "java.lang.String",
      "sourceField": "complexConfig",
      "extensionName": "quarkus-keycloak-authorization",
      "required": true,
      "phase": 2,
      "name": "quarkus.keycloak.policy-enforcer.claim-information-point.{*}.{*}.{*}",
      "description": "",
      "sourceType": "io.quarkus.keycloak.pep.runtime.KeycloakPolicyEnforcerConfig.KeycloakConfigPolicyEnforcer.ClaimInformationPointConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "simpleConfig",
      "extensionName": "quarkus-keycloak-authorization",
      "required": true,
      "phase": 2,
      "name": "quarkus.keycloak.policy-enforcer.claim-information-point.{*}.{*}",
      "description": "",
      "sourceType": "io.quarkus.keycloak.pep.runtime.KeycloakPolicyEnforcerConfig.KeycloakConfigPolicyEnforcer.ClaimInformationPointConfig"
    },
    {
      "type": "boolean",
      "sourceField": "httpMethodAsScope",
      "defaultValue": "false",
      "extensionName": "quarkus-keycloak-authorization",
      "required": false,
      "phase": 2,
      "name": "quarkus.keycloak.policy-enforcer.http-method-as-scope",
      "description": "Specifies how scopes should be mapped to HTTP methods. If set to true, the policy enforcer will use the HTTP method\nfrom\nthe current request to check whether or not access should be granted",
      "sourceType": "io.quarkus.keycloak.pep.runtime.KeycloakPolicyEnforcerConfig.KeycloakConfigPolicyEnforcer"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "partOf",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.part-of",
      "description": "The name of the group this component belongs too",
      "sourceType": "io.quarkus.kubernetes.deployment.KnativeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "defaultValue": "${quarkus.container-image.name}",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.name",
      "description": "The name of the application. This value will be used for naming Kubernetes\nresources like: - Deployment - Service and so on ...",
      "sourceType": "io.quarkus.kubernetes.deployment.KnativeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "version",
      "defaultValue": "${quarkus.container-image.tag}",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.version",
      "description": "The version of the application.",
      "sourceType": "io.quarkus.kubernetes.deployment.KnativeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "labels",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.knative.labels.{*}",
      "description": "Custom labels to add to all resources",
      "sourceType": "io.quarkus.kubernetes.deployment.KnativeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "annotations",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.knative.annotations.{*}",
      "description": "Custom annotations to add to all resources",
      "sourceType": "io.quarkus.kubernetes.deployment.KnativeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "addBuildTimestamp",
      "defaultValue": "true",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.add-build-timestamp",
      "description": "Whether or not to add the build timestamp to the Kubernetes annotations\nThis is a very useful way to have manifests of successive builds of the same\napplication differ - thus ensuring that Kubernetes will apply the updated resources",
      "sourceType": "io.quarkus.kubernetes.deployment.KnativeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.env-vars.{*}.name",
      "description": "The environment variable name.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "value",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.env-vars.{*}.value",
      "description": "The environment variable value.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "secret",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.env-vars.{*}.secret",
      "description": "The environment variable secret.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "configmap",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.env-vars.{*}.configmap",
      "description": "The environment variable config map.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "field",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.env-vars.{*}.field",
      "description": "The environment variable field.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "workingDir",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.working-dir",
      "description": "Working directory",
      "sourceType": "io.quarkus.kubernetes.deployment.KnativeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "command",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.command",
      "description": "The commands",
      "sourceType": "io.quarkus.kubernetes.deployment.KnativeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "arguments",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.arguments",
      "description": "The arguments\n\n@return The arguments",
      "sourceType": "io.quarkus.kubernetes.deployment.KnativeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "serviceAccount",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.service-account",
      "description": "The service account",
      "sourceType": "io.quarkus.kubernetes.deployment.KnativeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "host",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.host",
      "description": "The host under which the application is going to be exposed",
      "sourceType": "io.quarkus.kubernetes.deployment.KnativeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "containerPort",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.ports.{*}.container-port",
      "description": "The port number. Refers to the container port.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "hostPort",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.ports.{*}.host-port",
      "description": "The host port.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "defaultValue": "/",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.ports.{*}.path",
      "description": "The application path (refers to web application path).\n\n@return The path, defaults to /.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.Protocol",
      "sourceField": "protocol",
      "defaultValue": "TCP",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.knative.ports.{*}.protocol",
      "description": "The protocol.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.ServiceType",
      "sourceField": "serviceType",
      "defaultValue": "ClusterIP",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.knative.service-type",
      "description": "The type of service that will be generated for the application",
      "sourceType": "io.quarkus.kubernetes.deployment.KnativeConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.ImagePullPolicy",
      "sourceField": "imagePullPolicy",
      "defaultValue": "Always",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.knative.image-pull-policy",
      "description": "Image pull policy",
      "sourceType": "io.quarkus.kubernetes.deployment.KnativeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "imagePullSecrets",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.image-pull-secrets",
      "description": "The image pull secret",
      "sourceType": "io.quarkus.kubernetes.deployment.KnativeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "httpActionPath",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.liveness-probe.http-action-path",
      "description": "The http path to use for the probe For this to work, the container port also\nneeds to be set\n\nAssuming the container port has been set (as per above comment), if\nexecAction or tcpSocketAction are not set, an http probe will be used\nautomatically even if no path is set (which will result in the root path\nbeing used)",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "execAction",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.liveness-probe.exec-action",
      "description": "The command to use for the probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "tcpSocketAction",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.liveness-probe.tcp-socket-action",
      "description": "The tcp socket to use for the probe (the format is host:port).",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "initialDelay",
      "defaultValue": "0",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.liveness-probe.initial-delay",
      "description": "The amount of time to wait before starting to probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "period",
      "defaultValue": "30s",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.liveness-probe.period",
      "description": "The period in which the action should be called.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "timeout",
      "defaultValue": "10s",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.liveness-probe.timeout",
      "description": "The amount of time to wait for each action.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.lang.Integer",
      "sourceField": "successThreshold",
      "defaultValue": "1",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.liveness-probe.success-threshold",
      "description": "The success threshold to use.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.lang.Integer",
      "sourceField": "failureThreshold",
      "defaultValue": "3",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.liveness-probe.failure-threshold",
      "description": "The failure threshold to use.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "httpActionPath",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.readiness-probe.http-action-path",
      "description": "The http path to use for the probe For this to work, the container port also\nneeds to be set\n\nAssuming the container port has been set (as per above comment), if\nexecAction or tcpSocketAction are not set, an http probe will be used\nautomatically even if no path is set (which will result in the root path\nbeing used)",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "execAction",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.readiness-probe.exec-action",
      "description": "The command to use for the probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "tcpSocketAction",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.readiness-probe.tcp-socket-action",
      "description": "The tcp socket to use for the probe (the format is host:port).",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "initialDelay",
      "defaultValue": "0",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.readiness-probe.initial-delay",
      "description": "The amount of time to wait before starting to probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "period",
      "defaultValue": "30s",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.readiness-probe.period",
      "description": "The period in which the action should be called.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "timeout",
      "defaultValue": "10s",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.readiness-probe.timeout",
      "description": "The amount of time to wait for each action.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.lang.Integer",
      "sourceField": "successThreshold",
      "defaultValue": "1",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.readiness-probe.success-threshold",
      "description": "The success threshold to use.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.lang.Integer",
      "sourceField": "failureThreshold",
      "defaultValue": "3",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.readiness-probe.failure-threshold",
      "description": "The failure threshold to use.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.mounts.{*}.name",
      "description": "The name of the volumeName to mount.\n\n@return The name.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.mounts.{*}.path",
      "description": "The path to mount.\n\n@return The path.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "subPath",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.mounts.{*}.sub-path",
      "description": "Path within the volumeName from which the container\u0027s volumeName should be\nmounted.\n\n@return The subPath.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "boolean",
      "sourceField": "readOnly",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.mounts.{*}.read-only",
      "description": "ReadOnly\n\n@return True if mount is readonly, False otherwise.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "secretName",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.knative.secret-volumes.{*}.secret-name",
      "description": "The name of the secret to mount.",
      "sourceType": "io.quarkus.kubernetes.deployment.SecretVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "defaultMode",
      "defaultValue": "0600",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.secret-volumes.{*}.default-mode",
      "description": "Default mode.\nWhen specifying an octal number, leading zero must be present.\n\n@return The default mode.",
      "sourceType": "io.quarkus.kubernetes.deployment.SecretVolumeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "optional",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.secret-volumes.{*}.optional",
      "description": "Optional",
      "sourceType": "io.quarkus.kubernetes.deployment.SecretVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "configMapName",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.knative.config-map-volumes.{*}.config-map-name",
      "description": "The name of the ConfigMap to mount.",
      "sourceType": "io.quarkus.kubernetes.deployment.ConfigMapVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "defaultMode",
      "defaultValue": "0600",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.config-map-volumes.{*}.default-mode",
      "description": "Default mode.\nWhen specifying an octal number, leading zero must be present.\n\n@return The default mode.",
      "sourceType": "io.quarkus.kubernetes.deployment.ConfigMapVolumeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "optional",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.config-map-volumes.{*}.optional",
      "description": "Optional",
      "sourceType": "io.quarkus.kubernetes.deployment.ConfigMapVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "repository",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.knative.git-repo-volumes.{*}.repository",
      "description": "Git repoistory URL.",
      "sourceType": "io.quarkus.kubernetes.deployment.GitRepoVolumeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "directory",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.git-repo-volumes.{*}.directory",
      "description": "The directory of the repository to mount.",
      "sourceType": "io.quarkus.kubernetes.deployment.GitRepoVolumeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "revision",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.git-repo-volumes.{*}.revision",
      "description": "The commit hash to use.",
      "sourceType": "io.quarkus.kubernetes.deployment.GitRepoVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "claimName",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.knative.pvc-volumes.{*}.claim-name",
      "description": "The name of the claim to mount.",
      "sourceType": "io.quarkus.kubernetes.deployment.PvcVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "defaultMode",
      "defaultValue": "0600",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.pvc-volumes.{*}.default-mode",
      "description": "Default mode.\nWhen specifying an octal number, leading zero must be present.\n\n@return The default mode.",
      "sourceType": "io.quarkus.kubernetes.deployment.PvcVolumeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "optional",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.pvc-volumes.{*}.optional",
      "description": "Optional",
      "sourceType": "io.quarkus.kubernetes.deployment.PvcVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "volumeId",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.knative.aws-elastic-block-store-volumes.{*}.volume-id",
      "description": "The name of the disk to mount.",
      "sourceType": "io.quarkus.kubernetes.deployment.AwsElasticBlockStoreVolumeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "partition",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.aws-elastic-block-store-volumes.{*}.partition",
      "description": "The partition.",
      "sourceType": "io.quarkus.kubernetes.deployment.AwsElasticBlockStoreVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "fsType",
      "defaultValue": "ext4",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.aws-elastic-block-store-volumes.{*}.fs-type",
      "description": "Filesystem type.",
      "sourceType": "io.quarkus.kubernetes.deployment.AwsElasticBlockStoreVolumeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "readOnly",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.aws-elastic-block-store-volumes.{*}.read-only",
      "description": "Wether the volumeName is read only or not.",
      "sourceType": "io.quarkus.kubernetes.deployment.AwsElasticBlockStoreVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "shareName",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.knative.azure-file-volumes.{*}.share-name",
      "description": "The share name.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureFileVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "secretName",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.knative.azure-file-volumes.{*}.secret-name",
      "description": "The secret name.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureFileVolumeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "readOnly",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.azure-file-volumes.{*}.read-only",
      "description": "Wether the volumeName is read only or not.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureFileVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "diskName",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.knative.azure-disk-volumes.{*}.disk-name",
      "description": "The name of the disk to mount.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "diskURI",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.knative.azure-disk-volumes.{*}.disk-uri",
      "description": "The URI of the vhd blob object OR the resourceID of an Azure managed data disk if Kind is Managed",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig"
    },
    {
      "type": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig.Kind",
      "sourceField": "kind",
      "defaultValue": "Managed",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.knative.azure-disk-volumes.{*}.kind",
      "description": "Kind of disk.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig"
    },
    {
      "type": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig.CachingMode",
      "sourceField": "cachingMode",
      "defaultValue": "ReadWrite",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.knative.azure-disk-volumes.{*}.caching-mode",
      "description": "Disk caching mode.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "fsType",
      "defaultValue": "ext4",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.azure-disk-volumes.{*}.fs-type",
      "description": "File system type.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "readOnly",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.azure-disk-volumes.{*}.read-only",
      "description": "Wether the volumeName is read only or not.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "image",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.image",
      "description": "The container image.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.env-vars.{*}.name",
      "description": "The environment variable name.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "value",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.env-vars.{*}.value",
      "description": "The environment variable value.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "secret",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.env-vars.{*}.secret",
      "description": "The environment variable secret.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "configmap",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.env-vars.{*}.configmap",
      "description": "The environment variable config map.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "field",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.env-vars.{*}.field",
      "description": "The environment variable field.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "workingDir",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.working-dir",
      "description": "Working directory.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "command",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.command",
      "description": "The commands",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "arguments",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.arguments",
      "description": "The arguments\n\n@return The arguments.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "serviceAccount",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.service-account",
      "description": "The service account.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "host",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.host",
      "description": "The host under which the application is going to be exposed.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "containerPort",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.ports.{*}.container-port",
      "description": "The port number. Refers to the container port.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "hostPort",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.ports.{*}.host-port",
      "description": "The host port.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "defaultValue": "/",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.ports.{*}.path",
      "description": "The application path (refers to web application path).\n\n@return The path, defaults to /.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.Protocol",
      "sourceField": "protocol",
      "defaultValue": "TCP",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.knative.init-containers.{*}.ports.{*}.protocol",
      "description": "The protocol.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.ImagePullPolicy",
      "sourceField": "imagePullPolicy",
      "defaultValue": "Always",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.knative.init-containers.{*}.image-pull-policy",
      "description": "Image pull policy.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "imagePullSecrets",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.image-pull-secrets",
      "description": "The image pull secret",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.kubernetes.deployment.ProbeConfig\u003e",
      "sourceField": "livenessProbe",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.liveness-probe",
      "description": "The liveness probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.kubernetes.deployment.ProbeConfig\u003e",
      "sourceField": "readinessProbe",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.readiness-probe",
      "description": "The readiness probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.mounts.{*}.name",
      "description": "The name of the volumeName to mount.\n\n@return The name.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.mounts.{*}.path",
      "description": "The path to mount.\n\n@return The path.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "subPath",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.mounts.{*}.sub-path",
      "description": "Path within the volumeName from which the container\u0027s volumeName should be\nmounted.\n\n@return The subPath.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "boolean",
      "sourceField": "readOnly",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.init-containers.{*}.mounts.{*}.read-only",
      "description": "ReadOnly\n\n@return True if mount is readonly, False otherwise.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "image",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.image",
      "description": "The container image.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.env-vars.{*}.name",
      "description": "The environment variable name.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "value",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.env-vars.{*}.value",
      "description": "The environment variable value.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "secret",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.env-vars.{*}.secret",
      "description": "The environment variable secret.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "configmap",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.env-vars.{*}.configmap",
      "description": "The environment variable config map.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "field",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.env-vars.{*}.field",
      "description": "The environment variable field.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "workingDir",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.working-dir",
      "description": "Working directory.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "command",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.command",
      "description": "The commands",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "arguments",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.arguments",
      "description": "The arguments\n\n@return The arguments.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "serviceAccount",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.service-account",
      "description": "The service account.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "host",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.host",
      "description": "The host under which the application is going to be exposed.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "containerPort",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.ports.{*}.container-port",
      "description": "The port number. Refers to the container port.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "hostPort",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.ports.{*}.host-port",
      "description": "The host port.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "defaultValue": "/",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.ports.{*}.path",
      "description": "The application path (refers to web application path).\n\n@return The path, defaults to /.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.Protocol",
      "sourceField": "protocol",
      "defaultValue": "TCP",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.knative.containers.{*}.ports.{*}.protocol",
      "description": "The protocol.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.ImagePullPolicy",
      "sourceField": "imagePullPolicy",
      "defaultValue": "Always",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.knative.containers.{*}.image-pull-policy",
      "description": "Image pull policy.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "imagePullSecrets",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.image-pull-secrets",
      "description": "The image pull secret",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.kubernetes.deployment.ProbeConfig\u003e",
      "sourceField": "livenessProbe",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.liveness-probe",
      "description": "The liveness probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.kubernetes.deployment.ProbeConfig\u003e",
      "sourceField": "readinessProbe",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.readiness-probe",
      "description": "The readiness probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.mounts.{*}.name",
      "description": "The name of the volumeName to mount.\n\n@return The name.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.mounts.{*}.path",
      "description": "The path to mount.\n\n@return The path.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "subPath",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.mounts.{*}.sub-path",
      "description": "Path within the volumeName from which the container\u0027s volumeName should be\nmounted.\n\n@return The subPath.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "boolean",
      "sourceField": "readOnly",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.knative.containers.{*}.mounts.{*}.read-only",
      "description": "ReadOnly\n\n@return True if mount is readonly, False otherwise.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "partOf",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.part-of",
      "description": "The name of the group this component belongs too",
      "sourceType": "io.quarkus.kubernetes.deployment.KubernetesConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "defaultValue": "${quarkus.container-image.name}",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.name",
      "description": "The name of the application. This value will be used for naming Kubernetes\nresources like: - Deployment - Service and so on ...",
      "sourceType": "io.quarkus.kubernetes.deployment.KubernetesConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "version",
      "defaultValue": "${quarkus.container-image.tag}",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.version",
      "description": "The version of the application.",
      "sourceType": "io.quarkus.kubernetes.deployment.KubernetesConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "labels",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.kubernetes.labels.{*}",
      "description": "Custom labels to add to all resources",
      "sourceType": "io.quarkus.kubernetes.deployment.KubernetesConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "annotations",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.kubernetes.annotations.{*}",
      "description": "Custom annotations to add to all resources",
      "sourceType": "io.quarkus.kubernetes.deployment.KubernetesConfig"
    },
    {
      "type": "boolean",
      "sourceField": "addBuildTimestamp",
      "defaultValue": "true",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.add-build-timestamp",
      "description": "Whether or not to add the build timestamp to the Kubernetes annotations\nThis is a very useful way to have manifests of successive builds of the same\napplication differ - thus ensuring that Kubernetes will apply the updated resources",
      "sourceType": "io.quarkus.kubernetes.deployment.KubernetesConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.env-vars.{*}.name",
      "description": "The environment variable name.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "value",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.env-vars.{*}.value",
      "description": "The environment variable value.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "secret",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.env-vars.{*}.secret",
      "description": "The environment variable secret.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "configmap",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.env-vars.{*}.configmap",
      "description": "The environment variable config map.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "field",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.env-vars.{*}.field",
      "description": "The environment variable field.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "workingDir",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.working-dir",
      "description": "Working directory",
      "sourceType": "io.quarkus.kubernetes.deployment.KubernetesConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "command",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.command",
      "description": "The commands",
      "sourceType": "io.quarkus.kubernetes.deployment.KubernetesConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "arguments",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.arguments",
      "description": "The arguments\n\n@return The arguments",
      "sourceType": "io.quarkus.kubernetes.deployment.KubernetesConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "serviceAccount",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.service-account",
      "description": "The service account",
      "sourceType": "io.quarkus.kubernetes.deployment.KubernetesConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "host",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.host",
      "description": "The host under which the application is going to be exposed",
      "sourceType": "io.quarkus.kubernetes.deployment.KubernetesConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "containerPort",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.ports.{*}.container-port",
      "description": "The port number. Refers to the container port.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "hostPort",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.ports.{*}.host-port",
      "description": "The host port.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "defaultValue": "/",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.ports.{*}.path",
      "description": "The application path (refers to web application path).\n\n@return The path, defaults to /.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.Protocol",
      "sourceField": "protocol",
      "defaultValue": "TCP",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.kubernetes.ports.{*}.protocol",
      "description": "The protocol.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "java.lang.Integer",
      "sourceField": "replicas",
      "defaultValue": "1",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.replicas",
      "description": "The number of desired pods",
      "sourceType": "io.quarkus.kubernetes.deployment.KubernetesConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.ServiceType",
      "sourceField": "serviceType",
      "defaultValue": "ClusterIP",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.kubernetes.service-type",
      "description": "The type of service that will be generated for the application",
      "sourceType": "io.quarkus.kubernetes.deployment.KubernetesConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.ImagePullPolicy",
      "sourceField": "imagePullPolicy",
      "defaultValue": "Always",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.kubernetes.image-pull-policy",
      "description": "Image pull policy",
      "sourceType": "io.quarkus.kubernetes.deployment.KubernetesConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "imagePullSecrets",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.image-pull-secrets",
      "description": "The image pull secret",
      "sourceType": "io.quarkus.kubernetes.deployment.KubernetesConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "httpActionPath",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.liveness-probe.http-action-path",
      "description": "The http path to use for the probe For this to work, the container port also\nneeds to be set\n\nAssuming the container port has been set (as per above comment), if\nexecAction or tcpSocketAction are not set, an http probe will be used\nautomatically even if no path is set (which will result in the root path\nbeing used)",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "execAction",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.liveness-probe.exec-action",
      "description": "The command to use for the probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "tcpSocketAction",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.liveness-probe.tcp-socket-action",
      "description": "The tcp socket to use for the probe (the format is host:port).",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "initialDelay",
      "defaultValue": "0",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.liveness-probe.initial-delay",
      "description": "The amount of time to wait before starting to probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "period",
      "defaultValue": "30s",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.liveness-probe.period",
      "description": "The period in which the action should be called.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "timeout",
      "defaultValue": "10s",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.liveness-probe.timeout",
      "description": "The amount of time to wait for each action.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.lang.Integer",
      "sourceField": "successThreshold",
      "defaultValue": "1",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.liveness-probe.success-threshold",
      "description": "The success threshold to use.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.lang.Integer",
      "sourceField": "failureThreshold",
      "defaultValue": "3",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.liveness-probe.failure-threshold",
      "description": "The failure threshold to use.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "httpActionPath",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.readiness-probe.http-action-path",
      "description": "The http path to use for the probe For this to work, the container port also\nneeds to be set\n\nAssuming the container port has been set (as per above comment), if\nexecAction or tcpSocketAction are not set, an http probe will be used\nautomatically even if no path is set (which will result in the root path\nbeing used)",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "execAction",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.readiness-probe.exec-action",
      "description": "The command to use for the probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "tcpSocketAction",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.readiness-probe.tcp-socket-action",
      "description": "The tcp socket to use for the probe (the format is host:port).",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "initialDelay",
      "defaultValue": "0",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.readiness-probe.initial-delay",
      "description": "The amount of time to wait before starting to probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "period",
      "defaultValue": "30s",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.readiness-probe.period",
      "description": "The period in which the action should be called.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "timeout",
      "defaultValue": "10s",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.readiness-probe.timeout",
      "description": "The amount of time to wait for each action.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.lang.Integer",
      "sourceField": "successThreshold",
      "defaultValue": "1",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.readiness-probe.success-threshold",
      "description": "The success threshold to use.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.lang.Integer",
      "sourceField": "failureThreshold",
      "defaultValue": "3",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.readiness-probe.failure-threshold",
      "description": "The failure threshold to use.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.mounts.{*}.name",
      "description": "The name of the volumeName to mount.\n\n@return The name.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.mounts.{*}.path",
      "description": "The path to mount.\n\n@return The path.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "subPath",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.mounts.{*}.sub-path",
      "description": "Path within the volumeName from which the container\u0027s volumeName should be\nmounted.\n\n@return The subPath.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "boolean",
      "sourceField": "readOnly",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.mounts.{*}.read-only",
      "description": "ReadOnly\n\n@return True if mount is readonly, False otherwise.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "secretName",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.kubernetes.secret-volumes.{*}.secret-name",
      "description": "The name of the secret to mount.",
      "sourceType": "io.quarkus.kubernetes.deployment.SecretVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "defaultMode",
      "defaultValue": "0600",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.secret-volumes.{*}.default-mode",
      "description": "Default mode.\nWhen specifying an octal number, leading zero must be present.\n\n@return The default mode.",
      "sourceType": "io.quarkus.kubernetes.deployment.SecretVolumeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "optional",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.secret-volumes.{*}.optional",
      "description": "Optional",
      "sourceType": "io.quarkus.kubernetes.deployment.SecretVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "configMapName",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.kubernetes.config-map-volumes.{*}.config-map-name",
      "description": "The name of the ConfigMap to mount.",
      "sourceType": "io.quarkus.kubernetes.deployment.ConfigMapVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "defaultMode",
      "defaultValue": "0600",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.config-map-volumes.{*}.default-mode",
      "description": "Default mode.\nWhen specifying an octal number, leading zero must be present.\n\n@return The default mode.",
      "sourceType": "io.quarkus.kubernetes.deployment.ConfigMapVolumeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "optional",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.config-map-volumes.{*}.optional",
      "description": "Optional",
      "sourceType": "io.quarkus.kubernetes.deployment.ConfigMapVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "repository",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.kubernetes.git-repo-volumes.{*}.repository",
      "description": "Git repoistory URL.",
      "sourceType": "io.quarkus.kubernetes.deployment.GitRepoVolumeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "directory",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.git-repo-volumes.{*}.directory",
      "description": "The directory of the repository to mount.",
      "sourceType": "io.quarkus.kubernetes.deployment.GitRepoVolumeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "revision",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.git-repo-volumes.{*}.revision",
      "description": "The commit hash to use.",
      "sourceType": "io.quarkus.kubernetes.deployment.GitRepoVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "claimName",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.kubernetes.pvc-volumes.{*}.claim-name",
      "description": "The name of the claim to mount.",
      "sourceType": "io.quarkus.kubernetes.deployment.PvcVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "defaultMode",
      "defaultValue": "0600",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.pvc-volumes.{*}.default-mode",
      "description": "Default mode.\nWhen specifying an octal number, leading zero must be present.\n\n@return The default mode.",
      "sourceType": "io.quarkus.kubernetes.deployment.PvcVolumeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "optional",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.pvc-volumes.{*}.optional",
      "description": "Optional",
      "sourceType": "io.quarkus.kubernetes.deployment.PvcVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "volumeId",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.kubernetes.aws-elastic-block-store-volumes.{*}.volume-id",
      "description": "The name of the disk to mount.",
      "sourceType": "io.quarkus.kubernetes.deployment.AwsElasticBlockStoreVolumeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "partition",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.aws-elastic-block-store-volumes.{*}.partition",
      "description": "The partition.",
      "sourceType": "io.quarkus.kubernetes.deployment.AwsElasticBlockStoreVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "fsType",
      "defaultValue": "ext4",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.aws-elastic-block-store-volumes.{*}.fs-type",
      "description": "Filesystem type.",
      "sourceType": "io.quarkus.kubernetes.deployment.AwsElasticBlockStoreVolumeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "readOnly",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.aws-elastic-block-store-volumes.{*}.read-only",
      "description": "Wether the volumeName is read only or not.",
      "sourceType": "io.quarkus.kubernetes.deployment.AwsElasticBlockStoreVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "shareName",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.kubernetes.azure-file-volumes.{*}.share-name",
      "description": "The share name.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureFileVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "secretName",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.kubernetes.azure-file-volumes.{*}.secret-name",
      "description": "The secret name.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureFileVolumeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "readOnly",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.azure-file-volumes.{*}.read-only",
      "description": "Wether the volumeName is read only or not.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureFileVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "diskName",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.kubernetes.azure-disk-volumes.{*}.disk-name",
      "description": "The name of the disk to mount.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "diskURI",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.kubernetes.azure-disk-volumes.{*}.disk-uri",
      "description": "The URI of the vhd blob object OR the resourceID of an Azure managed data disk if Kind is Managed",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig"
    },
    {
      "type": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig.Kind",
      "sourceField": "kind",
      "defaultValue": "Managed",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.kubernetes.azure-disk-volumes.{*}.kind",
      "description": "Kind of disk.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig"
    },
    {
      "type": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig.CachingMode",
      "sourceField": "cachingMode",
      "defaultValue": "ReadWrite",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.kubernetes.azure-disk-volumes.{*}.caching-mode",
      "description": "Disk caching mode.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "fsType",
      "defaultValue": "ext4",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.azure-disk-volumes.{*}.fs-type",
      "description": "File system type.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "readOnly",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.azure-disk-volumes.{*}.read-only",
      "description": "Wether the volumeName is read only or not.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "image",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.image",
      "description": "The container image.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.env-vars.{*}.name",
      "description": "The environment variable name.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "value",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.env-vars.{*}.value",
      "description": "The environment variable value.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "secret",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.env-vars.{*}.secret",
      "description": "The environment variable secret.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "configmap",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.env-vars.{*}.configmap",
      "description": "The environment variable config map.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "field",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.env-vars.{*}.field",
      "description": "The environment variable field.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "workingDir",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.working-dir",
      "description": "Working directory.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "command",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.command",
      "description": "The commands",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "arguments",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.arguments",
      "description": "The arguments\n\n@return The arguments.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "serviceAccount",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.service-account",
      "description": "The service account.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "host",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.host",
      "description": "The host under which the application is going to be exposed.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "containerPort",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.ports.{*}.container-port",
      "description": "The port number. Refers to the container port.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "hostPort",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.ports.{*}.host-port",
      "description": "The host port.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "defaultValue": "/",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.ports.{*}.path",
      "description": "The application path (refers to web application path).\n\n@return The path, defaults to /.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.Protocol",
      "sourceField": "protocol",
      "defaultValue": "TCP",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.kubernetes.init-containers.{*}.ports.{*}.protocol",
      "description": "The protocol.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.ImagePullPolicy",
      "sourceField": "imagePullPolicy",
      "defaultValue": "Always",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.kubernetes.init-containers.{*}.image-pull-policy",
      "description": "Image pull policy.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "imagePullSecrets",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.image-pull-secrets",
      "description": "The image pull secret",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.kubernetes.deployment.ProbeConfig\u003e",
      "sourceField": "livenessProbe",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.liveness-probe",
      "description": "The liveness probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.kubernetes.deployment.ProbeConfig\u003e",
      "sourceField": "readinessProbe",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.readiness-probe",
      "description": "The readiness probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.mounts.{*}.name",
      "description": "The name of the volumeName to mount.\n\n@return The name.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.mounts.{*}.path",
      "description": "The path to mount.\n\n@return The path.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "subPath",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.mounts.{*}.sub-path",
      "description": "Path within the volumeName from which the container\u0027s volumeName should be\nmounted.\n\n@return The subPath.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "boolean",
      "sourceField": "readOnly",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.init-containers.{*}.mounts.{*}.read-only",
      "description": "ReadOnly\n\n@return True if mount is readonly, False otherwise.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "image",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.image",
      "description": "The container image.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.env-vars.{*}.name",
      "description": "The environment variable name.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "value",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.env-vars.{*}.value",
      "description": "The environment variable value.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "secret",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.env-vars.{*}.secret",
      "description": "The environment variable secret.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "configmap",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.env-vars.{*}.configmap",
      "description": "The environment variable config map.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "field",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.env-vars.{*}.field",
      "description": "The environment variable field.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "workingDir",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.working-dir",
      "description": "Working directory.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "command",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.command",
      "description": "The commands",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "arguments",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.arguments",
      "description": "The arguments\n\n@return The arguments.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "serviceAccount",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.service-account",
      "description": "The service account.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "host",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.host",
      "description": "The host under which the application is going to be exposed.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "containerPort",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.ports.{*}.container-port",
      "description": "The port number. Refers to the container port.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "hostPort",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.ports.{*}.host-port",
      "description": "The host port.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "defaultValue": "/",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.ports.{*}.path",
      "description": "The application path (refers to web application path).\n\n@return The path, defaults to /.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.Protocol",
      "sourceField": "protocol",
      "defaultValue": "TCP",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.kubernetes.containers.{*}.ports.{*}.protocol",
      "description": "The protocol.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.ImagePullPolicy",
      "sourceField": "imagePullPolicy",
      "defaultValue": "Always",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.kubernetes.containers.{*}.image-pull-policy",
      "description": "Image pull policy.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "imagePullSecrets",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.image-pull-secrets",
      "description": "The image pull secret",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.kubernetes.deployment.ProbeConfig\u003e",
      "sourceField": "livenessProbe",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.liveness-probe",
      "description": "The liveness probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.kubernetes.deployment.ProbeConfig\u003e",
      "sourceField": "readinessProbe",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.readiness-probe",
      "description": "The readiness probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.mounts.{*}.name",
      "description": "The name of the volumeName to mount.\n\n@return The name.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.mounts.{*}.path",
      "description": "The path to mount.\n\n@return The path.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "subPath",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.mounts.{*}.sub-path",
      "description": "Path within the volumeName from which the container\u0027s volumeName should be\nmounted.\n\n@return The subPath.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "boolean",
      "sourceField": "readOnly",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.containers.{*}.mounts.{*}.read-only",
      "description": "ReadOnly\n\n@return True if mount is readonly, False otherwise.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.List\u003cjava.lang.String\u003e",
      "sourceField": "deploymentTarget",
      "defaultValue": "kubernetes",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.deployment-target",
      "description": "The target deployment platform.\nDefaults to kubernetes. Can be kubernetes, openshift, knative etc, or any combination of the above as comma separated\nlist.",
      "sourceType": "io.quarkus.kubernetes.deployment.KubernetesConfig"
    },
    {
      "type": "boolean",
      "sourceField": "expose",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.kubernetes.expose",
      "description": "If true, a Kubernetes Ingress will be created",
      "sourceType": "io.quarkus.kubernetes.deployment.KubernetesConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "partOf",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.part-of",
      "description": "The name of the group this component belongs too",
      "sourceType": "io.quarkus.kubernetes.deployment.OpenshiftConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "defaultValue": "${quarkus.container-image.name}",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.name",
      "description": "The name of the application. This value will be used for naming Kubernetes\nresources like: - Deployment - Service and so on ...",
      "sourceType": "io.quarkus.kubernetes.deployment.OpenshiftConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "version",
      "defaultValue": "${quarkus.container-image.tag}",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.version",
      "description": "The version of the application.",
      "sourceType": "io.quarkus.kubernetes.deployment.OpenshiftConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "labels",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.openshift.labels.{*}",
      "description": "Custom labels to add to all resources",
      "sourceType": "io.quarkus.kubernetes.deployment.OpenshiftConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "annotations",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.openshift.annotations.{*}",
      "description": "Custom annotations to add to all resources",
      "sourceType": "io.quarkus.kubernetes.deployment.OpenshiftConfig"
    },
    {
      "type": "boolean",
      "sourceField": "addBuildTimestamp",
      "defaultValue": "true",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.add-build-timestamp",
      "description": "Whether or not to add the build timestamp to the Kubernetes annotations\nThis is a very useful way to have manifests of successive builds of the same\napplication differ - thus ensuring that Kubernetes will apply the updated resources",
      "sourceType": "io.quarkus.kubernetes.deployment.OpenshiftConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.env-vars.{*}.name",
      "description": "The environment variable name.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "value",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.env-vars.{*}.value",
      "description": "The environment variable value.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "secret",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.env-vars.{*}.secret",
      "description": "The environment variable secret.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "configmap",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.env-vars.{*}.configmap",
      "description": "The environment variable config map.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "field",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.env-vars.{*}.field",
      "description": "The environment variable field.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "workingDir",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.working-dir",
      "description": "Working directory",
      "sourceType": "io.quarkus.kubernetes.deployment.OpenshiftConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "command",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.command",
      "description": "The commands",
      "sourceType": "io.quarkus.kubernetes.deployment.OpenshiftConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "arguments",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.arguments",
      "description": "The arguments\n\n@return The arguments",
      "sourceType": "io.quarkus.kubernetes.deployment.OpenshiftConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "serviceAccount",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.service-account",
      "description": "The service account",
      "sourceType": "io.quarkus.kubernetes.deployment.OpenshiftConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "host",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.host",
      "description": "The host under which the application is going to be exposed",
      "sourceType": "io.quarkus.kubernetes.deployment.OpenshiftConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "containerPort",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.ports.{*}.container-port",
      "description": "The port number. Refers to the container port.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "hostPort",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.ports.{*}.host-port",
      "description": "The host port.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "defaultValue": "/",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.ports.{*}.path",
      "description": "The application path (refers to web application path).\n\n@return The path, defaults to /.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.Protocol",
      "sourceField": "protocol",
      "defaultValue": "TCP",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.openshift.ports.{*}.protocol",
      "description": "The protocol.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "java.lang.Integer",
      "sourceField": "replicas",
      "defaultValue": "1",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.replicas",
      "description": "The number of desired pods",
      "sourceType": "io.quarkus.kubernetes.deployment.OpenshiftConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.ServiceType",
      "sourceField": "serviceType",
      "defaultValue": "ClusterIP",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.openshift.service-type",
      "description": "The type of service that will be generated for the application",
      "sourceType": "io.quarkus.kubernetes.deployment.OpenshiftConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.ImagePullPolicy",
      "sourceField": "imagePullPolicy",
      "defaultValue": "Always",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.openshift.image-pull-policy",
      "description": "Image pull policy",
      "sourceType": "io.quarkus.kubernetes.deployment.OpenshiftConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "imagePullSecrets",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.image-pull-secrets",
      "description": "The image pull secret",
      "sourceType": "io.quarkus.kubernetes.deployment.OpenshiftConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "httpActionPath",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.liveness-probe.http-action-path",
      "description": "The http path to use for the probe For this to work, the container port also\nneeds to be set\n\nAssuming the container port has been set (as per above comment), if\nexecAction or tcpSocketAction are not set, an http probe will be used\nautomatically even if no path is set (which will result in the root path\nbeing used)",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "execAction",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.liveness-probe.exec-action",
      "description": "The command to use for the probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "tcpSocketAction",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.liveness-probe.tcp-socket-action",
      "description": "The tcp socket to use for the probe (the format is host:port).",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "initialDelay",
      "defaultValue": "0",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.liveness-probe.initial-delay",
      "description": "The amount of time to wait before starting to probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "period",
      "defaultValue": "30s",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.liveness-probe.period",
      "description": "The period in which the action should be called.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "timeout",
      "defaultValue": "10s",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.liveness-probe.timeout",
      "description": "The amount of time to wait for each action.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.lang.Integer",
      "sourceField": "successThreshold",
      "defaultValue": "1",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.liveness-probe.success-threshold",
      "description": "The success threshold to use.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.lang.Integer",
      "sourceField": "failureThreshold",
      "defaultValue": "3",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.liveness-probe.failure-threshold",
      "description": "The failure threshold to use.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "httpActionPath",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.readiness-probe.http-action-path",
      "description": "The http path to use for the probe For this to work, the container port also\nneeds to be set\n\nAssuming the container port has been set (as per above comment), if\nexecAction or tcpSocketAction are not set, an http probe will be used\nautomatically even if no path is set (which will result in the root path\nbeing used)",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "execAction",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.readiness-probe.exec-action",
      "description": "The command to use for the probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "tcpSocketAction",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.readiness-probe.tcp-socket-action",
      "description": "The tcp socket to use for the probe (the format is host:port).",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "initialDelay",
      "defaultValue": "0",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.readiness-probe.initial-delay",
      "description": "The amount of time to wait before starting to probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "period",
      "defaultValue": "30s",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.readiness-probe.period",
      "description": "The period in which the action should be called.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "timeout",
      "defaultValue": "10s",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.readiness-probe.timeout",
      "description": "The amount of time to wait for each action.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.lang.Integer",
      "sourceField": "successThreshold",
      "defaultValue": "1",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.readiness-probe.success-threshold",
      "description": "The success threshold to use.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.lang.Integer",
      "sourceField": "failureThreshold",
      "defaultValue": "3",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.readiness-probe.failure-threshold",
      "description": "The failure threshold to use.",
      "sourceType": "io.quarkus.kubernetes.deployment.ProbeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.mounts.{*}.name",
      "description": "The name of the volumeName to mount.\n\n@return The name.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.mounts.{*}.path",
      "description": "The path to mount.\n\n@return The path.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "subPath",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.mounts.{*}.sub-path",
      "description": "Path within the volumeName from which the container\u0027s volumeName should be\nmounted.\n\n@return The subPath.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "boolean",
      "sourceField": "readOnly",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.mounts.{*}.read-only",
      "description": "ReadOnly\n\n@return True if mount is readonly, False otherwise.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "secretName",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.openshift.secret-volumes.{*}.secret-name",
      "description": "The name of the secret to mount.",
      "sourceType": "io.quarkus.kubernetes.deployment.SecretVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "defaultMode",
      "defaultValue": "0600",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.secret-volumes.{*}.default-mode",
      "description": "Default mode.\nWhen specifying an octal number, leading zero must be present.\n\n@return The default mode.",
      "sourceType": "io.quarkus.kubernetes.deployment.SecretVolumeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "optional",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.secret-volumes.{*}.optional",
      "description": "Optional",
      "sourceType": "io.quarkus.kubernetes.deployment.SecretVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "configMapName",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.openshift.config-map-volumes.{*}.config-map-name",
      "description": "The name of the ConfigMap to mount.",
      "sourceType": "io.quarkus.kubernetes.deployment.ConfigMapVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "defaultMode",
      "defaultValue": "0600",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.config-map-volumes.{*}.default-mode",
      "description": "Default mode.\nWhen specifying an octal number, leading zero must be present.\n\n@return The default mode.",
      "sourceType": "io.quarkus.kubernetes.deployment.ConfigMapVolumeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "optional",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.config-map-volumes.{*}.optional",
      "description": "Optional",
      "sourceType": "io.quarkus.kubernetes.deployment.ConfigMapVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "repository",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.openshift.git-repo-volumes.{*}.repository",
      "description": "Git repoistory URL.",
      "sourceType": "io.quarkus.kubernetes.deployment.GitRepoVolumeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "directory",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.git-repo-volumes.{*}.directory",
      "description": "The directory of the repository to mount.",
      "sourceType": "io.quarkus.kubernetes.deployment.GitRepoVolumeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "revision",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.git-repo-volumes.{*}.revision",
      "description": "The commit hash to use.",
      "sourceType": "io.quarkus.kubernetes.deployment.GitRepoVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "claimName",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.openshift.pvc-volumes.{*}.claim-name",
      "description": "The name of the claim to mount.",
      "sourceType": "io.quarkus.kubernetes.deployment.PvcVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "defaultMode",
      "defaultValue": "0600",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.pvc-volumes.{*}.default-mode",
      "description": "Default mode.\nWhen specifying an octal number, leading zero must be present.\n\n@return The default mode.",
      "sourceType": "io.quarkus.kubernetes.deployment.PvcVolumeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "optional",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.pvc-volumes.{*}.optional",
      "description": "Optional",
      "sourceType": "io.quarkus.kubernetes.deployment.PvcVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "volumeId",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.openshift.aws-elastic-block-store-volumes.{*}.volume-id",
      "description": "The name of the disk to mount.",
      "sourceType": "io.quarkus.kubernetes.deployment.AwsElasticBlockStoreVolumeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "partition",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.aws-elastic-block-store-volumes.{*}.partition",
      "description": "The partition.",
      "sourceType": "io.quarkus.kubernetes.deployment.AwsElasticBlockStoreVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "fsType",
      "defaultValue": "ext4",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.aws-elastic-block-store-volumes.{*}.fs-type",
      "description": "Filesystem type.",
      "sourceType": "io.quarkus.kubernetes.deployment.AwsElasticBlockStoreVolumeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "readOnly",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.aws-elastic-block-store-volumes.{*}.read-only",
      "description": "Wether the volumeName is read only or not.",
      "sourceType": "io.quarkus.kubernetes.deployment.AwsElasticBlockStoreVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "shareName",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.openshift.azure-file-volumes.{*}.share-name",
      "description": "The share name.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureFileVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "secretName",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.openshift.azure-file-volumes.{*}.secret-name",
      "description": "The secret name.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureFileVolumeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "readOnly",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.azure-file-volumes.{*}.read-only",
      "description": "Wether the volumeName is read only or not.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureFileVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "diskName",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.openshift.azure-disk-volumes.{*}.disk-name",
      "description": "The name of the disk to mount.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "diskURI",
      "extensionName": "quarkus-kubernetes",
      "required": true,
      "phase": 1,
      "name": "quarkus.openshift.azure-disk-volumes.{*}.disk-uri",
      "description": "The URI of the vhd blob object OR the resourceID of an Azure managed data disk if Kind is Managed",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig"
    },
    {
      "type": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig.Kind",
      "sourceField": "kind",
      "defaultValue": "Managed",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.openshift.azure-disk-volumes.{*}.kind",
      "description": "Kind of disk.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig"
    },
    {
      "type": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig.CachingMode",
      "sourceField": "cachingMode",
      "defaultValue": "ReadWrite",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.openshift.azure-disk-volumes.{*}.caching-mode",
      "description": "Disk caching mode.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "fsType",
      "defaultValue": "ext4",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.azure-disk-volumes.{*}.fs-type",
      "description": "File system type.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "readOnly",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.azure-disk-volumes.{*}.read-only",
      "description": "Wether the volumeName is read only or not.",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "image",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.image",
      "description": "The container image.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.env-vars.{*}.name",
      "description": "The environment variable name.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "value",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.env-vars.{*}.value",
      "description": "The environment variable value.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "secret",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.env-vars.{*}.secret",
      "description": "The environment variable secret.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "configmap",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.env-vars.{*}.configmap",
      "description": "The environment variable config map.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "field",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.env-vars.{*}.field",
      "description": "The environment variable field.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "workingDir",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.working-dir",
      "description": "Working directory.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "command",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.command",
      "description": "The commands",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "arguments",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.arguments",
      "description": "The arguments\n\n@return The arguments.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "serviceAccount",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.service-account",
      "description": "The service account.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "host",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.host",
      "description": "The host under which the application is going to be exposed.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "containerPort",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.ports.{*}.container-port",
      "description": "The port number. Refers to the container port.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "hostPort",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.ports.{*}.host-port",
      "description": "The host port.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "defaultValue": "/",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.ports.{*}.path",
      "description": "The application path (refers to web application path).\n\n@return The path, defaults to /.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.Protocol",
      "sourceField": "protocol",
      "defaultValue": "TCP",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.openshift.init-containers.{*}.ports.{*}.protocol",
      "description": "The protocol.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.ImagePullPolicy",
      "sourceField": "imagePullPolicy",
      "defaultValue": "Always",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.openshift.init-containers.{*}.image-pull-policy",
      "description": "Image pull policy.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "imagePullSecrets",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.image-pull-secrets",
      "description": "The image pull secret",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.kubernetes.deployment.ProbeConfig\u003e",
      "sourceField": "livenessProbe",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.liveness-probe",
      "description": "The liveness probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.kubernetes.deployment.ProbeConfig\u003e",
      "sourceField": "readinessProbe",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.readiness-probe",
      "description": "The readiness probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.mounts.{*}.name",
      "description": "The name of the volumeName to mount.\n\n@return The name.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.mounts.{*}.path",
      "description": "The path to mount.\n\n@return The path.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "subPath",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.mounts.{*}.sub-path",
      "description": "Path within the volumeName from which the container\u0027s volumeName should be\nmounted.\n\n@return The subPath.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "boolean",
      "sourceField": "readOnly",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.init-containers.{*}.mounts.{*}.read-only",
      "description": "ReadOnly\n\n@return True if mount is readonly, False otherwise.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "image",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.image",
      "description": "The container image.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.env-vars.{*}.name",
      "description": "The environment variable name.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "value",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.env-vars.{*}.value",
      "description": "The environment variable value.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "secret",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.env-vars.{*}.secret",
      "description": "The environment variable secret.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "configmap",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.env-vars.{*}.configmap",
      "description": "The environment variable config map.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "field",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.env-vars.{*}.field",
      "description": "The environment variable field.",
      "sourceType": "io.quarkus.kubernetes.deployment.EnvConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "workingDir",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.working-dir",
      "description": "Working directory.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "command",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.command",
      "description": "The commands",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "arguments",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.arguments",
      "description": "The arguments\n\n@return The arguments.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "serviceAccount",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.service-account",
      "description": "The service account.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "host",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.host",
      "description": "The host under which the application is going to be exposed.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "containerPort",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.ports.{*}.container-port",
      "description": "The port number. Refers to the container port.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "hostPort",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.ports.{*}.host-port",
      "description": "The host port.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "defaultValue": "/",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.ports.{*}.path",
      "description": "The application path (refers to web application path).\n\n@return The path, defaults to /.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.Protocol",
      "sourceField": "protocol",
      "defaultValue": "TCP",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.openshift.containers.{*}.ports.{*}.protocol",
      "description": "The protocol.",
      "sourceType": "io.quarkus.kubernetes.deployment.PortConfig"
    },
    {
      "type": "io.dekorate.kubernetes.annotation.ImagePullPolicy",
      "sourceField": "imagePullPolicy",
      "defaultValue": "Always",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.openshift.containers.{*}.image-pull-policy",
      "description": "Image pull policy.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "imagePullSecrets",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.image-pull-secrets",
      "description": "The image pull secret",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.kubernetes.deployment.ProbeConfig\u003e",
      "sourceField": "livenessProbe",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.liveness-probe",
      "description": "The liveness probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.kubernetes.deployment.ProbeConfig\u003e",
      "sourceField": "readinessProbe",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.readiness-probe",
      "description": "The readiness probe.",
      "sourceType": "io.quarkus.kubernetes.deployment.ContainerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "name",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.mounts.{*}.name",
      "description": "The name of the volumeName to mount.\n\n@return The name.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.mounts.{*}.path",
      "description": "The path to mount.\n\n@return The path.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "subPath",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.mounts.{*}.sub-path",
      "description": "Path within the volumeName from which the container\u0027s volumeName should be\nmounted.\n\n@return The subPath.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "boolean",
      "sourceField": "readOnly",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.containers.{*}.mounts.{*}.read-only",
      "description": "ReadOnly\n\n@return True if mount is readonly, False otherwise.",
      "sourceType": "io.quarkus.kubernetes.deployment.MountConfig"
    },
    {
      "type": "boolean",
      "sourceField": "expose",
      "defaultValue": "false",
      "extensionName": "quarkus-kubernetes",
      "required": false,
      "phase": 1,
      "name": "quarkus.openshift.expose",
      "description": "If true, an Openshift Route will be created",
      "sourceType": "io.quarkus.kubernetes.deployment.OpenshiftConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "from",
      "extensionName": "quarkus-mailer",
      "required": false,
      "phase": 4,
      "name": "quarkus.mailer.from",
      "description": "Configure the default `from` attribute.\nIt\u0027s the sender email address.",
      "sourceType": "io.quarkus.mailer.runtime.MailConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Boolean\u003e",
      "sourceField": "mock",
      "extensionName": "quarkus-mailer",
      "required": false,
      "phase": 4,
      "name": "quarkus.mailer.mock",
      "description": "Enables the mock mode, not sending emails.\nThe content of the emails is printed on the console.\n\u003cp\u003e\nDisabled by default on PROD, enabled by default on DEV and TEST modes.",
      "sourceType": "io.quarkus.mailer.runtime.MailConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "bounceAddress",
      "extensionName": "quarkus-mailer",
      "required": false,
      "phase": 4,
      "name": "quarkus.mailer.bounce-address",
      "description": "Configures the default bounce email address.",
      "sourceType": "io.quarkus.mailer.runtime.MailConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "host",
      "defaultValue": "localhost",
      "extensionName": "quarkus-mailer",
      "required": false,
      "phase": 4,
      "name": "quarkus.mailer.host",
      "description": "The SMTP host name.",
      "sourceType": "io.quarkus.mailer.runtime.MailConfig"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "port",
      "extensionName": "quarkus-mailer",
      "required": false,
      "phase": 4,
      "name": "quarkus.mailer.port",
      "description": "The SMTP port.",
      "sourceType": "io.quarkus.mailer.runtime.MailConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "username",
      "extensionName": "quarkus-mailer",
      "required": false,
      "phase": 4,
      "name": "quarkus.mailer.username",
      "description": "The username.",
      "sourceType": "io.quarkus.mailer.runtime.MailConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "password",
      "extensionName": "quarkus-mailer",
      "required": false,
      "phase": 4,
      "name": "quarkus.mailer.password",
      "description": "The password.",
      "sourceType": "io.quarkus.mailer.runtime.MailConfig"
    },
    {
      "type": "boolean",
      "sourceField": "ssl",
      "defaultValue": "false",
      "extensionName": "quarkus-mailer",
      "required": false,
      "phase": 4,
      "name": "quarkus.mailer.ssl",
      "description": "Enables or disables the SSL on connect.\n{@code false} by default.",
      "sourceType": "io.quarkus.mailer.runtime.MailConfig"
    },
    {
      "type": "boolean",
      "sourceField": "trustAll",
      "defaultValue": "false",
      "extensionName": "quarkus-mailer",
      "required": false,
      "phase": 4,
      "name": "quarkus.mailer.trust-all",
      "description": "Set whether to trust all certificates on ssl connect the option is also\napplied to {@code STARTTLS} operation. {@code false} by default.",
      "sourceType": "io.quarkus.mailer.runtime.MailConfig"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "maxPoolSize",
      "extensionName": "quarkus-mailer",
      "required": false,
      "phase": 4,
      "name": "quarkus.mailer.max-pool-size",
      "description": "Configures the maximum allowed number of open connections to the mail server\nIf not set the default is {@code 10}.",
      "sourceType": "io.quarkus.mailer.runtime.MailConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "ownHostName",
      "extensionName": "quarkus-mailer",
      "required": false,
      "phase": 4,
      "name": "quarkus.mailer.own-host-name",
      "description": "The hostname to be used for HELO/EHLO and the Message-ID",
      "sourceType": "io.quarkus.mailer.runtime.MailConfig"
    },
    {
      "type": "boolean",
      "sourceField": "keepAlive",
      "defaultValue": "true",
      "extensionName": "quarkus-mailer",
      "required": false,
      "phase": 4,
      "name": "quarkus.mailer.keep-alive",
      "description": "Set if connection pool is enabled, {@code true} by default.\n\u003cp\u003e\nIf the connection pooling is disabled, the max number of sockets is enforced nevertheless.\n\u003cp\u003e",
      "sourceType": "io.quarkus.mailer.runtime.MailConfig"
    },
    {
      "type": "boolean",
      "sourceField": "disableEsmtp",
      "defaultValue": "false",
      "extensionName": "quarkus-mailer",
      "required": false,
      "phase": 4,
      "name": "quarkus.mailer.disable-esmtp",
      "description": "Disable ESMTP. {@code false} by default.\nThe RFC-1869 states that clients should always attempt {@code EHLO} as first command to determine if ESMTP\nis supported, if this returns an error code, {@code HELO} is tried to use the \u003cem\u003eregular\u003c/em\u003e SMTP command.",
      "sourceType": "io.quarkus.mailer.runtime.MailConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "startTLS",
      "extensionName": "quarkus-mailer",
      "required": false,
      "phase": 4,
      "name": "quarkus.mailer.start-tls",
      "description": "Set the TLS security mode for the connection.\nEither {@code DISABLED}, {@code OPTIONAL} or {@code REQUIRED}.",
      "sourceType": "io.quarkus.mailer.runtime.MailConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "login",
      "extensionName": "quarkus-mailer",
      "required": false,
      "phase": 4,
      "name": "quarkus.mailer.login",
      "description": "Set the login mode for the connection.\nEither {@code DISABLED}, {@code OPTIONAL} or {@code REQUIRED}",
      "sourceType": "io.quarkus.mailer.runtime.MailConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "authMethods",
      "extensionName": "quarkus-mailer",
      "required": false,
      "phase": 4,
      "name": "quarkus.mailer.auth-methods",
      "description": "Set the allowed auth methods.\nIf defined, only these methods will be used, if the server supports them.",
      "sourceType": "io.quarkus.mailer.runtime.MailConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "keyStore",
      "extensionName": "quarkus-mailer",
      "required": false,
      "phase": 4,
      "name": "quarkus.mailer.key-store",
      "description": "Set the key store.",
      "sourceType": "io.quarkus.mailer.runtime.MailConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "keyStorePassword",
      "extensionName": "quarkus-mailer",
      "required": false,
      "phase": 4,
      "name": "quarkus.mailer.key-store-password",
      "description": "Set the key store password.",
      "sourceType": "io.quarkus.mailer.runtime.MailConfig"
    },
    {
      "type": "boolean",
      "sourceField": "healthEnabled",
      "defaultValue": "true",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 1,
      "name": "quarkus.mongodb.health.enabled",
      "description": "Whether or not an health check is published in case the smallrye-health extension is present.",
      "sourceType": "io.quarkus.mongodb.deployment.MongoClientBuildTimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "metricsEnabled",
      "defaultValue": "false",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 1,
      "name": "quarkus.mongodb.metrics.enabled",
      "description": "Whether or not metrics are published in case the smallrye-metrics extension is present.",
      "sourceType": "io.quarkus.mongodb.deployment.MongoClientBuildTimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "connectionString",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.connection-string",
      "description": "Configures the connection string.\nThe format is:\n{@code  mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database.collection][?options]]}\n\u003cp\u003e\n{@code mongodb://} is a required prefix to identify that this is a string in the standard connection format.\n\u003cp\u003e\n{@code username:password@} are optional. If given, the driver will attempt to login to a database after\nconnecting to a database server. For some authentication mechanisms, only the username is specified and the\npassword is not, in which case the \":\" after the username is left off as well.\n\u003cp\u003e\n{@code host1} is the only required part of the connection string. It identifies a server address to connect to.\n\u003cp\u003e\n{@code :portX} is optional and defaults to :27017 if not provided.\n\u003cp\u003e\n{@code /database} is the name of the database to login to and thus is only relevant if the\n{@code username:password@} syntax is used. If not specified the {@code admin} database will be used by default.\n\u003cp\u003e\n{@code ?options} are connection options. Note that if {@code database} is absent there is still a {@code /}\nrequired between the last host and the {@code ?} introducing the options. Options are name\u003dvalue pairs and the\npairs are separated by \"\u0026amp;\".\n\u003cp\u003e\nAn alternative format, using the {@code mongodb+srv} protocol, is:\n\n\u003cpre\u003e\n mongodb+srv://[username:password@]host[/[database][?options]]\n\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e{@code mongodb+srv://} is a required prefix for this format.\u003c/li\u003e\n\u003cli\u003e{@code username:password@} are optional. If given, the driver will attempt to login to a database after\nconnecting to a database server. For some authentication mechanisms, only the username is specified and the\npassword is not, in which case the \":\" after the username is left off as well\u003c/li\u003e\n\u003cli\u003e{@code host} is the only required part of the URI. It identifies a single host name for which SRV records\nare looked up from a Domain Name Server after prefixing the host name with {@code \"_mongodb._tcp\"}. The\nhost/port for each SRV record becomes the seed list used to connect, as if each one were provided as host/port\npair in a URI using the normal mongodb protocol.\u003c/li\u003e\n\u003cli\u003e{@code /database} is the name of the database to login to and thus is only relevant if the\n{@code username:password@} syntax is used. If not specified the \"admin\" database will be used by default.\u003c/li\u003e\n\u003cli\u003e{@code ?options} are connection options. Note that if {@code database} is absent there is still a {@code /}\nrequired between the last host and the {@code ?} introducing the options. Options are name\u003dvalue pairs and the\npairs are separated by \"\u0026amp;\". Additionally with the mongodb+srv protocol, TXT records are looked up from a\nDomain Name Server for the given host, and the text value of each one is prepended to any options on the URI\nitself. Because the last specified value for any option wins, that means that options provided on the URI will\noverride any that are provided via TXT records.\u003c/li\u003e\n\u003c/ul\u003e",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.List\u003cjava.lang.String\u003e",
      "sourceField": "hosts",
      "defaultValue": "127.0.0.1:27017",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.hosts",
      "description": "Configures the MongoDB server addressed (one if single mode).\nThe addresses are passed as {@code host:port}.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "database",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.database",
      "description": "Configure the database name.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "applicationName",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.application-name",
      "description": "Configures the application name.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "maxPoolSize",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.max-pool-size",
      "description": "Configures the maximum number of connections in the connection pool.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "minPoolSize",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.min-pool-size",
      "description": "Configures the minimum number of connections in the connection pool.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "maxConnectionIdleTime",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.max-connection-idle-time",
      "description": "Maximum idle time of a pooled connection. A connection that exceeds this limit will be closed.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "maxConnectionLifeTime",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.max-connection-life-time",
      "description": "Maximum life time of a pooled connection. A connection that exceeds this limit will be closed.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "waitQueueTimeout",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.wait-queue-timeout",
      "description": "The maximum wait time that a thread may wait for a connection to become available.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "maintenanceFrequency",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.maintenance-frequency",
      "description": "Configures the time period between runs of the maintenance job.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "maintenanceInitialDelay",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.maintenance-initial-delay",
      "description": "Configures period of time to wait before running the first maintenance job on the connection pool.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "waitQueueMultiple",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.wait-queue-multiple",
      "description": "This multiplier, multiplied with the {@code maxPoolSize} setting, gives the maximum number of\nthreads that may be waiting for a connection to become available from the pool. All further threads will get an\nexception right away.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "connectTimeout",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.connect-timeout",
      "description": "How long a connection can take to be opened before timing out.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "readTimeout",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.read-timeout",
      "description": "How long a socket read can take before timing out.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "boolean",
      "sourceField": "tlsInsecure",
      "defaultValue": "false",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.tls-insecure",
      "description": "If connecting with TLS, this option enables insecure TLS connections.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "boolean",
      "sourceField": "tls",
      "defaultValue": "false",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.tls",
      "description": "Whether to connect using TLS.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "replicaSetName",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.replica-set-name",
      "description": "Implies that the hosts given are a seed list, and the driver will attempt to find all members of the set.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "serverSelectionTimeout",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.server-selection-timeout",
      "description": "How long the driver will wait for server selection to succeed before throwing an exception.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "localThreshold",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.local-threshold",
      "description": "When choosing among multiple MongoDB servers to send a request, the driver will only send that request to a\nserver whose ping time is less than or equal to the server with the fastest ping time plus the local threshold.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "heartbeatFrequency",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.heartbeat-frequency",
      "description": "The frequency that the driver will attempt to determine the current state of each server in the cluster.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "boolean",
      "sourceField": "safe",
      "defaultValue": "true",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.write-concern.safe",
      "description": "Configures the safety.\nIf set to {@code true}: the driver ensures that all writes are acknowledged by the MongoDB server, or else\nthrows an exception. (see also {@code w} and {@code wtimeoutMS}).\nIf set fo\n\u003cli\u003e{@code false}: the driver does not ensure that all writes are acknowledged by the MongoDB server.",
      "sourceType": "io.quarkus.mongodb.runtime.WriteConcernConfig"
    },
    {
      "type": "boolean",
      "sourceField": "journal",
      "defaultValue": "true",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.write-concern.journal",
      "description": "Configures the journal writing aspect.\nIf set to {@code true}: the driver waits for the server to group commit to the journal file on disk.\nIf set to {@code false}: the driver does not wait for the server to group commit to the journal file on disk.",
      "sourceType": "io.quarkus.mongodb.runtime.WriteConcernConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "w",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.write-concern.w",
      "description": "When set, the driver adds {@code w: wValue} to all write commands. It requires {@code safe} to be {@code true}.\nThe value is typically a number, but can also be the {@code majority} string.",
      "sourceType": "io.quarkus.mongodb.runtime.WriteConcernConfig"
    },
    {
      "type": "boolean",
      "sourceField": "retryWrites",
      "defaultValue": "false",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.write-concern.retry-writes",
      "description": "If set to {@code true}, the driver will retry supported write operations if they fail due to a network error.",
      "sourceType": "io.quarkus.mongodb.runtime.WriteConcernConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "wTimeout",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.write-concern.w-timeout",
      "description": "When set, the driver adds {@code wtimeout : ms } to all write commands. It requires {@code safe} to be\n{@code true}.",
      "sourceType": "io.quarkus.mongodb.runtime.WriteConcernConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "readPreference",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.read-preference",
      "description": "Configures the read preferences.\nSupported values are: {@code primary|primaryPreferred|secondary|secondaryPreferred|nearest}",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "username",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.credentials.username",
      "description": "Configures the username.",
      "sourceType": "io.quarkus.mongodb.runtime.CredentialConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "password",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.credentials.password",
      "description": "Configures the password.",
      "sourceType": "io.quarkus.mongodb.runtime.CredentialConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "authMechanism",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.credentials.auth-mechanism",
      "description": "Configures the authentication mechanism to use if a credential was supplied.\nThe default is unspecified, in which case the client will pick the most secure mechanism available based on the\nsever version. For the GSSAPI and MONGODB-X509 mechanisms, no password is accepted, only the username.\nSupported values: {@code MONGO-CR|GSSAPI|PLAIN|MONGODB-X509}",
      "sourceType": "io.quarkus.mongodb.runtime.CredentialConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "authSource",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.credentials.auth-source",
      "description": "Configures the source of the authentication credentials.\nThis is typically the database that the credentials have been created. The value defaults to the database\nspecified in the path portion of the connection string or in the \u0027database\u0027 configuration property..\nIf the database is specified in neither place, the default value is {@code admin}. This option is only\nrespected when using the MONGO-CR mechanism (the default).",
      "sourceType": "io.quarkus.mongodb.runtime.CredentialConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "authMechanismProperties",
      "extensionName": "quarkus-mongodb-client",
      "required": true,
      "phase": 4,
      "name": "quarkus.mongodb.credentials.auth-mechanism-properties.{*}",
      "description": "Allows passing authentication mechanism properties.",
      "sourceType": "io.quarkus.mongodb.runtime.CredentialConfig"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "maxWaitQueueSize",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.max-wait-queue-size",
      "description": "Configures the maximum number of concurrent operations allowed to wait for a server to become available.\nAll further operations will get an exception immediately.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "connectionString",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.connection-string",
      "description": "Configures the connection string.\nThe format is:\n{@code  mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database.collection][?options]]}\n\u003cp\u003e\n{@code mongodb://} is a required prefix to identify that this is a string in the standard connection format.\n\u003cp\u003e\n{@code username:password@} are optional. If given, the driver will attempt to login to a database after\nconnecting to a database server. For some authentication mechanisms, only the username is specified and the\npassword is not, in which case the \":\" after the username is left off as well.\n\u003cp\u003e\n{@code host1} is the only required part of the connection string. It identifies a server address to connect to.\n\u003cp\u003e\n{@code :portX} is optional and defaults to :27017 if not provided.\n\u003cp\u003e\n{@code /database} is the name of the database to login to and thus is only relevant if the\n{@code username:password@} syntax is used. If not specified the {@code admin} database will be used by default.\n\u003cp\u003e\n{@code ?options} are connection options. Note that if {@code database} is absent there is still a {@code /}\nrequired between the last host and the {@code ?} introducing the options. Options are name\u003dvalue pairs and the\npairs are separated by \"\u0026amp;\".\n\u003cp\u003e\nAn alternative format, using the {@code mongodb+srv} protocol, is:\n\n\u003cpre\u003e\n mongodb+srv://[username:password@]host[/[database][?options]]\n\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e{@code mongodb+srv://} is a required prefix for this format.\u003c/li\u003e\n\u003cli\u003e{@code username:password@} are optional. If given, the driver will attempt to login to a database after\nconnecting to a database server. For some authentication mechanisms, only the username is specified and the\npassword is not, in which case the \":\" after the username is left off as well\u003c/li\u003e\n\u003cli\u003e{@code host} is the only required part of the URI. It identifies a single host name for which SRV records\nare looked up from a Domain Name Server after prefixing the host name with {@code \"_mongodb._tcp\"}. The\nhost/port for each SRV record becomes the seed list used to connect, as if each one were provided as host/port\npair in a URI using the normal mongodb protocol.\u003c/li\u003e\n\u003cli\u003e{@code /database} is the name of the database to login to and thus is only relevant if the\n{@code username:password@} syntax is used. If not specified the \"admin\" database will be used by default.\u003c/li\u003e\n\u003cli\u003e{@code ?options} are connection options. Note that if {@code database} is absent there is still a {@code /}\nrequired between the last host and the {@code ?} introducing the options. Options are name\u003dvalue pairs and the\npairs are separated by \"\u0026amp;\". Additionally with the mongodb+srv protocol, TXT records are looked up from a\nDomain Name Server for the given host, and the text value of each one is prepended to any options on the URI\nitself. Because the last specified value for any option wins, that means that options provided on the URI will\noverride any that are provided via TXT records.\u003c/li\u003e\n\u003c/ul\u003e",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.List\u003cjava.lang.String\u003e",
      "sourceField": "hosts",
      "defaultValue": "127.0.0.1:27017",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.hosts",
      "description": "Configures the MongoDB server addressed (one if single mode).\nThe addresses are passed as {@code host:port}.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "database",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.database",
      "description": "Configure the database name.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "applicationName",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.application-name",
      "description": "Configures the application name.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "maxPoolSize",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.max-pool-size",
      "description": "Configures the maximum number of connections in the connection pool.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "minPoolSize",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.min-pool-size",
      "description": "Configures the minimum number of connections in the connection pool.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "maxConnectionIdleTime",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.max-connection-idle-time",
      "description": "Maximum idle time of a pooled connection. A connection that exceeds this limit will be closed.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "maxConnectionLifeTime",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.max-connection-life-time",
      "description": "Maximum life time of a pooled connection. A connection that exceeds this limit will be closed.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "waitQueueTimeout",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.wait-queue-timeout",
      "description": "The maximum wait time that a thread may wait for a connection to become available.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "maintenanceFrequency",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.maintenance-frequency",
      "description": "Configures the time period between runs of the maintenance job.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "maintenanceInitialDelay",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.maintenance-initial-delay",
      "description": "Configures period of time to wait before running the first maintenance job on the connection pool.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "waitQueueMultiple",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.wait-queue-multiple",
      "description": "This multiplier, multiplied with the {@code maxPoolSize} setting, gives the maximum number of\nthreads that may be waiting for a connection to become available from the pool. All further threads will get an\nexception right away.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "connectTimeout",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.connect-timeout",
      "description": "How long a connection can take to be opened before timing out.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "readTimeout",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.read-timeout",
      "description": "How long a socket read can take before timing out.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "boolean",
      "sourceField": "tlsInsecure",
      "defaultValue": "false",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.tls-insecure",
      "description": "If connecting with TLS, this option enables insecure TLS connections.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "boolean",
      "sourceField": "tls",
      "defaultValue": "false",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.tls",
      "description": "Whether to connect using TLS.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "replicaSetName",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.replica-set-name",
      "description": "Implies that the hosts given are a seed list, and the driver will attempt to find all members of the set.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "serverSelectionTimeout",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.server-selection-timeout",
      "description": "How long the driver will wait for server selection to succeed before throwing an exception.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "localThreshold",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.local-threshold",
      "description": "When choosing among multiple MongoDB servers to send a request, the driver will only send that request to a\nserver whose ping time is less than or equal to the server with the fastest ping time plus the local threshold.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "heartbeatFrequency",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.heartbeat-frequency",
      "description": "The frequency that the driver will attempt to determine the current state of each server in the cluster.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "boolean",
      "sourceField": "safe",
      "defaultValue": "true",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.write-concern.safe",
      "description": "Configures the safety.\nIf set to {@code true}: the driver ensures that all writes are acknowledged by the MongoDB server, or else\nthrows an exception. (see also {@code w} and {@code wtimeoutMS}).\nIf set fo\n\u003cli\u003e{@code false}: the driver does not ensure that all writes are acknowledged by the MongoDB server.",
      "sourceType": "io.quarkus.mongodb.runtime.WriteConcernConfig"
    },
    {
      "type": "boolean",
      "sourceField": "journal",
      "defaultValue": "true",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.write-concern.journal",
      "description": "Configures the journal writing aspect.\nIf set to {@code true}: the driver waits for the server to group commit to the journal file on disk.\nIf set to {@code false}: the driver does not wait for the server to group commit to the journal file on disk.",
      "sourceType": "io.quarkus.mongodb.runtime.WriteConcernConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "w",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.write-concern.w",
      "description": "When set, the driver adds {@code w: wValue} to all write commands. It requires {@code safe} to be {@code true}.\nThe value is typically a number, but can also be the {@code majority} string.",
      "sourceType": "io.quarkus.mongodb.runtime.WriteConcernConfig"
    },
    {
      "type": "boolean",
      "sourceField": "retryWrites",
      "defaultValue": "false",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.write-concern.retry-writes",
      "description": "If set to {@code true}, the driver will retry supported write operations if they fail due to a network error.",
      "sourceType": "io.quarkus.mongodb.runtime.WriteConcernConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "wTimeout",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.write-concern.w-timeout",
      "description": "When set, the driver adds {@code wtimeout : ms } to all write commands. It requires {@code safe} to be\n{@code true}.",
      "sourceType": "io.quarkus.mongodb.runtime.WriteConcernConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "readPreference",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.read-preference",
      "description": "Configures the read preferences.\nSupported values are: {@code primary|primaryPreferred|secondary|secondaryPreferred|nearest}",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "username",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.credentials.username",
      "description": "Configures the username.",
      "sourceType": "io.quarkus.mongodb.runtime.CredentialConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "password",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.credentials.password",
      "description": "Configures the password.",
      "sourceType": "io.quarkus.mongodb.runtime.CredentialConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "authMechanism",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.credentials.auth-mechanism",
      "description": "Configures the authentication mechanism to use if a credential was supplied.\nThe default is unspecified, in which case the client will pick the most secure mechanism available based on the\nsever version. For the GSSAPI and MONGODB-X509 mechanisms, no password is accepted, only the username.\nSupported values: {@code MONGO-CR|GSSAPI|PLAIN|MONGODB-X509}",
      "sourceType": "io.quarkus.mongodb.runtime.CredentialConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "authSource",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.credentials.auth-source",
      "description": "Configures the source of the authentication credentials.\nThis is typically the database that the credentials have been created. The value defaults to the database\nspecified in the path portion of the connection string or in the \u0027database\u0027 configuration property..\nIf the database is specified in neither place, the default value is {@code admin}. This option is only\nrespected when using the MONGO-CR mechanism (the default).",
      "sourceType": "io.quarkus.mongodb.runtime.CredentialConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "authMechanismProperties",
      "extensionName": "quarkus-mongodb-client",
      "required": true,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.credentials.auth-mechanism-properties.{*}",
      "description": "Allows passing authentication mechanism properties.",
      "sourceType": "io.quarkus.mongodb.runtime.CredentialConfig"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "maxWaitQueueSize",
      "extensionName": "quarkus-mongodb-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.mongodb.{*}.max-wait-queue-size",
      "description": "Configures the maximum number of concurrent operations allowed to wait for a server to become available.\nAll further operations will get an exception immediately.",
      "sourceType": "io.quarkus.mongodb.runtime.MongoClientConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "nodeName",
      "defaultValue": "quarkus",
      "extensionName": "quarkus-narayana-jta",
      "required": false,
      "phase": 4,
      "name": "quarkus.transaction-manager.node-name",
      "description": "The node name used by the transaction manager",
      "sourceType": "io.quarkus.narayana.jta.runtime.TransactionManagerConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "defaultTransactionTimeout",
      "defaultValue": "60",
      "extensionName": "quarkus-narayana-jta",
      "required": false,
      "phase": 4,
      "name": "quarkus.transaction-manager.default-transaction-timeout",
      "description": "The default transaction timeout",
      "sourceType": "io.quarkus.narayana.jta.runtime.TransactionManagerConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "healthEnabled",
      "defaultValue": "true",
      "extensionName": "quarkus-neo4j",
      "required": false,
      "phase": 1,
      "name": "quarkus.neo4j.health.enabled",
      "description": "Whether or not an health check is published in case the smallrye-health extension is present.",
      "sourceType": "io.quarkus.neo4j.deployment.Neo4jBuildTimeConfig"
    },
    {
      "type": "java.util.List\u003cjava.lang.String\u003e",
      "sourceField": "suffixes",
      "defaultValue": "qute.html,qute.txt,html,txt",
      "extensionName": "quarkus-qute",
      "required": false,
      "phase": 2,
      "name": "quarkus.qute.suffixes",
      "description": "The set of suffixes used when attempting to locate a template file.\n\nBy default, `engine.getTemplate(\"foo\")` would result in several lookups: `foo`, `foo.html`, `foo.txt`, etc.\n\n@asciidoclet",
      "sourceType": "io.quarkus.qute.runtime.QuteConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Boolean\u003e",
      "sourceField": "cachePreparedStatements",
      "extensionName": "quarkus-reactive-pg-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.reactive.postgresql.cache-prepared-statements",
      "description": "Whether prepared statements should be cached on the client side.",
      "sourceType": "io.quarkus.reactive.pg.client.runtime.DataSourceReactivePostgreSQLConfig"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "pipeliningLimit",
      "extensionName": "quarkus-reactive-pg-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.reactive.postgresql.pipelining-limit",
      "description": "The maximum number of inflight database commands that can be pipelined.",
      "sourceType": "io.quarkus.reactive.pg.client.runtime.DataSourceReactivePostgreSQLConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Boolean\u003e",
      "sourceField": "cachePreparedStatements",
      "extensionName": "quarkus-reactive-pg-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.reactive-pg-client.cache-prepared-statements",
      "description": "@deprecated use quarkus.datasource.reactive.postgresql.cache-prepared-statements instead.",
      "sourceType": "io.quarkus.reactive.pg.client.runtime.LegacyDataSourceReactivePostgreSQLConfig"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "pipeliningLimit",
      "extensionName": "quarkus-reactive-pg-client",
      "required": false,
      "phase": 4,
      "name": "quarkus.reactive-pg-client.pipelining-limit",
      "description": "@deprecated use quarkus.datasource.reactive.postgresql.pipelining-limit instead.",
      "sourceType": "io.quarkus.reactive.pg.client.runtime.LegacyDataSourceReactivePostgreSQLConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enabled",
      "defaultValue": "true",
      "extensionName": "quarkus-reactive-datasource",
      "required": false,
      "phase": 2,
      "name": "quarkus.datasource.reactive",
      "description": "If we create a Reactive datasource for this datasource.",
      "sourceType": "io.quarkus.reactive.datasource.runtime.DataSourceReactiveBuildTimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "url",
      "extensionName": "quarkus-reactive-datasource",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.reactive.url",
      "description": "The datasource URL.",
      "sourceType": "io.quarkus.reactive.datasource.runtime.DataSourceReactiveRuntimeConfig"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "maxSize",
      "extensionName": "quarkus-reactive-datasource",
      "required": false,
      "phase": 4,
      "name": "quarkus.datasource.reactive.max-size",
      "description": "The datasource pool maximum size.",
      "sourceType": "io.quarkus.reactive.datasource.runtime.DataSourceReactiveRuntimeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "uri",
      "defaultValue": "bolt://localhost:7687",
      "extensionName": "quarkus-neo4j",
      "required": false,
      "phase": 4,
      "name": "quarkus.neo4j.uri",
      "description": "The uri this driver should connect to. The driver supports bolt, bolt+routing or neo4j as schemes.",
      "sourceType": "io.quarkus.neo4j.runtime.Neo4jConfiguration"
    },
    {
      "type": "java.lang.String",
      "sourceField": "username",
      "defaultValue": "neo4j",
      "extensionName": "quarkus-neo4j",
      "required": false,
      "phase": 4,
      "name": "quarkus.neo4j.authentication.username",
      "description": "The login of the user connecting to the database.",
      "sourceType": "io.quarkus.neo4j.runtime.Neo4jConfiguration.Authentication"
    },
    {
      "type": "java.lang.String",
      "sourceField": "password",
      "defaultValue": "neo4j",
      "extensionName": "quarkus-neo4j",
      "required": false,
      "phase": 4,
      "name": "quarkus.neo4j.authentication.password",
      "description": "The password of the user connecting to the database.",
      "sourceType": "io.quarkus.neo4j.runtime.Neo4jConfiguration.Authentication"
    },
    {
      "type": "boolean",
      "sourceField": "disabled",
      "defaultValue": "false",
      "extensionName": "quarkus-neo4j",
      "required": false,
      "phase": 4,
      "name": "quarkus.neo4j.authentication.disabled",
      "description": "Set this to true to disable authentication.",
      "sourceType": "io.quarkus.neo4j.runtime.Neo4jConfiguration.Authentication"
    },
    {
      "type": "boolean",
      "sourceField": "metricsEnabled",
      "defaultValue": "false",
      "extensionName": "quarkus-neo4j",
      "required": false,
      "phase": 4,
      "name": "quarkus.neo4j.pool.metrics-enabled",
      "description": "Flag, if metrics are enabled.",
      "sourceType": "io.quarkus.neo4j.runtime.Neo4jConfiguration.Pool"
    },
    {
      "type": "boolean",
      "sourceField": "logLeakedSessions",
      "defaultValue": "false",
      "extensionName": "quarkus-neo4j",
      "required": false,
      "phase": 4,
      "name": "quarkus.neo4j.pool.log-leaked-sessions",
      "description": "Flag, if leaked sessions logging is enabled.",
      "sourceType": "io.quarkus.neo4j.runtime.Neo4jConfiguration.Pool"
    },
    {
      "type": "int",
      "sourceField": "maxConnectionPoolSize",
      "defaultValue": "100",
      "extensionName": "quarkus-neo4j",
      "required": false,
      "phase": 4,
      "name": "quarkus.neo4j.pool.max-connection-pool-size",
      "description": "The maximum amount of connections in the connection pool towards a single database.",
      "sourceType": "io.quarkus.neo4j.runtime.Neo4jConfiguration.Pool"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "idleTimeBeforeConnectionTest",
      "defaultValue": "-0.001S",
      "extensionName": "quarkus-neo4j",
      "required": false,
      "phase": 4,
      "name": "quarkus.neo4j.pool.idle-time-before-connection-test",
      "description": "Pooled connections that have been idle in the pool for longer than this timeout will be tested before they are used\nagain. The value {@literal 0} means connections will always be tested for validity and negative values mean\nconnections\nwill never be tested.",
      "sourceType": "io.quarkus.neo4j.runtime.Neo4jConfiguration.Pool"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "maxConnectionLifetime",
      "defaultValue": "1H",
      "extensionName": "quarkus-neo4j",
      "required": false,
      "phase": 4,
      "name": "quarkus.neo4j.pool.max-connection-lifetime",
      "description": "Pooled connections older than this threshold will be closed and removed from the pool.",
      "sourceType": "io.quarkus.neo4j.runtime.Neo4jConfiguration.Pool"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "connectionAcquisitionTimeout",
      "defaultValue": "1M",
      "extensionName": "quarkus-neo4j",
      "required": false,
      "phase": 4,
      "name": "quarkus.neo4j.pool.connection-acquisition-timeout",
      "description": "Acquisition of new connections will be attempted for at most configured timeout.",
      "sourceType": "io.quarkus.neo4j.runtime.Neo4jConfiguration.Pool"
    },
    {
      "type": "boolean",
      "sourceField": "enabled",
      "defaultValue": "true",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 1,
      "name": "quarkus.oidc.enabled",
      "description": "If the OIDC extension is enabled.",
      "sourceType": "io.quarkus.oidc.runtime.OidcBuildTimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "tenantId",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.tenant-id",
      "description": "A unique tenant identifier. It must be set by {@code TenantConfigResolver} providers which\nresolve the tenant configuration dynamically and is optional in all other cases.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig"
    },
    {
      "type": "boolean",
      "sourceField": "tenantEnabled",
      "defaultValue": "true",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.tenant-enabled",
      "description": "If this tenant configuration is enabled.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig"
    },
    {
      "type": "io.quarkus.oidc.runtime.OidcTenantConfig.ApplicationType",
      "sourceField": "applicationType",
      "defaultValue": "service",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.oidc.application-type",
      "description": "The application type, which can be one of the following values from enum {@link ApplicationType}.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "connectionDelay",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.connection-delay",
      "description": "The maximum amount of time the adapter will try connecting to the currently unavailable OIDC server for.\nFor example, setting it to \u002720S\u0027 will let the adapter keep requesting the connection for up to 20 seconds.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "authServerUrl",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.auth-server-url",
      "description": "The base URL of the OpenID Connect (OIDC) server, for example, \u0027https://host:port/auth\u0027.\nAll the other OIDC server page and service URLs are derived from this URL.\nNote if you work with Keycloak OIDC server, make sure the base URL is in the following format:\n\u0027https://host:port/auth/realms/{realm}\u0027 where \u0027{realm}\u0027 has to be replaced by the name of the Keycloak realm.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "introspectionPath",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.introspection-path",
      "description": "Relative path of the RFC7662 introspection service.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "jwksPath",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.jwks-path",
      "description": "Relative path of the OIDC service returning a JWK set.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "publicKey",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.public-key",
      "description": "Public key for the local JWT token verification.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "clientId",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.client-id",
      "description": "The client-id of the application. Each application has a client-id that is used to identify the application",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "roleClaimPath",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.roles.role-claim-path",
      "description": "Path to the claim containing an array of groups. It starts from the top level JWT JSON object and\ncan contain multiple segments where each segment represents a JSON object name only, example: \"realm/groups\".\nUse double quotes with the namespace qualified claim names.\nThis property can be used if a token has no \u0027groups\u0027 claim but has the groups set in a different claim.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Roles"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "roleClaimSeparator",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.roles.role-claim-separator",
      "description": "Separator for splitting a string which may contain multiple group values.\nIt will only be used if the \"role-claim-path\" property points to a custom claim whose value is a string.\nA single space will be used by default because the standard \u0027scope\u0027 claim may contain a space separated sequence.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Roles"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "issuer",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.token.issuer",
      "description": "Expected issuer \u0027iss\u0027 claim value.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Token"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "audience",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.token.audience",
      "description": "Expected audience \u0027aud\u0027 claim value which may be a string or an array of strings.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Token"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "expirationGrace",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.token.expiration-grace",
      "description": "Expiration grace period in seconds. A token expiration time will be reduced by\nthe value of this property before being compared to the current time.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Token"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "principalClaim",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.token.principal-claim",
      "description": "Name of the claim which contains a principal name. By default, the \u0027upn\u0027, \u0027preferred_username\u0027 and `sub` claims are\nchecked.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Token"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "secret",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.credentials.secret",
      "description": "Client secret which is used for a \u0027client_secret_basic\u0027 authentication method.\nNote that a \u0027client-secret\u0027 can be used instead but both properties are mutually exclusive.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Credentials"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "value",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.credentials.client-secret.value",
      "description": "The client secret",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Credentials.Secret"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.oidc.runtime.OidcTenantConfig.Credentials.Secret.Method\u003e",
      "sourceField": "method",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.oidc.credentials.client-secret.method",
      "description": "Authentication method.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Credentials.Secret"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "redirectPath",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.authentication.redirect-path",
      "description": "Relative path for calculating a \"redirect_uri\" query parameter.\nIt has to start from a forward slash and will be appended to the request URI\u0027s host and port.\nFor example, if the current request URI is \u0027https://localhost:8080/service\u0027 then a \u0027redirect_uri\u0027 parameter\nwill be set to \u0027https://localhost:8080/\u0027 if this property is set to \u0027/\u0027 and be the same as the request URI\nif this property has not been configured.\nNote the original request URI will be restored after the user has authenticated.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Authentication"
    },
    {
      "type": "boolean",
      "sourceField": "restorePathAfterRedirect",
      "defaultValue": "true",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.authentication.restore-path-after-redirect",
      "description": "If this property is set to \u0027true\u0027 then the original request URI which was used before\nthe authentication will be restored after the user has been redirected back to the application.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Authentication"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "scopes",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.authentication.scopes",
      "description": "List of scopes",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Authentication"
    },
    {
      "type": "java.lang.String",
      "sourceField": "extraParams",
      "extensionName": "quarkus-oidc",
      "required": true,
      "phase": 4,
      "name": "quarkus.oidc.authentication.extra-params.{*}",
      "description": "Additional properties which will be added as the query parameters to the authentication redirect URI.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Authentication"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "cookiePath",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.authentication.cookie-path",
      "description": "Cookie path parameter value which, if set, will be used for the session and state cookies.\nIt may need to be set when the redirect path has a root different to that of the original request URL.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Authentication"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "tenantId",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.{*}.tenant-id",
      "description": "A unique tenant identifier. It must be set by {@code TenantConfigResolver} providers which\nresolve the tenant configuration dynamically and is optional in all other cases.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig"
    },
    {
      "type": "boolean",
      "sourceField": "tenantEnabled",
      "defaultValue": "true",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.{*}.tenant-enabled",
      "description": "If this tenant configuration is enabled.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig"
    },
    {
      "type": "io.quarkus.oidc.runtime.OidcTenantConfig.ApplicationType",
      "sourceField": "applicationType",
      "defaultValue": "service",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.oidc.{*}.application-type",
      "description": "The application type, which can be one of the following values from enum {@link ApplicationType}.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "connectionDelay",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.{*}.connection-delay",
      "description": "The maximum amount of time the adapter will try connecting to the currently unavailable OIDC server for.\nFor example, setting it to \u002720S\u0027 will let the adapter keep requesting the connection for up to 20 seconds.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "authServerUrl",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.{*}.auth-server-url",
      "description": "The base URL of the OpenID Connect (OIDC) server, for example, \u0027https://host:port/auth\u0027.\nAll the other OIDC server page and service URLs are derived from this URL.\nNote if you work with Keycloak OIDC server, make sure the base URL is in the following format:\n\u0027https://host:port/auth/realms/{realm}\u0027 where \u0027{realm}\u0027 has to be replaced by the name of the Keycloak realm.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "introspectionPath",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.{*}.introspection-path",
      "description": "Relative path of the RFC7662 introspection service.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "jwksPath",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.{*}.jwks-path",
      "description": "Relative path of the OIDC service returning a JWK set.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "publicKey",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.{*}.public-key",
      "description": "Public key for the local JWT token verification.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "clientId",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.{*}.client-id",
      "description": "The client-id of the application. Each application has a client-id that is used to identify the application",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "roleClaimPath",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.{*}.roles.role-claim-path",
      "description": "Path to the claim containing an array of groups. It starts from the top level JWT JSON object and\ncan contain multiple segments where each segment represents a JSON object name only, example: \"realm/groups\".\nUse double quotes with the namespace qualified claim names.\nThis property can be used if a token has no \u0027groups\u0027 claim but has the groups set in a different claim.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Roles"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "roleClaimSeparator",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.{*}.roles.role-claim-separator",
      "description": "Separator for splitting a string which may contain multiple group values.\nIt will only be used if the \"role-claim-path\" property points to a custom claim whose value is a string.\nA single space will be used by default because the standard \u0027scope\u0027 claim may contain a space separated sequence.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Roles"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "issuer",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.{*}.token.issuer",
      "description": "Expected issuer \u0027iss\u0027 claim value.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Token"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "audience",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.{*}.token.audience",
      "description": "Expected audience \u0027aud\u0027 claim value which may be a string or an array of strings.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Token"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "expirationGrace",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.{*}.token.expiration-grace",
      "description": "Expiration grace period in seconds. A token expiration time will be reduced by\nthe value of this property before being compared to the current time.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Token"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "principalClaim",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.{*}.token.principal-claim",
      "description": "Name of the claim which contains a principal name. By default, the \u0027upn\u0027, \u0027preferred_username\u0027 and `sub` claims are\nchecked.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Token"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "secret",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.{*}.credentials.secret",
      "description": "Client secret which is used for a \u0027client_secret_basic\u0027 authentication method.\nNote that a \u0027client-secret\u0027 can be used instead but both properties are mutually exclusive.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Credentials"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "value",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.{*}.credentials.client-secret.value",
      "description": "The client secret",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Credentials.Secret"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.oidc.runtime.OidcTenantConfig.Credentials.Secret.Method\u003e",
      "sourceField": "method",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.oidc.{*}.credentials.client-secret.method",
      "description": "Authentication method.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Credentials.Secret"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "redirectPath",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.{*}.authentication.redirect-path",
      "description": "Relative path for calculating a \"redirect_uri\" query parameter.\nIt has to start from a forward slash and will be appended to the request URI\u0027s host and port.\nFor example, if the current request URI is \u0027https://localhost:8080/service\u0027 then a \u0027redirect_uri\u0027 parameter\nwill be set to \u0027https://localhost:8080/\u0027 if this property is set to \u0027/\u0027 and be the same as the request URI\nif this property has not been configured.\nNote the original request URI will be restored after the user has authenticated.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Authentication"
    },
    {
      "type": "boolean",
      "sourceField": "restorePathAfterRedirect",
      "defaultValue": "true",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.{*}.authentication.restore-path-after-redirect",
      "description": "If this property is set to \u0027true\u0027 then the original request URI which was used before\nthe authentication will be restored after the user has been redirected back to the application.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Authentication"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "scopes",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.{*}.authentication.scopes",
      "description": "List of scopes",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Authentication"
    },
    {
      "type": "java.lang.String",
      "sourceField": "extraParams",
      "extensionName": "quarkus-oidc",
      "required": true,
      "phase": 4,
      "name": "quarkus.oidc.{*}.authentication.extra-params.{*}",
      "description": "Additional properties which will be added as the query parameters to the authentication redirect URI.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Authentication"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "cookiePath",
      "extensionName": "quarkus-oidc",
      "required": false,
      "phase": 4,
      "name": "quarkus.oidc.{*}.authentication.cookie-path",
      "description": "Cookie path parameter value which, if set, will be used for the session and state cookies.\nIt may need to be set when the redirect path has a root different to that of the original request URL.",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Authentication"
    },
    {
      "type": "boolean",
      "sourceField": "singletonResources",
      "defaultValue": "true",
      "extensionName": "quarkus-resteasy-server-common",
      "required": false,
      "phase": 1,
      "name": "quarkus.resteasy.singleton-resources",
      "description": "If this is true then JAX-RS will use only a single instance of a resource\nclass to service all requests.\n\u003cp\u003e\nIf this is false then it will create a new instance of the resource per\nrequest.\n\u003cp\u003e\nIf the resource class has an explicit CDI scope annotation then the value of\nthis annotation will always be used to control the lifecycle of the resource\nclass.\n\u003cp\u003e\nIMPLEMENTATION NOTE: {@code javax.ws.rs.Path} turns into a CDI stereotype\nwith singleton scope. As a result, if a user annotates a JAX-RS resource with\na stereotype which has a different default scope the deployment fails with\nIllegalStateException.",
      "sourceType": "io.quarkus.resteasy.server.common.deployment.ResteasyServerCommonProcessor.ResteasyConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "path",
      "defaultValue": "/",
      "extensionName": "quarkus-resteasy-server-common",
      "required": false,
      "phase": 1,
      "name": "quarkus.resteasy.path",
      "description": "Set this to override the default path for JAX-RS resources if there are no\nannotated application classes.",
      "sourceType": "io.quarkus.resteasy.server.common.deployment.ResteasyServerCommonProcessor.ResteasyConfig"
    },
    {
      "type": "boolean",
      "sourceField": "metricsEnabled",
      "defaultValue": "false",
      "extensionName": "quarkus-resteasy-server-common",
      "required": false,
      "phase": 1,
      "name": "quarkus.resteasy.metrics.enabled",
      "description": "Whether or not JAX-RS metrics should be enabled if the Metrics capability is present and Vert.x is being used.",
      "sourceType": "io.quarkus.resteasy.server.common.deployment.ResteasyServerCommonProcessor.ResteasyConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enabled",
      "defaultValue": "false",
      "extensionName": "quarkus-resteasy-common",
      "required": false,
      "phase": 1,
      "name": "quarkus.resteasy.gzip.enabled",
      "description": "If gzip is enabled",
      "sourceType": "io.quarkus.resteasy.common.deployment.ResteasyCommonProcessor.ResteasyCommonConfigGzip"
    },
    {
      "type": "io.quarkus.runtime.configuration.MemorySize",
      "sourceField": "maxInput",
      "defaultValue": "10M",
      "extensionName": "quarkus-resteasy-common",
      "required": false,
      "phase": 1,
      "name": "quarkus.resteasy.gzip.max-input",
      "description": "Maximum deflated file bytes size\n\u003cp\u003e\nIf the limit is exceeded, Resteasy will return Response\nwith status 413(\"Request Entity Too Large\")",
      "sourceType": "io.quarkus.resteasy.common.deployment.ResteasyCommonProcessor.ResteasyCommonConfigGzip"
    },
    {
      "type": "boolean",
      "sourceField": "denyJaxRs",
      "defaultValue": "false",
      "extensionName": "quarkus-resteasy",
      "required": false,
      "phase": 2,
      "name": "quarkus.security.jaxrs.deny-unannotated-endpoints",
      "description": "if set to true, access to all JAX-RS resources will be denied by default",
      "sourceType": "io.quarkus.resteasy.runtime.JaxRsSecurityConfig"
    },
    {
      "type": "com.cronutils.model.CronType",
      "sourceField": "cronType",
      "defaultValue": "quartz",
      "extensionName": "quarkus-scheduler",
      "required": false,
      "phase": 2,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.scheduler.cron-type",
      "description": "The syntax used in CRON expressions.\n\n@see Scheduled#cron()",
      "sourceType": "io.quarkus.scheduler.runtime.SchedulerConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "securityProviders",
      "extensionName": "quarkus-security",
      "required": false,
      "phase": 1,
      "name": "quarkus.security.security-providers",
      "description": "List of security providers to enable for reflection",
      "sourceType": "io.quarkus.security.deployment.SecurityConfig"
    },
    {
      "type": "boolean",
      "sourceField": "denyUnannotated",
      "defaultValue": "false",
      "extensionName": "quarkus-security",
      "required": false,
      "phase": 2,
      "name": "quarkus.security.deny-unannotated-members",
      "description": "If set to true, access to all methods of beans that have any security annotations on other members will be denied by\ndefault.\nE.g. if enabled, in the following bean, \u003ccode\u003emethodB\u003c/code\u003e will be denied.\n\n\u003cpre\u003e\n  {@literal @}ApplicationScoped\n  public class A {\n     {@literal @}RolesAllowed(\"admin\")\n     public void methodA() {\n         ...\n     }\n     public void methodB() {\n         ...\n     }\n  }\n\u003c/pre\u003e",
      "sourceType": "io.quarkus.security.runtime.SecurityBuildTimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enabled",
      "defaultValue": "true",
      "extensionName": "quarkus-smallrye-jwt",
      "required": false,
      "phase": 1,
      "name": "quarkus.smallrye-jwt.enabled",
      "description": "The MP-JWT configuration object",
      "sourceType": "io.quarkus.smallrye.jwt.deployment.SmallryeJWTConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "rsaSigProvider",
      "defaultValue": "SunRsaSign",
      "extensionName": "quarkus-smallrye-jwt",
      "required": false,
      "phase": 1,
      "name": "quarkus.smallrye-jwt.rsa-sig-provider",
      "description": "The name of the {@linkplain java.security.Provider} that supports SHA256withRSA signatures",
      "sourceType": "io.quarkus.smallrye.jwt.deployment.SmallryeJWTConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "path",
      "defaultValue": "/openapi",
      "extensionName": "quarkus-smallrye-openapi-common",
      "required": false,
      "phase": 1,
      "name": "quarkus.smallrye-openapi.path",
      "description": "The path at which to register the OpenAPI Servlet.",
      "sourceType": "io.quarkus.smallrye.openapi.common.deployment.SmallRyeOpenApiConfig"
    },
    {
      "type": "boolean",
      "sourceField": "extensionsEnabled",
      "defaultValue": "true",
      "extensionName": "quarkus-smallrye-health",
      "required": false,
      "phase": 1,
      "name": "quarkus.health.extensions.enabled",
      "description": "Whether or not extensions published health check should be enabled.",
      "sourceType": "io.quarkus.smallrye.health.deployment.HealthBuildTimeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "rootPath",
      "defaultValue": "/health",
      "extensionName": "quarkus-smallrye-health",
      "required": false,
      "phase": 1,
      "name": "quarkus.smallrye-health.root-path",
      "description": "Root path for health-checking servlets.",
      "sourceType": "io.quarkus.smallrye.health.deployment.SmallRyeHealthProcessor.SmallRyeHealthConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "livenessPath",
      "defaultValue": "/live",
      "extensionName": "quarkus-smallrye-health",
      "required": false,
      "phase": 1,
      "name": "quarkus.smallrye-health.liveness-path",
      "description": "The relative path of the liveness health-checking servlet.",
      "sourceType": "io.quarkus.smallrye.health.deployment.SmallRyeHealthProcessor.SmallRyeHealthConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "readinessPath",
      "defaultValue": "/ready",
      "extensionName": "quarkus-smallrye-health",
      "required": false,
      "phase": 1,
      "name": "quarkus.smallrye-health.readiness-path",
      "description": "The relative path of the readiness health-checking servlet.",
      "sourceType": "io.quarkus.smallrye.health.deployment.SmallRyeHealthProcessor.SmallRyeHealthConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "path",
      "defaultValue": "/metrics",
      "extensionName": "quarkus-smallrye-metrics",
      "required": false,
      "phase": 1,
      "name": "quarkus.smallrye-metrics.path",
      "description": "The path to the metrics handler.",
      "sourceType": "io.quarkus.smallrye.metrics.deployment.SmallRyeMetricsProcessor.SmallRyeMetricsConfig"
    },
    {
      "type": "boolean",
      "sourceField": "extensionsEnabled",
      "defaultValue": "true",
      "extensionName": "quarkus-smallrye-metrics",
      "required": false,
      "phase": 1,
      "name": "quarkus.smallrye-metrics.extensions.enabled",
      "description": "Whether or not metrics published by Quarkus extensions should be enabled.",
      "sourceType": "io.quarkus.smallrye.metrics.deployment.SmallRyeMetricsProcessor.SmallRyeMetricsConfig"
    },
    {
      "type": "boolean",
      "sourceField": "micrometerCompatibility",
      "defaultValue": "false",
      "extensionName": "quarkus-smallrye-metrics",
      "required": false,
      "phase": 1,
      "name": "quarkus.smallrye-metrics.micrometer.compatibility",
      "description": "Apply Micrometer compatibility mode, where instead of regular \u0027base\u0027 and \u0027vendor\u0027 metrics,\nQuarkus exposes the same \u0027jvm\u0027 metrics that Micrometer does. Application metrics are unaffected by this mode.\nThe use case is to facilitate migration from Micrometer-based metrics, because original dashboards for JVM metrics\nwill continue working without having to rewrite them.",
      "sourceType": "io.quarkus.smallrye.metrics.deployment.SmallRyeMetricsProcessor.SmallRyeMetricsConfig"
    },
    {
      "type": "boolean",
      "sourceField": "strict",
      "defaultValue": "false",
      "extensionName": "quarkus-smallrye-reactive-messaging",
      "required": false,
      "phase": 2,
      "name": "quarkus.reactive-messaging.strict",
      "description": "Enables or disables the \u003cem\u003estrict\u003c/em\u003e mode.",
      "sourceType": "io.quarkus.smallrye.reactivemessaging.runtime.ReactiveMessagingConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "metricsEnabled",
      "defaultValue": "false",
      "extensionName": "quarkus-smallrye-reactive-messaging",
      "required": false,
      "phase": 2,
      "name": "quarkus.reactive-messaging.metrics.enabled",
      "description": "Whether or not Reactive Messaging metrics are published in case the smallrye-metrics extension is present\n(default to false).",
      "sourceType": "io.quarkus.smallrye.reactivemessaging.runtime.ReactiveMessagingConfiguration"
    },
    {
      "type": "java.lang.String",
      "sourceField": "path",
      "defaultValue": "/swagger-ui",
      "extensionName": "quarkus-swagger-ui",
      "required": false,
      "phase": 1,
      "name": "quarkus.swagger-ui.path",
      "description": "The path where Swagger UI is available.\n\u003cp\u003e\nThe value `/` is not allowed as it blocks the application from serving anything else.",
      "sourceType": "io.quarkus.swaggerui.deployment.SwaggerUiProcessor.SwaggerUiConfig"
    },
    {
      "type": "boolean",
      "sourceField": "alwaysInclude",
      "defaultValue": "false",
      "extensionName": "quarkus-swagger-ui",
      "required": false,
      "phase": 1,
      "name": "quarkus.swagger-ui.always-include",
      "description": "If this should be included every time. By default this is only included when the application is running\nin dev mode.",
      "sourceType": "io.quarkus.swaggerui.deployment.SwaggerUiProcessor.SwaggerUiConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enable",
      "defaultValue": "true",
      "extensionName": "quarkus-swagger-ui",
      "required": false,
      "phase": 1,
      "name": "quarkus.swagger-ui.enable",
      "description": "If Swagger UI should be enabled. By default, Swagger UI is enabled.",
      "sourceType": "io.quarkus.swaggerui.deployment.SwaggerUiProcessor.SwaggerUiConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "tikaConfigPath",
      "extensionName": "quarkus-tika",
      "required": false,
      "phase": 2,
      "name": "quarkus.tika.tika-config-path",
      "description": "The resource path within the application artifact to the {@code tika-config.xml} file.",
      "sourceType": "io.quarkus.tika.runtime.TikaConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "parsers",
      "extensionName": "quarkus-tika",
      "required": false,
      "phase": 2,
      "name": "quarkus.tika.parsers",
      "description": "Comma separated list of the parsers which must be supported.\n\u003cp\u003e\nMost of the document formats recognized by Apache Tika are supported by default but it affects\nthe application memory and native executable sizes. One can list only the required parsers in\n{@code tika-config.xml} to minimize a number of parsers loaded into the memory, but using this\nproperty is recommended to achieve both optimizations.\n\u003cp\u003e\nEither the abbreviated or full parser class names can be used.\nOnly PDF and OpenDocument format parsers can be listed using the reserved \u0027pdf\u0027 and \u0027odf\u0027 abbreviations.\nCustom class name abbreviations have to be used for all other parsers.\nFor example:\n\n\u003cpre\u003e\n// Only PDF parser is required:\nquarkus.tika.parsers \u003d pdf\n// Only PDF and OpenDocument parsers are required:\nquarkus.tika.parsers \u003d pdf,odf\n\u003c/pre\u003e\n\nThis property will have no effect if the `tikaConfigPath\u0027 property has been set.",
      "sourceType": "io.quarkus.tika.runtime.TikaConfiguration"
    },
    {
      "type": "java.lang.String",
      "sourceField": "parserOptions",
      "extensionName": "quarkus-tika",
      "required": true,
      "phase": 2,
      "name": "quarkus.tika.parser-options.{*}.{*}",
      "description": "Configuration of the individual parsers.\nFor example:\n\n\u003cpre\u003e\nquarkus.tika.parsers \u003d pdf,odf\nquarkus.tika.parser-options.pdf.sort-by-position \u003d true",
      "sourceType": "io.quarkus.tika.runtime.TikaConfiguration"
    },
    {
      "type": "java.lang.String",
      "sourceField": "parser",
      "extensionName": "quarkus-tika",
      "required": true,
      "phase": 2,
      "name": "quarkus.tika.parser.{*}",
      "description": "Full parser class name for a given parser abbreviation.\nFor example:\n\n\u003cpre\u003e\nquarkus.tika.parsers \u003d classparser\nquarkus.tika.parser.classparser \u003d org.apache.tika.parser.asm.ClassParser",
      "sourceType": "io.quarkus.tika.runtime.TikaConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "appendEmbeddedContent",
      "defaultValue": "true",
      "extensionName": "quarkus-tika",
      "required": false,
      "phase": 2,
      "name": "quarkus.tika.append-embedded-content",
      "description": "Controls how the content of the embedded documents is parsed.\nBy default it is appended to the master document content.\nSetting this property to false makes the content of each of the embedded documents\navailable separately.",
      "sourceType": "io.quarkus.tika.runtime.TikaConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "password",
      "defaultValue": "\u003c\u003cno default\u003e\u003e",
      "extensionName": "quarkus-undertow-websockets",
      "required": false,
      "phase": 1,
      "name": "quarkus.hot-reload.password",
      "sourceType": "io.quarkus.undertow.websockets.deployment.UndertowWebsocketProcessor.HotReloadConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "url",
      "defaultValue": "\u003c\u003cno default\u003e\u003e",
      "extensionName": "quarkus-undertow-websockets",
      "required": false,
      "phase": 1,
      "name": "quarkus.hot-reload.url",
      "sourceType": "io.quarkus.undertow.websockets.deployment.UndertowWebsocketProcessor.HotReloadConfig"
    },
    {
      "type": "int",
      "sourceField": "maxFrameSize",
      "defaultValue": "65536",
      "extensionName": "quarkus-undertow-websockets",
      "required": false,
      "phase": 1,
      "name": "quarkus.websocket.max-frame-size",
      "description": "The maximum amount of data that can be sent in a single frame.\n\nMessages larger than this must be broken up into continuation frames.",
      "sourceType": "io.quarkus.undertow.websockets.deployment.WebsocketConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "contextPath",
      "extensionName": "quarkus-undertow",
      "required": false,
      "phase": 1,
      "name": "quarkus.servlet.context-path",
      "description": "The context path to serve all Servlet context from. This will also affect any resources\nthat run as a Servlet, e.g. JAX-RS.\n\nNote that this is relative to the HTTP root path set in quarkus.http.root-path, so if the context path\nis /bar and the http root is /foo then the actual Servlet path will be /foo/bar.",
      "sourceType": "io.quarkus.undertow.deployment.ServletConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "defaultCharset",
      "defaultValue": "UTF-8",
      "extensionName": "quarkus-undertow",
      "required": false,
      "phase": 1,
      "name": "quarkus.servlet.default-charset",
      "description": "The default charset to use for reading and writing requests",
      "sourceType": "io.quarkus.undertow.deployment.ServletConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "rootPath",
      "defaultValue": "/",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 2,
      "name": "quarkus.http.root-path",
      "description": "The HTTP root path. All web content will be served relative to this root path.",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpBuildTimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "basic",
      "defaultValue": "false",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 2,
      "name": "quarkus.http.auth.basic",
      "description": "If basic auth should be enabled. If both basic and form auth is enabled then basic auth will be enabled in silent mode.\n\nIf no authentication mechanisms are configured basic auth is the default.",
      "sourceType": "io.quarkus.vertx.http.runtime.AuthConfig"
    },
    {
      "type": "boolean",
      "sourceField": "enabled",
      "defaultValue": "false",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 2,
      "name": "quarkus.http.auth.form.enabled",
      "description": "If form authentication is enabled",
      "sourceType": "io.quarkus.vertx.http.runtime.FormAuthConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "loginPage",
      "defaultValue": "/login.html",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 2,
      "name": "quarkus.http.auth.form.login-page",
      "description": "The login page",
      "sourceType": "io.quarkus.vertx.http.runtime.FormAuthConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "errorPage",
      "defaultValue": "/error.html",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 2,
      "name": "quarkus.http.auth.form.error-page",
      "description": "The error page",
      "sourceType": "io.quarkus.vertx.http.runtime.FormAuthConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "landingPage",
      "defaultValue": "/index.html",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 2,
      "name": "quarkus.http.auth.form.landing-page",
      "description": "The landing page to redirect to if there is no saved page to redirect back to",
      "sourceType": "io.quarkus.vertx.http.runtime.FormAuthConfig"
    },
    {
      "type": "boolean",
      "sourceField": "redirectAfterLogin",
      "defaultValue": "true",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 2,
      "name": "quarkus.http.auth.form.redirect-after-login",
      "description": "Option to disable redirect to landingPage if there is no saved page to redirect back to. Form Auth POST is followed\nby redirect to landingPage by default.",
      "sourceType": "io.quarkus.vertx.http.runtime.FormAuthConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "timeout",
      "defaultValue": "PT30M",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 2,
      "name": "quarkus.http.auth.form.timeout",
      "description": "The inactivity (idle) timeout\n\nWhen inactivity timeout is reached, cookie is not renewed and a new login is enforced.",
      "sourceType": "io.quarkus.vertx.http.runtime.FormAuthConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "newCookieInterval",
      "defaultValue": "PT1M",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 2,
      "name": "quarkus.http.auth.form.new-cookie-interval",
      "description": "How old a cookie can get before it will be replaced with a new cookie with an updated timeout, also\nreferred to as \"renewal-timeout\".\n\nNote that smaller values will result in slightly more server load (as new encrypted cookies will be\ngenerated more often), however larger values affect the inactivity timeout as the timeout is set\nwhen a cookie is generated.\n\nFor example if this is set to 10 minutes, and the inactivity timeout is 30m, if a users last request\nis when the cookie is 9m old then the actual timeout will happen 21m after the last request, as the timeout\nis only refreshed when a new cookie is generated.\n\nIn other words no timeout is tracked on the server side; the timestamp is encoded and encrypted in the cookie itself\nand it is decrypted and parsed with each request.",
      "sourceType": "io.quarkus.vertx.http.runtime.FormAuthConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "cookieName",
      "defaultValue": "quarkus-credential",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 2,
      "name": "quarkus.http.auth.form.cookie-name",
      "description": "The cookie that is used to store the persistent session",
      "sourceType": "io.quarkus.vertx.http.runtime.FormAuthConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "realm",
      "defaultValue": "Quarkus",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 2,
      "name": "quarkus.http.auth.realm",
      "description": "The authentication realm",
      "sourceType": "io.quarkus.vertx.http.runtime.AuthConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "policy",
      "extensionName": "quarkus-vertx-http",
      "required": true,
      "phase": 2,
      "name": "quarkus.http.auth.permission.{*}.policy",
      "description": "The HTTP policy that this permission set is linked to.\n\nThere are 3 built in policies: permit, deny and authenticated. Role based\npolicies can be defined, and extensions can add their own policies.",
      "sourceType": "io.quarkus.vertx.http.runtime.PolicyMappingConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "methods",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 2,
      "name": "quarkus.http.auth.permission.{*}.methods",
      "description": "The methods that this permission set applies to. If this is not set then they apply to all methods.\n\nNote that if a request matches any path from any permission set, but does not match the constraint\ndue to the method not being listed then the request will be denied.\n\nMethod specific permissions take precedence over matches that do not have any methods set.\n\nThis means that for example if Quarkus is configured to allow GET and POST requests to /admin to\nand no other permissions are configured PUT requests to /admin will be denied.",
      "sourceType": "io.quarkus.vertx.http.runtime.PolicyMappingConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "paths",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 2,
      "name": "quarkus.http.auth.permission.{*}.paths",
      "description": "The paths that this permission check applies to. If the path ends in /* then this is treated\nas a path prefix, otherwise it is treated as an exact match.\n\nMatches are done on a length basis, so the most specific path match takes precedence.\n\nIf multiple permission sets match the same path then explicit methods matches take precedence\nover over matches without methods set, otherwise the most restrictive permissions are applied.",
      "sourceType": "io.quarkus.vertx.http.runtime.PolicyMappingConfig"
    },
    {
      "type": "java.util.List\u003cjava.lang.String\u003e",
      "sourceField": "rolesAllowed",
      "extensionName": "quarkus-vertx-http",
      "required": true,
      "phase": 2,
      "name": "quarkus.http.auth.policy.{*}.roles-allowed",
      "description": "The roles that are allowed to access resources protected by this policy",
      "sourceType": "io.quarkus.vertx.http.runtime.PolicyConfig"
    },
    {
      "type": "boolean",
      "sourceField": "virtual",
      "defaultValue": "false",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 2,
      "name": "quarkus.http.virtual",
      "description": "If this is true then only a virtual channel will be set up for vertx web.\nWe have this switch for testing purposes.",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpBuildTimeConfig"
    },
    {
      "type": "boolean",
      "sourceField": "corsEnabled",
      "defaultValue": "false",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.cors",
      "description": "Enable the CORS filter.",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration"
    },
    {
      "type": "int",
      "sourceField": "port",
      "defaultValue": "8080",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.port",
      "description": "The HTTP port",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration"
    },
    {
      "type": "int",
      "sourceField": "testPort",
      "defaultValue": "8081",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.test-port",
      "description": "The HTTP port used to run tests",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration"
    },
    {
      "type": "java.lang.String",
      "sourceField": "host",
      "defaultValue": "0.0.0.0",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.host",
      "description": "The HTTP host",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "hostEnabled",
      "defaultValue": "true",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.host-enabled",
      "description": "Enable listening to host:port",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration"
    },
    {
      "type": "int",
      "sourceField": "sslPort",
      "defaultValue": "8443",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.ssl-port",
      "description": "The HTTPS port",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration"
    },
    {
      "type": "int",
      "sourceField": "testSslPort",
      "defaultValue": "8444",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.test-ssl-port",
      "description": "The HTTPS port used to run tests",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "proxyAddressForwarding",
      "defaultValue": "false",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.proxy-address-forwarding",
      "description": "If this is true then the address, scheme etc will be set from headers forwarded by the proxy server, such as\n{@code X-Forwarded-For}. This should only be set if you are behind a proxy that sets these headers.",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "allowForwarded",
      "defaultValue": "false",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.allow-forwarded",
      "description": "If this is true and proxy address forwarding is enabled then the standard {@code Forwarded} header will be used,\nrather than the more common but not standard {@code X-Forwarded-For}.",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration"
    },
    {
      "type": "io.quarkus.vertx.http.runtime.HttpConfiguration.InsecureRequests",
      "sourceField": "insecureRequests",
      "defaultValue": "enabled",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.http.insecure-requests",
      "description": "If insecure (i.e. http rather than https) requests are allowed. If this is {@code enabled}\nthen http works as normal. {@code redirect} will still open the http port, but\nall requests will be redirected to the HTTPS port. {@code disabled} will prevent the HTTP\nport from opening at all.",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "origins",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.cors.origins",
      "description": "Origins allowed for CORS\n\nComma separated list of valid URLs. ex: http://www.quarkus.io,http://localhost:3000\nThe filter allows any origin if this is not set.\n\ndefault: returns any requested origin as valid",
      "sourceType": "io.quarkus.vertx.http.runtime.cors.CORSConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cio.vertx.core.http.HttpMethod\u003e\u003e",
      "sourceField": "methods",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.cors.methods",
      "description": "HTTP methods allowed for CORS\n\nComma separated list of valid methods. ex: GET,PUT,POST\nThe filter allows any method if this is not set.\n\ndefault: returns any requested method as valid",
      "sourceType": "io.quarkus.vertx.http.runtime.cors.CORSConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "headers",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.cors.headers",
      "description": "HTTP headers allowed for CORS\n\nComma separated list of valid headers. ex: X-Custom,Content-Disposition\nThe filter allows any header if this is not set.\n\ndefault: returns any requested header as valid",
      "sourceType": "io.quarkus.vertx.http.runtime.cors.CORSConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "exposedHeaders",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.cors.exposed-headers",
      "description": "HTTP headers exposed in CORS\n\nComma separated list of valid headers. ex: X-Custom,Content-Disposition\n\ndefault: empty",
      "sourceType": "io.quarkus.vertx.http.runtime.cors.CORSConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "accessControlMaxAge",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.cors.access-control-max-age",
      "description": "The `Access-Control-Max-Age` response header value indicating\nhow long the results of a pre-flight request can be cached.",
      "sourceType": "io.quarkus.vertx.http.runtime.cors.CORSConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.nio.file.Path\u003e",
      "sourceField": "file",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.ssl.certificate.file",
      "description": "The file path to a server certificate or certificate chain in PEM format.",
      "sourceType": "io.quarkus.vertx.http.runtime.CertificateConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.nio.file.Path\u003e",
      "sourceField": "keyFile",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.ssl.certificate.key-file",
      "description": "The file path to the corresponding certificate private key file in PEM format.",
      "sourceType": "io.quarkus.vertx.http.runtime.CertificateConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.nio.file.Path\u003e",
      "sourceField": "keyStoreFile",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.ssl.certificate.key-store-file",
      "description": "An optional key store which holds the certificate information instead of specifying separate files.",
      "sourceType": "io.quarkus.vertx.http.runtime.CertificateConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "keyStoreFileType",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.ssl.certificate.key-store-file-type",
      "description": "An optional parameter to specify type of the key store file. If not given, the type is automatically detected\nbased on the file name.",
      "sourceType": "io.quarkus.vertx.http.runtime.CertificateConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "keyStorePassword",
      "defaultValue": "password",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.ssl.certificate.key-store-password",
      "description": "A parameter to specify the password of the key store file. If not given, the default (\"password\") is used.",
      "sourceType": "io.quarkus.vertx.http.runtime.CertificateConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.nio.file.Path\u003e",
      "sourceField": "trustStoreFile",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.ssl.certificate.trust-store-file",
      "description": "An optional trust store which holds the certificate information of the certificates to trust",
      "sourceType": "io.quarkus.vertx.http.runtime.CertificateConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "trustStoreFileType",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.ssl.certificate.trust-store-file-type",
      "description": "An optional parameter to specify type of the trust store file. If not given, the type is automatically detected\nbased on the file name.",
      "sourceType": "io.quarkus.vertx.http.runtime.CertificateConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "trustStorePassword",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.ssl.certificate.trust-store-password",
      "description": "A parameter to specify the password of the trust store file.",
      "sourceType": "io.quarkus.vertx.http.runtime.CertificateConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.util.List\u003cjava.lang.String\u003e\u003e",
      "sourceField": "cipherSuites",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.ssl.cipher-suites",
      "description": "The cipher suites to use. If none is given, a reasonable default is selected.",
      "sourceType": "io.quarkus.vertx.http.runtime.ServerSslConfig"
    },
    {
      "type": "java.util.List\u003cjava.lang.String\u003e",
      "sourceField": "protocols",
      "defaultValue": "TLSv1.3,TLSv1.2",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.ssl.protocols",
      "description": "The list of protocols to explicitly enable.",
      "sourceType": "io.quarkus.vertx.http.runtime.ServerSslConfig"
    },
    {
      "type": "io.vertx.core.http.ClientAuth",
      "sourceField": "clientAuth",
      "defaultValue": "NONE",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "converterKinds": [
        1,
        2
      ],
      "name": "quarkus.http.ssl.client-auth",
      "description": "Configures the engine to require/request client authentication.\nNONE, REQUEST, REQUIRED",
      "sourceType": "io.quarkus.vertx.http.runtime.ServerSslConfig"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "ioThreads",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.io-threads",
      "description": "The number if IO threads used to perform IO. This will be automatically set to a reasonable value based on\nthe number of CPU cores if it is not provided. If this is set to a higher value than the number of Vert.x event\nloops then it will be capped at the number of event loops.\n\nIn general this should be controlled by setting quarkus.vertx.event-loops-pool-size, this setting should only\nbe used if you want to limit the number of HTTP io threads to a smaller number than the total number of IO threads.",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration"
    },
    {
      "type": "io.quarkus.runtime.configuration.MemorySize",
      "sourceField": "maxHeaderSize",
      "defaultValue": "20K",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.limits.max-header-size",
      "description": "The maximum length of all headers.",
      "sourceType": "io.quarkus.vertx.http.runtime.ServerLimitsConfig"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.runtime.configuration.MemorySize\u003e",
      "sourceField": "maxBodySize",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.limits.max-body-size",
      "description": "The maximum size of a request body.\nDefault: no limit.",
      "sourceType": "io.quarkus.vertx.http.runtime.ServerLimitsConfig"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.runtime.configuration.MemorySize\u003e",
      "sourceField": "maxChunkSize",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.limits.max-chunk-size",
      "description": "The max HTTP chunk size",
      "sourceType": "io.quarkus.vertx.http.runtime.ServerLimitsConfig"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "idleTimeout",
      "defaultValue": "30M",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.idle-timeout",
      "description": "Http connection idle timeout",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "readTimeout",
      "defaultValue": "60s",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.read-timeout",
      "description": "Http connection read timeout for blocking IO. This is the maximum amount of time\na thread will wait for data, before an IOException will be thrown and the connection\nclosed.",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "handleFileUploads",
      "defaultValue": "true",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.body.handle-file-uploads",
      "description": "Whether the files sent using {@code multipart/form-data} will be stored locally.\n\u003cp\u003e\nIf {@code true}, they will be stored in {@code quarkus.http.body-handler.uploads-directory} and will be made\navailable via {@code io.vertx.ext.web.RoutingContext.fileUploads()}. Otherwise, the the files sent using\n{@code multipart/form-data} will not be stored locally, and {@code io.vertx.ext.web.RoutingContext.fileUploads()}\nwill always return an empty collection. Note that even with this option being set to {@code false}, the\n{@code multipart/form-data} requests will be accepted.",
      "sourceType": "io.quarkus.vertx.http.runtime.BodyConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "uploadsDirectory",
      "defaultValue": "file-uploads",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.body.uploads-directory",
      "description": "The directory where the files sent using {@code multipart/form-data} should be stored.\n\u003cp\u003e\nEither an absolute path or a path relative to the current directory of the application process.",
      "sourceType": "io.quarkus.vertx.http.runtime.BodyConfig"
    },
    {
      "type": "boolean",
      "sourceField": "mergeFormAttributes",
      "defaultValue": "true",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.body.merge-form-attributes",
      "description": "Whether the form attributes should be added to the request parameters.\n\u003cp\u003e\nIf {@code true}, the form attributes will be added to the request parameters; otherwise the form parameters will\nnot be added to the request parameters",
      "sourceType": "io.quarkus.vertx.http.runtime.BodyConfig"
    },
    {
      "type": "boolean",
      "sourceField": "deleteUploadedFilesOnEnd",
      "defaultValue": "false",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.body.delete-uploaded-files-on-end",
      "description": "Whether the uploaded files should be removed after serving the request.\n\u003cp\u003e\nIf {@code true} the uploaded files stored in {@code quarkus.http.body-handler.uploads-directory} will be removed\nafter handling the request. Otherwise the files will be left there forever.",
      "sourceType": "io.quarkus.vertx.http.runtime.BodyConfig"
    },
    {
      "type": "boolean",
      "sourceField": "preallocateBodyBuffer",
      "defaultValue": "false",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.body.preallocate-body-buffer",
      "description": "Whether the body buffer should pre-allocated based on the {@code Content-Length} header value.\n\u003cp\u003e\nIf {@code true} the body buffer is pre-allocated according to the size read from the {@code Content-Length}\nheader. Otherwise the body buffer is pre-allocated to 1KB, and is resized dynamically",
      "sourceType": "io.quarkus.vertx.http.runtime.BodyConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "encryptionKey",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.auth.session.encryption-key",
      "description": "The encryption key that is used to store persistent logins (e.g. for form auth). Logins are stored in a persistent\ncookie that is encrypted with AES-256 using a key derived from a SHA-256 hash of the key that is provided here.\n\nIf no key is provided then an in-memory one will be generated, this will change on every restart though so it\nis not suitable for production environments. This must be more than 16 characters long for security reasons",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "soReusePort",
      "defaultValue": "false",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.so-reuse-port",
      "description": "Enable socket reuse port (linux/macOs native transport only)",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "tcpQuickAck",
      "defaultValue": "false",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.tcp-quick-ack",
      "description": "Enable tcp quick ack (linux native transport only)",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "tcpCork",
      "defaultValue": "false",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.tcp-cork",
      "description": "Enable tcp cork (linux native transport only)",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "tcpFastOpen",
      "defaultValue": "false",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.tcp-fast-open",
      "description": "Enable tcp fast open (linux native transport only)",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration"
    },
    {
      "type": "java.lang.String",
      "sourceField": "domainSocket",
      "defaultValue": "/var/run/io.quarkus.app.socket",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.domain-socket",
      "description": "Path to a unix domain socket",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "domainSocketEnabled",
      "defaultValue": "false",
      "extensionName": "quarkus-vertx-http",
      "required": false,
      "phase": 4,
      "name": "quarkus.http.domain-socket-enabled",
      "description": "Enable listening to host:port",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "mpJwtPublicKey",
      "defaultValue": "NONE",
      "required": false,
      "phase": 0,
      "name": "mp.jwt.verify.publickey",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "java.lang.String",
      "sourceField": "mpJwtIssuer",
      "defaultValue": "NONE",
      "required": false,
      "phase": 0,
      "name": "mp.jwt.verify.issuer",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "mpJwtLocation",
      "defaultValue": "NONE",
      "required": false,
      "phase": 0,
      "name": "mp.jwt.verify.publickey.location",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Boolean\u003e",
      "sourceField": "mpJwtRequireIss",
      "defaultValue": "true",
      "required": false,
      "phase": 0,
      "name": "mp.jwt.verify.requireiss",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "java.lang.String",
      "sourceField": "tokenHeader",
      "defaultValue": "Authorization",
      "required": false,
      "phase": 0,
      "name": "smallrye.jwt.token.header",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "tokenCookie",
      "required": true,
      "phase": 0,
      "name": "smallrye.jwt.token.cookie",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "boolean",
      "sourceField": "alwaysCheckAuthorization",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "smallrye.jwt.always-check-authorization",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "tokenKeyId",
      "required": true,
      "phase": 0,
      "name": "smallrye.jwt.token.kid",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "tokenSchemes",
      "defaultValue": "Bearer",
      "required": false,
      "phase": 0,
      "name": "smallrye.jwt.token.schemes",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Boolean\u003e",
      "sourceField": "requireNamedPrincipal",
      "defaultValue": "false",
      "required": false,
      "phase": 0,
      "name": "smallrye.jwt.require.named-principal",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "defaultSubClaim",
      "required": true,
      "phase": 0,
      "name": "smallrye.jwt.claims.sub",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "subPath",
      "required": true,
      "phase": 0,
      "name": "smallrye.jwt.path.sub",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "defaultGroupsClaim",
      "required": true,
      "phase": 0,
      "name": "smallrye.jwt.claims.groups",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "groupsPath",
      "required": true,
      "phase": 0,
      "name": "smallrye.jwt.path.groups",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "java.lang.String",
      "sourceField": "groupsSeparator",
      "defaultValue": " ",
      "required": false,
      "phase": 0,
      "name": "smallrye.jwt.groups-separator",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "expGracePeriodSecs",
      "defaultValue": "60",
      "required": false,
      "phase": 0,
      "name": "smallrye.jwt.expiration.grace",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Long\u003e",
      "sourceField": "maxTimeToLiveSecs",
      "required": true,
      "phase": 0,
      "name": "smallrye.jwt.time-to-live",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "jwksRefreshInterval",
      "defaultValue": "60",
      "required": false,
      "phase": 0,
      "name": "smallrye.jwt.jwks.refresh-interval",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "whitelistAlgorithms",
      "required": true,
      "phase": 0,
      "name": "smallrye.jwt.whitelist.algorithms",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "java.util.Optional\u003cio.smallrye.jwt.algorithm.SignatureAlgorithm\u003e",
      "sourceField": "signatureAlgorithm",
      "defaultValue": "RS256",
      "required": false,
      "phase": 0,
      "name": "smallrye.jwt.verify.algorithm",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "io.smallrye.jwt.KeyFormat",
      "sourceField": "keyFormat",
      "defaultValue": "ANY",
      "required": false,
      "phase": 0,
      "name": "smallrye.jwt.verify.key-format",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "java.util.Optional\u003cjava.util.Set\u003cjava.lang.String\u003e\u003e",
      "sourceField": "expectedAudience",
      "required": true,
      "phase": 0,
      "name": "smallrye.jwt.verify.aud",
      "sourceType": "io.smallrye.jwt.config.JWTAuthContextInfoProvider"
    },
    {
      "type": "java.lang.Integer",
      "sourceField": "configuredPort",
      "defaultValue": "5672",
      "required": false,
      "phase": 0,
      "name": "amqp-port",
      "sourceType": "io.smallrye.reactive.messaging.amqp.AmqpConnector"
    },
    {
      "type": "java.lang.String",
      "sourceField": "configuredHost",
      "defaultValue": "localhost",
      "required": false,
      "phase": 0,
      "name": "amqp-host",
      "sourceType": "io.smallrye.reactive.messaging.amqp.AmqpConnector"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "configuredUsername",
      "required": true,
      "phase": 0,
      "name": "amqp-username",
      "sourceType": "io.smallrye.reactive.messaging.amqp.AmqpConnector"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "configuredPassword",
      "required": true,
      "phase": 0,
      "name": "amqp-password",
      "sourceType": "io.smallrye.reactive.messaging.amqp.AmqpConnector"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Boolean\u003e",
      "sourceField": "configuredUseSsl",
      "required": true,
      "phase": 0,
      "name": "amqp-use-ssl",
      "sourceType": "io.smallrye.reactive.messaging.amqp.AmqpConnector"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "configuredReconnectAttempts",
      "defaultValue": "100",
      "required": false,
      "phase": 0,
      "name": "amqp-reconnect-attempts",
      "sourceType": "io.smallrye.reactive.messaging.amqp.AmqpConnector"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Long\u003e",
      "sourceField": "configuredReconnectInterval",
      "defaultValue": "10",
      "required": false,
      "phase": 0,
      "name": "amqp-reconnect-interval",
      "sourceType": "io.smallrye.reactive.messaging.amqp.AmqpConnector"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Integer\u003e",
      "sourceField": "configuredConnectTimeout",
      "defaultValue": "1000",
      "required": false,
      "phase": 0,
      "name": "amqp-connect-timeout",
      "sourceType": "io.smallrye.reactive.messaging.amqp.AmqpConnector"
    },
    {
      "type": "int",
      "sourceField": "defaultBufferSize",
      "defaultValue": "128",
      "required": false,
      "phase": 0,
      "name": "mp.messaging.emitter.default-buffer-size",
      "sourceType": "io.smallrye.reactive.messaging.extension.MediatorManager"
    },
    {
      "type": "int",
      "sourceField": "defaultBufferSizeLegacy",
      "defaultValue": "128",
      "required": false,
      "phase": 0,
      "name": "smallrye.messaging.emitter.default-buffer-size",
      "sourceType": "io.smallrye.reactive.messaging.extension.MediatorManager"
    },
    {
      "type": "boolean",
      "sourceField": "caching",
      "defaultValue": "true",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.caching",
      "description": "Enables or disables the Vert.x cache.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.VertxConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "classpathResolving",
      "defaultValue": "true",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.classpath-resolving",
      "description": "Enables or disabled the Vert.x classpath resource resolver.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.VertxConfiguration"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "eventLoopsPoolSize",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.event-loops-pool-size",
      "description": "The number of event loops. 2 x the number of core by default.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.VertxConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "maxEventLoopExecuteTime",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.max-event-loop-execute-time",
      "description": "The maximum amount of time the event loop can be blocked.\nDefault is 2s.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.VertxConfiguration"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "warningExceptionTime",
      "defaultValue": "2",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.warning-exception-time",
      "description": "The amount of time before a warning is displayed if the event loop is blocked.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.VertxConfiguration"
    },
    {
      "type": "int",
      "sourceField": "workerPoolSize",
      "defaultValue": "20",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.worker-pool-size",
      "description": "The size of the worker thread pool.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.VertxConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "maxWorkerExecuteTime",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.max-worker-execute-time",
      "description": "The maximum amount of time the worker thread can be blocked.\nDefault is 10s.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.VertxConfiguration"
    },
    {
      "type": "int",
      "sourceField": "internalBlockingPoolSize",
      "defaultValue": "20",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.internal-blocking-pool-size",
      "description": "The size of the internal thread pool (used for the file system).",
      "sourceType": "io.quarkus.vertx.core.runtime.config.VertxConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "useAsyncDNS",
      "defaultValue": "false",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.use-async-dns",
      "description": "Enables the async DNS resolver.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.VertxConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "keys",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.key-certificate-pem.keys",
      "description": "Comma-separated list of the path to the key files (Pem format).",
      "sourceType": "io.quarkus.vertx.core.runtime.config.PemKeyCertConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "certs",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.key-certificate-pem.certs",
      "description": "Comma-separated list of the path to the certificate files (Pem format).",
      "sourceType": "io.quarkus.vertx.core.runtime.config.PemKeyCertConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.key-certificate-jks.path",
      "description": "Path of the key file (JKS format).",
      "sourceType": "io.quarkus.vertx.core.runtime.config.JksConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "password",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.key-certificate-jks.password",
      "description": "Password of the key file.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.JksConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.key-certificate-pfx.path",
      "description": "Path to the key file (PFX format)",
      "sourceType": "io.quarkus.vertx.core.runtime.config.PfxConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "password",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.key-certificate-pfx.password",
      "description": "Password of the key.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.PfxConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "certs",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.trust-certificate-pem.certs",
      "description": "Comma-separated list of the trust certificate files (Pem format).",
      "sourceType": "io.quarkus.vertx.core.runtime.config.PemTrustCertConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.trust-certificate-jks.path",
      "description": "Path of the key file (JKS format).",
      "sourceType": "io.quarkus.vertx.core.runtime.config.JksConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "password",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.trust-certificate-jks.password",
      "description": "Password of the key file.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.JksConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "path",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.trust-certificate-pfx.path",
      "description": "Path to the key file (PFX format)",
      "sourceType": "io.quarkus.vertx.core.runtime.config.PfxConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "password",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.trust-certificate-pfx.password",
      "description": "Password of the key.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.PfxConfiguration"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "acceptBacklog",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.accept-backlog",
      "description": "The accept backlog.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.EventBusConfiguration"
    },
    {
      "type": "java.lang.String",
      "sourceField": "clientAuth",
      "defaultValue": "NONE",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.client-auth",
      "description": "The client authentication.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.EventBusConfiguration"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "connectTimeout",
      "defaultValue": "60",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.connect-timeout",
      "description": "The connect timeout.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.EventBusConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.time.Duration\u003e",
      "sourceField": "idleTimeout",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.idle-timeout",
      "description": "The idle timeout in milliseconds.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.EventBusConfiguration"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "receiveBufferSize",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.receive-buffer-size",
      "description": "The receive buffer size.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.EventBusConfiguration"
    },
    {
      "type": "int",
      "sourceField": "reconnectAttempts",
      "defaultValue": "0",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.reconnect-attempts",
      "description": "The number of reconnection attempts.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.EventBusConfiguration"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "reconnectInterval",
      "defaultValue": "1",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.reconnect-interval",
      "description": "The reconnection interval in milliseconds.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.EventBusConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "reuseAddress",
      "defaultValue": "true",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.reuse-address",
      "description": "Whether or not to reuse the address.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.EventBusConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "reusePort",
      "defaultValue": "false",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.reuse-port",
      "description": "Whether or not to reuse the port.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.EventBusConfiguration"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "sendBufferSize",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.send-buffer-size",
      "description": "The send buffer size.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.EventBusConfiguration"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "soLinger",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.soLinger",
      "description": "The so linger.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.EventBusConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "ssl",
      "defaultValue": "false",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.ssl",
      "description": "Enables or Disabled SSL.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.EventBusConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "tcpKeepAlive",
      "defaultValue": "false",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.tcp-keep-alive",
      "description": "Whether or not to keep the TCP connection opened (keep-alive).",
      "sourceType": "io.quarkus.vertx.core.runtime.config.EventBusConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "tcpNoDelay",
      "defaultValue": "true",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.tcp-no-delay",
      "description": "Configure the TCP no delay.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.EventBusConfiguration"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "trafficClass",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.traffic-class",
      "description": "Configure the traffic class.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.EventBusConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "trustAll",
      "defaultValue": "false",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.eventbus.trust-all",
      "description": "Enables or disables the trust all parameter.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.EventBusConfiguration"
    },
    {
      "type": "java.lang.String",
      "sourceField": "host",
      "defaultValue": "localhost",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.cluster.host",
      "description": "The host name.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.ClusterConfiguration"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "port",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.cluster.port",
      "description": "The port.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.ClusterConfiguration"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.String\u003e",
      "sourceField": "publicHost",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.cluster.public-host",
      "description": "The public host name.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.ClusterConfiguration"
    },
    {
      "type": "java.util.OptionalInt",
      "sourceField": "publicPort",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.cluster.public-port",
      "description": "The public port.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.ClusterConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "clustered",
      "defaultValue": "false",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.cluster.clustered",
      "description": "Enables or disables the clustering.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.ClusterConfiguration"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "pingInterval",
      "defaultValue": "20",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.cluster.ping-interval",
      "description": "The ping interval.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.ClusterConfiguration"
    },
    {
      "type": "java.time.Duration",
      "sourceField": "pingReplyInterval",
      "defaultValue": "20",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.cluster.ping-reply-interval",
      "description": "The ping reply interval.",
      "sourceType": "io.quarkus.vertx.core.runtime.config.ClusterConfiguration"
    },
    {
      "type": "boolean",
      "sourceField": "preferNativeTransport",
      "defaultValue": "false",
      "extensionName": "quarkus-vertx-core",
      "required": false,
      "phase": 4,
      "name": "quarkus.vertx.prefer-native-transport",
      "description": "Enable or disable native transport",
      "sourceType": "io.quarkus.vertx.core.runtime.config.VertxConfiguration"
    },
    {
      "type": "java.lang.Integer",
      "sourceField": "size",
      "defaultValue": "100",
      "required": false,
      "phase": 0,
      "name": "io.smallrye.faulttolerance.globalThreadPoolSize",
      "sourceType": "io.smallrye.faulttolerance.ExecutorProvider"
    },
    {
      "type": "java.lang.Integer",
      "sourceField": "timeoutExecutorSize",
      "defaultValue": "5",
      "required": false,
      "phase": 0,
      "name": "io.smallrye.faulttolerance.timeoutExecutorThreads",
      "sourceType": "io.smallrye.faulttolerance.ExecutorProvider"
    },
    {
      "type": "java.lang.Boolean",
      "sourceField": "metricsEnabled",
      "defaultValue": "true",
      "required": false,
      "phase": 0,
      "name": "MP_Fault_Tolerance_Metrics_Enabled",
      "sourceType": "io.smallrye.faulttolerance.metrics.MetricsCollectorFactory"
    },
    {
      "type": "java.lang.String",
      "sourceField": "servers",
      "defaultValue": "localhost:9092",
      "required": false,
      "phase": 0,
      "name": "kafka.bootstrap.servers",
      "sourceType": "io.smallrye.reactive.messaging.kafka.KafkaConnector"
    },
    {
      "type": "java.util.Optional\u003cio.quarkus.runtime.configuration.MemorySize\u003e",
      "sourceField": "bufferSize",
      "extensionName": "quarkus-undertow",
      "required": false,
      "phase": 4,
      "name": "quarkus.servlet.buffer-size",
      "description": "The buffer size to use for Servlet. If this is not specified the default will depend on the amount\nof available memory. If there is less than 64mb it will default to 512b heap buffer, less that 128mb\n1k direct buffer and otherwise 16k direct buffers.",
      "sourceType": "io.quarkus.undertow.runtime.ServletRuntimeConfig"
    },
    {
      "type": "java.util.Optional\u003cjava.lang.Boolean\u003e",
      "sourceField": "directBuffers",
      "extensionName": "quarkus-undertow",
      "required": false,
      "phase": 4,
      "name": "quarkus.servlet.direct-buffers",
      "description": "If Servlet should use direct buffers, this gives maximum performance but can be problematic\nin memory constrained environments",
      "sourceType": "io.quarkus.undertow.runtime.ServletRuntimeConfig"
    },
    {
      "type": "java.lang.String",
      "sourceField": "uncheckedExceptionDataStyle",
      "defaultValue": "rootCause",
      "required": false,
      "phase": 0,
      "name": "io.smallrye.health.uncheckedExceptionDataStyle",
      "sourceType": "io.smallrye.health.SmallRyeHealthReporter"
    },
    {
      "type": "java.lang.String",
      "sourceField": "emptyChecksOutcome",
      "defaultValue": "UP",
      "required": false,
      "phase": 0,
      "name": "io.smallrye.health.emptyChecksOutcome",
      "sourceType": "io.smallrye.health.SmallRyeHealthReporter"
    }
  ],
  "hints": [
    {
      "values": [
        {
          "value": "class-method",
          "description": "The provider for the default operation name."
        },
        {
          "value": "http-path",
          "description": "The operation name has the following form `\u003cHTTP method\u003e:\u003c@Path value of endpoints class\u003e/\u003c@Path value of endpoints method\u003e`. For example if the class is annotated with `@Path(\"service\")` and method `@Path(\"endpoint/{id: \\\\d+}\")` then the operation name is `GET:/service/endpoint/{id: \\\\d+}`."
        }
      ],
      "name": "mp.opentracing.server.operation-name-provider"
    },
    {
      "values": [
        {
          "value": "TCP"
        },
        {
          "value": "UDP"
        }
      ],
      "name": "io.dekorate.kubernetes.annotation.Protocol",
      "sourceType": "io.dekorate.kubernetes.annotation.Protocol"
    },
    {
      "values": [
        {
          "value": "Always"
        },
        {
          "value": "IfNotPresent"
        },
        {
          "value": "Never"
        }
      ],
      "name": "io.dekorate.kubernetes.annotation.ImagePullPolicy",
      "sourceType": "io.dekorate.kubernetes.annotation.ImagePullPolicy"
    },
    {
      "values": [
        {
          "value": "ClusterIP"
        },
        {
          "value": "NodePort"
        },
        {
          "value": "LoadBalancer"
        },
        {
          "value": "ExternalName"
        }
      ],
      "name": "io.dekorate.kubernetes.annotation.ServiceType",
      "sourceType": "io.dekorate.kubernetes.annotation.ServiceType"
    },
    {
      "values": [
        {
          "value": "ENABLED"
        },
        {
          "value": "XA"
        },
        {
          "value": "DISABLED"
        }
      ],
      "name": "io.quarkus.agroal.runtime.TransactionIntegration",
      "sourceType": "io.quarkus.agroal.runtime.TransactionIntegration"
    },
    {
      "values": [
        {
          "value": "UNDEFINED"
        },
        {
          "value": "NONE"
        },
        {
          "value": "READ_UNCOMMITTED"
        },
        {
          "value": "READ_COMMITTED"
        },
        {
          "value": "REPEATABLE_READ"
        },
        {
          "value": "SERIALIZABLE"
        }
      ],
      "name": "io.agroal.api.configuration.AgroalConnectionFactoryConfiguration.TransactionIsolation",
      "sourceType": "io.agroal.api.configuration.AgroalConnectionFactoryConfiguration.TransactionIsolation"
    },
    {
      "values": [
        {
          "value": "URL"
        },
        {
          "value": "APACHE"
        }
      ],
      "name": "io.quarkus.dynamodb.runtime.SyncHttpClientBuildTimeConfig.SyncClientType",
      "sourceType": "io.quarkus.dynamodb.runtime.SyncHttpClientBuildTimeConfig.SyncClientType"
    },
    {
      "values": [
        {
          "value": "DEFAULT"
        },
        {
          "value": "STATIC"
        },
        {
          "value": "SYSTEM_PROPERTY"
        },
        {
          "value": "ENV_VARIABLE"
        },
        {
          "value": "PROFILE"
        },
        {
          "value": "CONTAINER"
        },
        {
          "value": "INSTANCE_PROFILE"
        },
        {
          "value": "PROCESS"
        },
        {
          "value": "ANONYMOUS"
        }
      ],
      "name": "io.quarkus.dynamodb.runtime.AwsCredentialsProviderType",
      "sourceType": "io.quarkus.dynamodb.runtime.AwsCredentialsProviderType"
    },
    {
      "values": [
        {
          "value": "NONE"
        },
        {
          "value": "SYSTEM_PROPERTY"
        },
        {
          "value": "FILE_STORE"
        }
      ],
      "name": "io.quarkus.dynamodb.runtime.TlsManagersProviderType",
      "sourceType": "io.quarkus.dynamodb.runtime.TlsManagersProviderType"
    },
    {
      "values": [
        {
          "value": "HTTP1_1"
        },
        {
          "value": "HTTP2"
        }
      ],
      "name": "software.amazon.awssdk.http.Protocol",
      "sourceType": "software.amazon.awssdk.http.Protocol"
    },
    {
      "values": [
        {
          "value": "JDK"
        },
        {
          "value": "OPENSSL"
        },
        {
          "value": "OPENSSL_REFCNT"
        }
      ],
      "name": "io.netty.handler.ssl.SslProvider",
      "sourceType": "io.netty.handler.ssl.SslProvider"
    },
    {
      "values": [
        {
          "value": "FROM_CONFIG"
        },
        {
          "value": "VERBATIM"
        },
        {
          "value": "KEBAB_CASE"
        }
      ],
      "name": "io.quarkus.arc.config.ConfigProperties.NamingStrategy",
      "sourceType": "io.quarkus.arc.config.ConfigProperties.NamingStrategy"
    },
    {
      "values": [
        {
          "value": "BLOCK"
        },
        {
          "value": "DISCARD"
        }
      ],
      "name": "org.jboss.logmanager.handlers.AsyncHandler.OverflowAction",
      "sourceType": "org.jboss.logmanager.handlers.AsyncHandler.OverflowAction"
    },
    {
      "values": [
        {
          "value": "KERNEL"
        },
        {
          "value": "USER_LEVEL"
        },
        {
          "value": "MAIL_SYSTEM"
        },
        {
          "value": "SYSTEM_DAEMONS"
        },
        {
          "value": "SECURITY"
        },
        {
          "value": "SYSLOGD"
        },
        {
          "value": "LINE_PRINTER"
        },
        {
          "value": "NETWORK_NEWS"
        },
        {
          "value": "UUCP"
        },
        {
          "value": "CLOCK_DAEMON"
        },
        {
          "value": "SECURITY2"
        },
        {
          "value": "FTP_DAEMON"
        },
        {
          "value": "NTP"
        },
        {
          "value": "LOG_AUDIT"
        },
        {
          "value": "LOG_ALERT"
        },
        {
          "value": "CLOCK_DAEMON2"
        },
        {
          "value": "LOCAL_USE_0"
        },
        {
          "value": "LOCAL_USE_1"
        },
        {
          "value": "LOCAL_USE_2"
        },
        {
          "value": "LOCAL_USE_3"
        },
        {
          "value": "LOCAL_USE_4"
        },
        {
          "value": "LOCAL_USE_5"
        },
        {
          "value": "LOCAL_USE_6"
        },
        {
          "value": "LOCAL_USE_7"
        }
      ],
      "name": "org.jboss.logmanager.handlers.SyslogHandler.Facility",
      "sourceType": "org.jboss.logmanager.handlers.SyslogHandler.Facility"
    },
    {
      "values": [
        {
          "value": "RFC5424"
        },
        {
          "value": "RFC3164"
        }
      ],
      "name": "org.jboss.logmanager.handlers.SyslogHandler.SyslogType",
      "sourceType": "org.jboss.logmanager.handlers.SyslogHandler.SyslogType"
    },
    {
      "values": [
        {
          "value": "TCP"
        },
        {
          "value": "UDP"
        },
        {
          "value": "SSL_TCP"
        }
      ],
      "name": "org.jboss.logmanager.handlers.SyslogHandler.Protocol",
      "sourceType": "org.jboss.logmanager.handlers.SyslogHandler.Protocol"
    },
    {
      "values": [
        {
          "value": "HTTP"
        },
        {
          "value": "HTTPS"
        }
      ],
      "name": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.ElasticsearchClientProtocol",
      "sourceType": "io.quarkus.hibernate.search.elasticsearch.runtime.HibernateSearchElasticsearchRuntimeConfig.ElasticsearchClientProtocol"
    },
    {
      "values": [
        {
          "value": "NONE"
        },
        {
          "value": "VALIDATE"
        },
        {
          "value": "UPDATE"
        },
        {
          "value": "CREATE"
        },
        {
          "value": "DROP_AND_CREATE"
        },
        {
          "value": "DROP_AND_CREATE_AND_DROP"
        }
      ],
      "name": "org.hibernate.search.backend.elasticsearch.index.IndexLifecycleStrategyName",
      "sourceType": "org.hibernate.search.backend.elasticsearch.index.IndexLifecycleStrategyName"
    },
    {
      "values": [
        {
          "value": "GREEN"
        },
        {
          "value": "YELLOW"
        },
        {
          "value": "RED"
        }
      ],
      "name": "org.hibernate.search.backend.elasticsearch.index.IndexStatus",
      "sourceType": "org.hibernate.search.backend.elasticsearch.index.IndexStatus"
    },
    {
      "values": [
        {
          "value": "SKIP"
        },
        {
          "value": "PERSISTENCE_CONTEXT"
        },
        {
          "value": "PERSISTENCE_CONTEXT_THEN_SECOND_LEVEL_CACHE"
        }
      ],
      "name": "org.hibernate.search.mapper.orm.search.loading.EntityLoadingCacheLookupStrategy",
      "sourceType": "org.hibernate.search.mapper.orm.search.loading.EntityLoadingCacheLookupStrategy"
    },
    {
      "values": [
        {
          "value": "ALL"
        },
        {
          "value": "ANY"
        },
        {
          "value": "DISABLED"
        }
      ],
      "name": "org.keycloak.representations.adapters.config.PolicyEnforcerConfig.ScopeEnforcementMode",
      "sourceType": "org.keycloak.representations.adapters.config.PolicyEnforcerConfig.ScopeEnforcementMode"
    },
    {
      "values": [
        {
          "value": "PERMISSIVE"
        },
        {
          "value": "ENFORCING"
        },
        {
          "value": "DISABLED"
        }
      ],
      "name": "org.keycloak.representations.adapters.config.PolicyEnforcerConfig.EnforcementMode",
      "sourceType": "org.keycloak.representations.adapters.config.PolicyEnforcerConfig.EnforcementMode"
    },
    {
      "values": [
        {
          "value": "Managed"
        },
        {
          "value": "Shared"
        }
      ],
      "name": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig.Kind",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig.Kind"
    },
    {
      "values": [
        {
          "value": "ReadWrite"
        },
        {
          "value": "ReadOnly"
        },
        {
          "value": "None"
        }
      ],
      "name": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig.CachingMode",
      "sourceType": "io.quarkus.kubernetes.deployment.AzureDiskVolumeConfig.CachingMode"
    },
    {
      "values": [
        {
          "value": "WEB_APP"
        },
        {
          "value": "SERVICE"
        }
      ],
      "name": "io.quarkus.oidc.runtime.OidcTenantConfig.ApplicationType",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.ApplicationType"
    },
    {
      "values": [
        {
          "value": "BASIC"
        },
        {
          "value": "POST"
        }
      ],
      "name": "io.quarkus.oidc.runtime.OidcTenantConfig.Credentials.Secret.Method",
      "sourceType": "io.quarkus.oidc.runtime.OidcTenantConfig.Credentials.Secret.Method"
    },
    {
      "values": [
        {
          "value": "CRON4J"
        },
        {
          "value": "QUARTZ"
        },
        {
          "value": "UNIX"
        },
        {
          "value": "SPRING"
        }
      ],
      "name": "com.cronutils.model.CronType",
      "sourceType": "com.cronutils.model.CronType"
    },
    {
      "values": [
        {
          "value": "ENABLED"
        },
        {
          "value": "REDIRECT"
        },
        {
          "value": "DISABLED"
        }
      ],
      "name": "io.quarkus.vertx.http.runtime.HttpConfiguration.InsecureRequests",
      "sourceType": "io.quarkus.vertx.http.runtime.HttpConfiguration.InsecureRequests"
    },
    {
      "values": [
        {
          "value": "NONE"
        },
        {
          "value": "REQUEST"
        },
        {
          "value": "REQUIRED"
        }
      ],
      "name": "io.vertx.core.http.ClientAuth",
      "sourceType": "io.vertx.core.http.ClientAuth"
    },
    {
      "values": [
        {
          "value": "RS256"
        },
        {
          "value": "RS384"
        },
        {
          "value": "RS512"
        },
        {
          "value": "ES256"
        },
        {
          "value": "ES384"
        },
        {
          "value": "ES512"
        },
        {
          "value": "HS256"
        },
        {
          "value": "HS384"
        },
        {
          "value": "HS512"
        }
      ],
      "name": "io.smallrye.jwt.algorithm.SignatureAlgorithm",
      "sourceType": "io.smallrye.jwt.algorithm.SignatureAlgorithm"
    },
    {
      "values": [
        {
          "value": "PEM_KEY"
        },
        {
          "value": "PEM_CERTIFICATE"
        },
        {
          "value": "JWK"
        },
        {
          "value": "JWK_BASE64URL"
        },
        {
          "value": "ANY"
        }
      ],
      "name": "io.smallrye.jwt.KeyFormat",
      "sourceType": "io.smallrye.jwt.KeyFormat"
    }
  ]
}